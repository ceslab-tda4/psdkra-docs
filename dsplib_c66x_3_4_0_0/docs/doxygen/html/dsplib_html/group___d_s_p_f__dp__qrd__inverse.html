<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DSPLIB: DSPF_dp_qrd_inverse</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>DSPF_dp_qrd_inverse<br>
<small>
[<a class="el" href="group___d_s_p_f__dp__qrd.html">DSPF_dp_qrd</a>,&nbsp;<a class="el" href="group___d_s_p_f__dp__qrd__cmplx.html">DSPF_dp_qrd_cmplx</a>]</small>
</h1>
<p>
Collaboration diagram for DSPF_dp_qrd_inverse:<center><table><tr><td><img src="group___d_s_p_f__dp__qrd__inverse.gif" border="0" alt="" usemap="#group______d__s__p__f____dp____qrd____inverse_map">
<map name="group______d__s__p__f____dp____qrd____inverse_map">
<area href="group___d_s_p_f__dp__qrd.html" shape="rect" coords="27,5,133,32" alt="">
<area href="group___d_s_p_f__dp__qrd__cmplx.html" shape="rect" coords="5,56,155,83" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_s_p_f__dp__qrd__inverse.html#g39e5e566e12c6644d03f32d7e92c200e">DSPF_dp_qrd_inverse</a> (const int Nrows, const int Ncols, double *restrict Q, double *restrict R, double *restrict inv_A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_s_p_f__dp__qrd__inverse.html#g0beb1dcd4824759f645b20bfddf6775c">DSPF_dp_qrd_inverse_cmplx</a> (const int Nrows, const int Ncols, double *restrict Q, double *restrict R, double *restrict inv_A)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g39e5e566e12c6644d03f32d7e92c200e"></a><!-- doxytag: member="c66/DSPF_dp_qrd.h::DSPF_dp_qrd_inverse" ref="g39e5e566e12c6644d03f32d7e92c200e" args="(const int Nrows, const int Ncols, double *restrict Q, double *restrict R, double *restrict inv_A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DSPF_dp_qrd_inverse           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>Nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>Ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>inv_A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function processes an orthogonal matrix Q, and an upper triangular matrix R generated by DSPF_dp_qrd and generates the inverse of the A matrix where inv_A=inv(R)*inv(Q). In place processing is performed on the R matrix such that its original contents are modified. The values stored in the matrices are assumed to be double precision floating point values. This code is suitable for dense matrices. No optimizations are made for sparse matrices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Nrows</em>&nbsp;</td><td>= number of rows in matrix A </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ncols</em>&nbsp;</td><td>= number of columns in matrix A </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>= pointer to lower triangular matrix Q[Nrows*Nrows] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>= pointer to upper triangular matrix R[Nrows*Ncols] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inv_A</em>&nbsp;</td><td>= pointer to inverse of matrix A[Nrows*Ncols]</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Algorithm:</b></dt><dd>DSPF_dp_qrd_cn.c is the natural C equivalent of the optimized intrinsic C code without restrictions. Note that the intrinsic C code is optimized and restrictions may apply.</dd></dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd>The arrays Q, R, and inv_A are stored in distinct arrays. In-place processing of R is done. <br>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><b>Interruptibility</b> : The code is interruptible. <br>
 <b>Endian</b> support : supports both Little and Big endian modes. <br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0beb1dcd4824759f645b20bfddf6775c"></a><!-- doxytag: member="c66/DSPF_dp_qrd_cmplx.h::DSPF_dp_qrd_inverse_cmplx" ref="g0beb1dcd4824759f645b20bfddf6775c" args="(const int Nrows, const int Ncols, double *restrict Q, double *restrict R, double *restrict inv_A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DSPF_dp_qrd_inverse_cmplx           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>Nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>Ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>inv_A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function processes an orthogonal matrix Q, and an upper triangular matrix R generated by DSPF_dp_qrd and generates the inverse of the A matrix where inv_A=inv(R)*inv(Q). In place processing is performed on the R matrix such that its original contents are modified. The values stored in the matrices are assumed to be double precision floating point values. This code is suitable for dense matrices. No optimizations are made for sparse matrices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Nrows</em>&nbsp;</td><td>= number of rows in matrix A </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ncols</em>&nbsp;</td><td>= number of columns in matrix A </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>= pointer to lower triangular matrix Q[Nrows*2*Nrows] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>= pointer to upper triangular matrix R[Nrows*2*Ncols] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inv_A</em>&nbsp;</td><td>= pointer to inverse of matrix A[Nrows*2*Ncols]</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Algorithm:</b></dt><dd>DSPF_dp_qrd_cmplx_cn.c is the natural C equivalent of the optimized intrinsic C code without restrictions. Note that the intrinsic C code is optimized and restrictions may apply.</dd></dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd>1. The arrays Q, R, and inv_A are stored in distinct arrays. In-place processing of R is done. <br>
 2. The arrays consist of complex number entries with alternating real and imaginary parts: real0,imag0,real1,imag1,... <br>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><b>Interruptibility</b> : The code is interruptible. <br>
 <b>Endian</b> support : supports both Little and Big endian modes. <br>
 </dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2014, Texas Instruments Incorporated</small>
</body>
</html>
