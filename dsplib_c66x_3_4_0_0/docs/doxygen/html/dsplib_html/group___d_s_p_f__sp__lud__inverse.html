<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DSPLIB: DSPF_sp_lud_inverse</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>DSPF_sp_lud_inverse<br>
<small>
[<a class="el" href="group___m_a_t_r_i_x.html">Matrix</a>]</small>
</h1>
<p>
Collaboration diagram for DSPF_sp_lud_inverse:<center><table><tr><td><img src="group___d_s_p_f__sp__lud__inverse.gif" border="0" alt="" usemap="#group______d__s__p__f____sp____lud____inverse_map">
<map name="group______d__s__p__f____sp____lud____inverse_map">
<area href="group___m_a_t_r_i_x.html" shape="rect" coords="5,5,64,32" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_s_p_f__sp__lud__inverse.html#g7e961846ec42ceb0d6ec81c64a5d0891">DSPF_sp_lud_inverse</a> (const int order, unsigned short *restrict P, float *restrict L, float *restrict U, float *restrict inv_A)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g7e961846ec42ceb0d6ec81c64a5d0891"></a><!-- doxytag: member="c66/DSPF_sp_lud_inv.h::DSPF_sp_lud_inverse" ref="g7e961846ec42ceb0d6ec81c64a5d0891" args="(const int order, unsigned short *restrict P, float *restrict L, float *restrict U, float *restrict inv_A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DSPF_sp_lud_inverse           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *restrict&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *restrict&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *restrict&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *restrict&nbsp;</td>
          <td class="paramname"> <em>inv_A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function processes a permutation matrix P, a lower triangular matrix L, and an upper triangular matrix U generated by DSPF_sp_lud_inv and generates the inverse of the A matrix where inv_A=inv(U)*inv(L)*P. In place processing is performed on the L and U matrices such that their original contents are modified. The values stored in the matrices are assumed to be single precision floating point values. This code is suitable for dense matrices. No optimizations are made for sparse matrices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>= order of matrix A </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>= pointer to permutation matrix P[order*order] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>= pointer to lower triangular matrix L[order*order] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>= pointer to upper triangular matrix U[order*order] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inv_A</em>&nbsp;</td><td>= pointer to inverse of A matrix[order*order]</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Algorithm:</b></dt><dd>DSPF_sp_lud_inverse.c is the natural C equivalent of the optimized intrinsic C code without restrictions. Note that the intrinsic C code is optimized and restrictions may apply.</dd></dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd>The arrays P, L, U, and inv_A are stored in distinct arrays. In-place processing of L and U is done. <br>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><b>Interruptibility</b> : The code is interruptible. <br>
 <b>Endian</b> support : supports both Little and Big endian modes. <br>
 </dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2014, Texas Instruments Incorporated</small>
</body>
</html>
