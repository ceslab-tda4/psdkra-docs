<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>Ethernet Firmware: Porting Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ethernet Firmware
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ethfw_c_porting_top.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Porting Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ethfw_porting_intro">Introduction</a></li>
<li class="level1"><a href="#ethfw_porting_board_init">Board initialization</a><ul><li class="level2"><a href="#ethfw_porting_board_init_mii">Ethernet port interface type selection</a></li>
<li class="level2"><a href="#ethfw_porting_board_init_sciclient">Enabling modules via SciClient</a></li>
<li class="level2"><a href="#ethfw_porting_board_init_pinmux">Pinmux settings</a></li>
<li class="level2"><a href="#ethfw_porting_board_init_phy">Ethernet PHY initialization</a></li>
<li class="level2"><a href="#ethfw_porting_board_init_serdes">SerDes configuration</a><ul><li class="level3"><a href="#ethfw_porting_board_init_serdes_clks">Clock configuration</a></li>
<li class="level3"><a href="#ethfw_porting_board_init_serdes_mod">SerDes module configuration</a></li>
</ul>
</li>
<li class="level2"><a href="#ethfw_porting_board_init_cpsw">CPSW clocks configuration</a></li>
</ul>
</li>
<li class="level1"><a href="#ethfw_porting_mac_pool">MAC address pool</a></li>
<li class="level1"><a href="#ethfw_porting_phy_cfg">MAC port and PHY configuration</a></li>
<li class="level1"><a href="#ethfw_porting_tievm">TI EVM Board Support</a></li>
<li class="level1"><a href="#ethfw_porting_guide_rev_history">Document Revision History</a></li>
</ul>
</div>
<div class="textblock"><hr/>
 <h1><a class="anchor" id="ethfw_porting_intro"></a>
Introduction</h1>
<p>The default implementation of Ethernet Firmware provided in this software package enables CPSW switch support on TI EVMs, currently supporting J721E, J7200 and J784S4 TI EVMs. So Ethernet Firmware's default implementation is board specific, and porting is required when enabling a new platform.</p>
<p>The main porting steps will be explained throughout this document, and they can be summarized into three distintive operations: <b>board initialization</b>, <b>MAC address pool initialization</b> and <b>MAC port and PHY configuration</b>.</p>
<hr/>
 <h1><a class="anchor" id="ethfw_porting_board_init"></a>
Board initialization</h1>
<p>This is a big category that encompasses any board level initialization outside of CPSW peripheral, either internal or external to the Jacinto 7 SoC. Ethernet Firmware configures CPSW peripheral using Enet LLD.</p>
<p>The configuration steps described in the following sections is not an exhaustive list, but rather the ones most commonly used.</p>
<h2><a class="anchor" id="ethfw_porting_board_init_mii"></a>
Ethernet port interface type selection</h2>
<p>The MII interface type is configurable per Ethernet port: RMII, RGMII, SGMII, QSGMII, etc. The supported interface types is SoC dependent, please refer to the TRM to find out which MII interface types are supported in a given SoC.</p>
<p>The interface type is configured Control Module's <code>CTRLMMR_ENET&lt;n&gt;_CTRL</code> register, where <code>&lt;n&gt;</code> is the port number. Note that the RGMII internal transmit delay is also configured in the same register.</p>
<p>For TI EVMs, the Ethernet port interface type is configured via PDK board library using <code>BOARD_INIT_ENETCTRL_CPSW9G</code> init flag, as follows:</p>
<div class="fragment"><div class="line">Board_initCfg boardCfg = 0U;</div><div class="line">Board_STATUS boardStatus;</div><div class="line"></div><div class="line"><span class="comment">/* Set other board config flags */</span></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">/* Request board library to configure MII interface type in ENETCTRL register */</span></div><div class="line">boardCfg |= BOARD_INIT_ENETCTRL_CPSW9G;</div><div class="line"></div><div class="line"><span class="comment">/* Initialize board library */</span></div><div class="line">boardStatus = Board_init(boardCfg);</div></div><!-- fragment --><p>Alternatively, MII interface type could also be configured by bootloader.</p>
<h2><a class="anchor" id="ethfw_porting_board_init_sciclient"></a>
Enabling modules via SciClient</h2>
<p>The SoC <em>modules</em> (such as CPSW, SerDes, UART, Timers) which are needed by Ethernet Firmware need to be explicitly turned on via <em>sciclient</em> before using them. Note that some of these modules might have already been turned on by the bootloader, so this step could be skipped for such modules.</p>
<p>The code snippet below shows the SerDes module being turned on:</p>
<div class="fragment"><div class="line">uint32_t moduleId = TISCI_DEV_SERDES_16G0;</div><div class="line"></div><div class="line">status = Sciclient_pmSetModuleState(moduleId,</div><div class="line">                                    TISCI_MSG_VALUE_DEVICE_SW_STATE_ON,</div><div class="line">                                    TISCI_MSG_FLAG_AOP | TISCI_MSG_FLAG_DEVICE_RESET_ISO,</div><div class="line">                                    SCICLIENT_SERVICE_WAIT_FOREVER);</div></div><!-- fragment --><p>This sciclient API can be used for other modules as well, passing the appropriate <code>moduleId</code>. Please refer to the Sciclient PM API Interface documentation in the PDK API Guide for further information.</p>
<p><code>EnetAppUtils_setDeviceState()</code> helper function provided as part of Enet LLD apputils can also be used to turn on and reset modules. Note that this helper function asserts that the sciclient calls return no errors.</p>
<div class="fragment"><div class="line">uint32_t moduleId = TISCI_DEV_SERDES_16G0;</div><div class="line"></div><div class="line">EnetAppUtils_setDeviceState(moduleId, TISCI_MSG_VALUE_DEVICE_SW_STATE_ON, 0U);</div></div><!-- fragment --><h2><a class="anchor" id="ethfw_porting_board_init_pinmux"></a>
Pinmux settings</h2>
<p>The bootloader will initialize a set of base pins needed for its initial operation, but may not necessarily configure all pins required for Ethernet. Those pins have to be explicitly setup by Ethernet Firmware RTOS app.</p>
<p>It's highly recommended to use TI's <a href="https://www.ti.com/tool/SYSCONFIG">SYSCONFIG</a> tool for pinmux configuration. SYSCONFIG can generate a C file output with the requested pinmux settings. The settings in this file can be directly passed to <code>Board_pinmuxUpdate()</code>, which is PDK board library's API used to update the mux configuration of a set of pins:</p>
<div class="fragment"><div class="line"><span class="comment">/* Pinmux configuration of pins used by Ethernet Firmware. */</span></div><div class="line">Board_pinmuxUpdate(gEthFwPinmuxData, BOARD_SOC_DOMAIN_MAIN);</div></div><!-- fragment --><p>It's recommended that pinmux settings done in this step is limited to the pins used for Ethernet related functionality in order to avoid overwriting the pinmux settings done by others (i.e. bootloader, other processing cores).</p>
<h2><a class="anchor" id="ethfw_porting_board_init_phy"></a>
Ethernet PHY initialization</h2>
<p>During the initialization stage of Ethernet Firmware, the Ethernet ports are <em>opened</em>, which triggers a PHY state machine in Enet LLD that takes care of configuring the Ethernet PHYs via MDIO. However, this excludes any board level setting, such as taking the PHY out of reset.</p>
<p>Often times PHYs are taken out of reset at board level at power-on reset (POR). When not, explicit action must taken - usually by driving a GPIO line. This can be done by bootloader or at this stage in Ethernet Firmware's board init.</p>
<h2><a class="anchor" id="ethfw_porting_board_init_serdes"></a>
SerDes configuration</h2>
<p>SerDes has to be configured in advance for the Ethernet ports in Q/SGMII mode. For multi-link case, where lanes of the same SerDes are configured for different functionality (i.e. Ethernet, PCIe, USB), this is typically done by the bootloader. In single-link or when all lanes are for Ethernet related functionality, the bootloader may not configure SerDes and Ethernet Firmware must do it via CSL Serdes.</p>
<h3><a class="anchor" id="ethfw_porting_board_init_serdes_clks"></a>
Clock configuration</h3>
<p>The SerDes reference clock(s) rate must be set consistently with the clock requirement of the intended SerDes function as indicated via <code>refClk</code> argument of <code>CSL_serdesRefclkSel()</code> function.</p>
<p>The code snippet below shows how the SerDes reference clocks are being configured to 100MHz for J721E SerDes used for Q/SGMII operation. It's worth noting that the clock rate set in <code>params.refClock</code> and <code>PMLIBClkRateSet()</code> are consistently set to 100MHz.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Board_CfgQsgmii(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    CSL_SerdesLaneEnableParams params;</div><div class="line">    CSL_SerdesResult result;</div><div class="line"></div><div class="line">    <span class="comment">/* QSGMII Config */</span></div><div class="line">    params.serdesInstance    = (CSL_SerdesInstance)SGMII_SERDES_INSTANCE;</div><div class="line">    params.baseAddr          = CSL_SERDES_16G0_BASE;</div><div class="line">    params.refClock          = CSL_SERDES_REF_CLOCK_100M;</div><div class="line">    params.refClkSrc         = CSL_SERDES_REF_CLOCK_INT;</div><div class="line">    params.linkRate          = CSL_SERDES_LINK_RATE_5G;</div><div class="line">    params.numLanes          = 1;</div><div class="line">    params.laneMask          = 0x2;</div><div class="line">    params.phyType           = CSL_SERDES_PHY_TYPE_QSGMII;</div><div class="line">    ...</div><div class="line"></div><div class="line">    CSL_serdesPorReset(params.baseAddr);</div><div class="line"></div><div class="line">    <span class="comment">/* Select the IP type, IP instance num, Serdes Lane Number */</span></div><div class="line">    CSL_serdesIPSelect(CSL_CTRL_MMR0_CFG0_BASE,</div><div class="line">                       params.phyType,</div><div class="line">                       params.phyInstanceNum,</div><div class="line">                       params.serdesInstance,</div><div class="line">                       SGMII_LANE_NUM);</div><div class="line"></div><div class="line">    <span class="comment">/* Set SerDes reference clock configuration */</span></div><div class="line">    result = CSL_serdesRefclkSel(CSL_CTRL_MMR0_CFG0_BASE,</div><div class="line">                                 params.baseAddr,</div><div class="line">                                 params.refClock,</div><div class="line">                                 params.refClkSrc,</div><div class="line">                                 params.serdesInstance,</div><div class="line">                                 params.phyType);</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> EthFwBoard_configureSerdesClock(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t moduleId = TISCI_DEV_SERDES_16G0;</div><div class="line">    uint32_t clkId;</div><div class="line">    uint32_t clkRateHz;</div><div class="line"></div><div class="line">    <span class="comment">/* Set rate of SerDes CORE_REFCLK1 to 100M */</span></div><div class="line">    clkId     = TISCI_DEV_SERDES_16G0_CORE_REF1_CLK;</div><div class="line">    clkRateHz = 100000000U;</div><div class="line">    PMLIBClkRateSet(moduleId, clkId, clkRateHz);</div><div class="line"></div><div class="line">    <span class="comment">/* Set rate of SerDes CORE_REFCLK to 100M */</span></div><div class="line">    clkId     = TISCI_DEV_SERDES_16G0_CORE_REF_CLK;</div><div class="line">    clkRateHz = 100000000U;</div><div class="line">    PMLIBClkRateSet(moduleId, clkId, clkRateHz);</div><div class="line"></div><div class="line">    <span class="comment">/* Turn on SerDes module, take it out of reset */</span></div><div class="line">    EnetAppUtils_setDeviceState(moduleId, TISCI_MSG_VALUE_DEVICE_SW_STATE_ON, 0U);</div><div class="line">}</div></div><!-- fragment --><p>Alternatively, user may choose to use Enet LLD's <code>EnetAppUtils_clkRateSet()</code> helper function to set the clocks. This is a simple wrapper on top of PDK PM library APIs.</p>
<h3><a class="anchor" id="ethfw_porting_board_init_serdes_mod"></a>
SerDes module configuration</h3>
<p>SerDes module configuration is done using CSL SerDes APIs. For TI EVM support, PDK Board library provides helper functions, such as <code>Board_serdesCfgSgmii()</code> and <code>Board_serdesCfgQsgmii()</code> to configure SerDes according to TI EVM capabilities. Ethernet Firmware uses these helper functions. Users may choose to implement their own SerDes configuration functions using CSL.</p>
<p>The CSL SerDes library support can be found at the following locations:</p><ul>
<li>J721E: <code>&lt;pdk&gt;/packages/ti/csl/src/ip/serdes_cd/V0</code></li>
<li>J7200: <code>&lt;pdk&gt;/packages/ti/csl/src/ip/serdes_cd/V1</code></li>
<li>J721S2: <code>&lt;pdk&gt;/packages/ti/csl/src/ip/serdes_cd/V2</code></li>
<li>J784S4: <code>&lt;pdk&gt;/packages/ti/csl/ src/ip/serdes_cd/V3</code></li>
</ul>
<h2><a class="anchor" id="ethfw_porting_board_init_cpsw"></a>
CPSW clocks configuration</h2>
<p>Similar to any other SoC module, CPSW clocks must be configured and the module must be explicitly turned on via Sciclient.</p>
<p>The following clocks must be configured for proper operation of CPSW: <code>CPPI_CLK_CLK</code>, <code>RGMII_MHZ_5_CLK</code>, <code>RGMII_MHZ_CLK</code>, and <code>RGMII_MHZ_250_CLK</code>. Optionally, when using time synchronization, CPTS source clock must also be configured, the source is selected from a list of possible sources which is SoC dependent. Please refer to TRM of the specific SoC being used.</p>
<div class="fragment"><div class="line">uint32_t moduleId = TISCI_DEV_CPSW0;</div><div class="line">uint32_t appFlags = TISCI_MSG_FLAG_DEVICE_EXCLUSIVE;</div><div class="line">uint64_t cppiClkFreqHz = 0U;</div><div class="line"></div><div class="line"><span class="comment">/* Set rate of CPPI_CLK */</span></div><div class="line">cppiClkFreqHz = EnetSoc_getClkFreq(enetType, instId, CPSW_CPPI_CLK);</div><div class="line">PMLIBClkRateSet(moduleId, TISCI_DEV_CPSW0_CPPI_CLK_CLK, clkRateHz);</div><div class="line"></div><div class="line"><span class="comment">/* Set rate of RGMII clocks */</span></div><div class="line">PMLIBClkRateSet(moduleId, TISCI_DEV_CPSW0_RGMII_MHZ_250_CLK, 250000000U);</div><div class="line">PMLIBClkRateSet(moduleId, TISCI_DEV_CPSW0_RGMII_MHZ_50_CLK, 50000000U);</div><div class="line">PMLIBClkRateSet(moduleId, TISCI_DEV_CPSW0_RGMII_MHZ_5_CLK, 5000000U);</div><div class="line"></div><div class="line"><span class="comment">/* Turn on CPSW module, take it out of reset */</span></div><div class="line">EnetAppUtils_setDeviceState(moduleId, TISCI_MSG_VALUE_DEVICE_SW_STATE_ON, appFlags);</div></div><!-- fragment --><p>Alternatively, user may choose to use Enet LLD's helper functions as shown below:</p>
<div class="fragment"><div class="line"><span class="comment">/* CPTS clock source */</span></div><div class="line"><span class="preprocessor">#define ETHFW_CPSW_CPTS_RFT_CLK                 (ENET_CPSW0_CPTS_CLKSEL_MAIN_SYSCLK0)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> EthFwBoard_configCpswClocks(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Enable CPPI_CLK_CLK and set RGMII_MHZ_[5,50,250]_CLK clock rate */</span></div><div class="line">    EnetAppUtils_enableClocks(ENET_CPSW_9G, 0U);</div><div class="line"></div><div class="line">    <span class="comment">/* Select CPTS source clock (CPTS_RFT_CLK) in CLKSEL mux */</span></div><div class="line">    EnetAppUtils_selectCptsClock(ENET_CPSW_9G, 0U, ETHFW_CPSW_CPTS_RFT_CLK);</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="ethfw_c_porting_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_porting_mac_pool"></a>
MAC address pool</h1>
<p>Ethernet Firmware requires a pool of MAC addresses to be used during its lifecycle, for its own usage and for the virtual MAC clients. A MAC address is given to each virtual client as they attach to Ethernet Firmware at runtime.</p>
<p>The pool size requirement is as follows:</p><ul>
<li>One MAC address for Ethernet Firmware. This is used by the Ethernet Firmware lwIP stack running on Main R5F.</li>
<li>One MAC address for each virtual network interface for Linux, QNX or RTOS clients.<ul>
<li>Processing cores that enable multiple virtual interfaces require as many MAC addresses.</li>
<li>For instance, Linux and RTOS clients enable <a class="el" href="ethfw_c_ug_top.html#ethfw_virtual_switch_port">Virtual switch port</a> and <a class="el" href="ethfw_c_ug_top.html#ethfw_virtual_mac_port">Virtual MAC port</a>, hence they require two MAC addresses.</li>
</ul>
</li>
<li>One MAC address for AUTOSAR virtual MAC.</li>
</ul>
<p>It's worth noting that the required MAC address pool can exceed the number of physical Ethernet ports, as the pool size also depends on the number of virtual clients being enabled.</p>
<p>In the default implementation of Ethernet Firmware for TI EVMs, a total of 6 x MAC addresses are required for Linux and RTOS SDK releases.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Count  </th><th class="markdownTableHeadCenter">Owner  </th><th class="markdownTableHeadCenter">Core  </th><th class="markdownTableHeadLeft">Usage   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">Ethernet Firmware  </td><td class="markdownTableBodyCenter">mcu2_0  </td><td class="markdownTableBodyLeft">lwIP stack   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter" rowspan="2">2  </td><td class="markdownTableBodyCenter" rowspan="2">Linux virtual clients  </td><td class="markdownTableBodyCenter" rowspan="2">mpu1_0  </td><td class="markdownTableBodyLeft">1 x virtual switch port (eth1)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">1 x virtual MAC port (eth2)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter" rowspan="2">2  </td><td class="markdownTableBodyCenter" rowspan="2">RTOS virtual clients  </td><td class="markdownTableBodyCenter" rowspan="2">mcu2_1  </td><td class="markdownTableBodyLeft">1 x virtual switch port (netif1)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">1 x virtual MAC port (netif2)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">AUTOSAR virtual MAC  </td><td class="markdownTableBodyCenter">mcu2_1  </td><td class="markdownTableBodyLeft">1 x virtual switch port   </td></tr>
</table>
<p>For QNX SDK releases, a total of 4 x MAC addresses are required as MAC-only feature is not enabled which reduces the overall count.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Count  </th><th class="markdownTableHeadCenter">Owner  </th><th class="markdownTableHeadCenter">Core  </th><th class="markdownTableHeadLeft">Usage   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">Ethernet Firmware  </td><td class="markdownTableBodyCenter">mcu2_0  </td><td class="markdownTableBodyLeft">lwIP stack   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">QNX virtual client  </td><td class="markdownTableBodyCenter">mpu1_0  </td><td class="markdownTableBodyLeft">1 x virtual switch port   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">RTOS virtual clients  </td><td class="markdownTableBodyCenter">mcu2_1  </td><td class="markdownTableBodyLeft">1 x virtual switch port   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">AUTOSAR virtual MAC  </td><td class="markdownTableBodyCenter">mcu2_1  </td><td class="markdownTableBodyLeft">1 x virtual switch port   </td></tr>
</table>
<p>The pool of MAC addresses is usually provisioned in an EEPROM memory, so the Ethernet Firmware RTOS application must read them from that memory and populate the pool which is passed to Ethernet Firmware at open time via <a href="../api_guide/html_/structEthFw__Config.html"><b>EthFw_Config</b></a>.</p>
<p>The code snippet below shows the configuration parameters where the MAC address pool must be populated:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ETHAPP_MAC_ADDR_POOL_SIZE               (6U)</span></div><div class="line"></div><div class="line">int32_t EthApp_initEthFw(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    EthFw_Config ethFwCfg;</div><div class="line">    Cpsw_Cfg *cpswCfg = &amp;ethFwCfg.cpswCfg;</div><div class="line">    EnetRm_MacAddressPool *pool = &amp;cpswCfg-&gt;resCfg.macList;</div><div class="line">    uint32_t poolSize;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* Populate MAC address pool */</span></div><div class="line">    poolSize = EnetUtils_min(ENET_ARRAYSIZE(pool-&gt;macAddress), ETHAPP_MAC_ADDR_POOL_SIZE);</div><div class="line">    pool-&gt;numMacAddress = EthFwBoard_getMacAddrPool(pool-&gt;macAddress, poolSize);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize EthFw */</span></div><div class="line">    gEthAppObj.hEthFw = EthFw_init(gEthAppObj.enetType, &amp;ethFwCfg);</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line">uint32_t EthFwBoard_getMacAddrPool(uint8_t macAddr[][ENET_MAC_ADDR_LEN],</div><div class="line">                                   uint32_t poolSize)</div><div class="line">{</div><div class="line">    uint32_t allocCnt;</div><div class="line"></div><div class="line">    <span class="comment">/* Read MAC addresses from EEPROM */</span></div><div class="line">    allocCnt = EthFwBoard_getMacAddrPoolEeprom(macAddr, poolSize);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> allocCnt;</div><div class="line">}</div></div><!-- fragment --><p>In TI Jacinto 7 EVMs, the EEPROMs in the expansion boards are flashed with a number of MAC addresses:</p><ul>
<li>EEPROM in GESI expansion board has 5 MAC addresses.</li>
<li>EEPROM in QpENet expansion board (QSGMII) has 4 MAC addreses.</li>
</ul>
<p><b>Note:</b> In TI EVMs, there is a potential conflict when Ethernet Firmware tries to read EEPROM memories via I2C at the same time that another processing core (i.e. A72) is also using the same I2C bus (see <a href="https://sir.ext.ti.com/jira/browse/EXT_EP-10020">ETHFW-1580</a>). Due to this limitation, Ethernet Firmware uses a static MAC address pool for Linux/QNX SDKs as a temporary workaround. <b>The static MAC address pool must not be used in production code.</b></p>
<p><a class="el" href="ethfw_c_porting_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_porting_phy_cfg"></a>
MAC port and PHY configuration</h1>
<p>The RTOS application passes to Ethernet Firmware the list of MAC ports intended to be used. Ethernet Firmware then enables each of them during its initialization stage when <a href="../api_guide/html_/group__ETHFW__LIB__API.html#ga41135bde04b458fc86b70b2448c0e5a3"><b>EthFw_init()</b></a> is called. At that time, Ethernet Firmware will call the <a href="../api_guide/html_/structEthFw__Config.html#a25336535f220df239805c80dd3e5d738"><b>EthFw_Config.setPortCfg()</b></a> callback for each MAC port.</p>
<p>It's expected that the implementation of <a href="../api_guide/html_/structEthFw__Config.html#a25336535f220df239805c80dd3e5d738"><b>EthFw_Config.setPortCfg()</b></a> callback will:</p><ul>
<li>Set the MII interface type: RMII, RGMII, Q/SGMII, etc.</li>
<li>Set the link configuration: auto-negotiation or fixed (speed/duplexity)</li>
<li>Set the PHY configuration: PHY address, PHY specific parameters, strap, etc.<ul>
<li>For MAC-to-MAC connection, PHY address must be set to <code>ENETPHY_INVALID_PHYADDR</code>.</li>
</ul>
</li>
<li>Set SGMII mode (for Q/SGMII ports only).</li>
</ul>
<p>The following code snippet shows the relevant functions and configuration parameters involved in MAC and PHY configuration:</p>
<div class="fragment"><div class="line">Enet_MacPort gEthAppPorts[] =</div><div class="line">{</div><div class="line">    ENET_MAC_PORT_1, <span class="comment">/* RGMII */</span></div><div class="line">    ENET_MAC_PORT_2, <span class="comment">/* QSGMII main */</span></div><div class="line">    ENET_MAC_PORT_3, <span class="comment">/* RGMII */</span></div><div class="line">    ENET_MAC_PORT_4, <span class="comment">/* RGMII */</span></div><div class="line">    ENET_MAC_PORT_5, <span class="comment">/* QSGMII sub */</span></div><div class="line">    ENET_MAC_PORT_6, <span class="comment">/* QSGMII sub */</span></div><div class="line">    ENET_MAC_PORT_7, <span class="comment">/* QSGMII sub */</span></div><div class="line">    ENET_MAC_PORT_8, <span class="comment">/* RGMII */</span></div><div class="line">};</div><div class="line"></div><div class="line">int32_t EthApp_initEthFw(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    EthFw_Config ethFwCfg;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* Set hardware port configuration parameters */</span></div><div class="line">    ethFwCfg.ports    = &amp;gEthAppPorts[0];</div><div class="line">    ethFwCfg.numPorts = ARRAY_SIZE(gEthAppPorts);</div><div class="line">    ethFwCfg.setPortCfg = EthFwBoard_setPortCfg;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize EthFw */</span></div><div class="line">    gEthAppObj.hEthFw = EthFw_init(gEthAppObj.enetType, &amp;ethFwCfg);</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line">int32_t EthFwBoard_setPortCfg(Enet_MacPort macPort,</div><div class="line">                              CpswMacPort_Cfg *macCfg,</div><div class="line">                              EnetMacPort_Interface *mii,</div><div class="line">                              EnetPhy_Cfg *phyCfg,</div><div class="line">                              EnetMacPort_LinkCfg *linkCfg)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (macPort == ENET_MAC_PORT_1)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set MII type to RGMII */</span></div><div class="line">        mii-&gt;layerType    = ENET_MAC_LAYER_GMII;</div><div class="line">        mii-&gt;subLayerType = ENET_MAC_SUBLAYER_REDUCED;</div><div class="line">        mii-&gt;variantType  = ENET_MAC_VARIANT_FORCED;</div><div class="line"></div><div class="line">        <span class="comment">/* Set link configuration to auto-negotiation */</span></div><div class="line">        linkCfg-&gt;speed     = ENET_SPEED_AUTO;</div><div class="line">        linkCfg-&gt;duplexity = ENET_DUPLEX_AUTO;</div><div class="line"></div><div class="line">        <span class="comment">/* Set the RGMII PHY configuration parameters */</span></div><div class="line">        phyCfg-&gt;phyAddr         = 12U,</div><div class="line">        phyCfg-&gt;isStrapped      = <span class="keyword">false</span>,</div><div class="line">        phyCfg-&gt;skipExtendedCfg = <span class="keyword">false</span>;</div><div class="line">        phyCfg-&gt;extendedCfg     = &amp;gEnetGesiBoard_dp83867PhyCfg,</div><div class="line">        phyCfg-&gt;extendedCfgSize = <span class="keyword">sizeof</span>(gEnetGesiBoard_dp83867PhyCfg),</div><div class="line"></div><div class="line">        <span class="comment">/* SGMII mode is don&#39;t care for RGMII ports */</span></div><div class="line">        macCfg-&gt;sgmiiMode = ENET_MAC_SGMIIMODE_INVALID;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (macPort == ENET_MAC_PORT_2)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set QSGMII main port configuration parameters */</span></div><div class="line">    }</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ENET_SOK;</div><div class="line">}</div></div><!-- fragment --><p>The implementation of <code>EthFwBoard_setPortCfg()</code> for TI EVMs provided in the SDK is slightly different than the one shown in the code snippet above. Instead, it's organized based on the expansion boards supported in the different TI EVMs. This is an implementation decision, so user should choose the approach that works best for their system.</p>
<p><a class="el" href="ethfw_c_porting_top.html">Back To Top</a></p>
<hr/>
<h1><a class="anchor" id="ethfw_porting_tievm"></a>
TI EVM Board Support</h1>
<p>Starting with SDK 8.2.1, board initialization has been moved from Enet LLD to Ethernet Firmware repository:</p><ul>
<li>Old location is <code>&lt;pdk&gt;/packages/ti/drv/enet/examples/utils/V1/</code>.</li>
<li>New location is <code>&lt;ethfw&gt;/utils/board/</code>.</li>
</ul>
<p>This implementation is specific to TI EVMs (Ethernet port configuration, PHYs being used, etc), and can be used as reference when porting Ethernet Firmware to a new platform.</p>
<p>It has been made a separate library because it's required in two scenarios:</p><ul>
<li>When Ethernet Firmware is built as a standalone RTOS application (i.e. when Main R5F0 core 0 is dedicated for Ethernet Firmware), and/or</li>
<li>When Ethernet Firmware is integrated in a larger RTOS application (i.e. when integrated in Vision Apps for J721E/J784S4).</li>
</ul>
<p>There EthFw board library is composed of four main board initialization functions:</p>
<ul>
<li><a href="../api_guide/html_/group__ETHFW__BOARD__UTILS.html#ga8625aa9f3642ecc8b5122560fc6ac626"><b>EthFwBoard_init()</b></a>. Implements the board initialization steps described in <a class="el" href="ethfw_c_porting_top.html#ethfw_porting_board_init">Board initialization</a> section.</li>
<li><a href="../api_guide/html_/group__ETHFW__BOARD__UTILS.html#ga6b188c815f14dc8e1ab58ebbfc4fdad7"><b>EthFwBoard_getMacPorts()</b></a>. Returns the list of MAC ports supported by the EthFw board library.</li>
<li><a href="../api_guide/html_/group__ETHFW__BOARD__UTILS.html#gacf09b70f8441308445d6fb8906d187dc"><b>EthFwBoard_setPortCfg()</b></a>. Implements the MAC/PHY configuration callback described in <a class="el" href="ethfw_c_porting_top.html#ethfw_porting_phy_cfg">MAC port and PHY configuration</a>.</li>
<li><a href="../api_guide/html_/group__ETHFW__BOARD__UTILS.html#gae0ae6187fa1ab8991ff25250f8248822"><b>EthFwBoard_getMacAddrPool()</b></a>. Populates the MAC address pool with values read from EEPROM or static defined (TI EVM workaround).</li>
</ul>
<p><a class="el" href="ethfw_c_porting_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_porting_guide_rev_history"></a>
Document Revision History</h1>
<hr/>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Revision  </th><th class="markdownTableHeadNone">Date  </th><th class="markdownTableHeadNone">Author  </th><th class="markdownTableHeadNone">Description ------&mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.1  </td><td class="markdownTableBodyNone">25 Aug 2022  </td><td class="markdownTableBodyNone">Misael Lopez  </td><td class="markdownTableBodyNone">Initial version of porting guide   </td></tr>
</table>
<p><a class="el" href="ethfw_c_porting_top.html">Back To Top</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
