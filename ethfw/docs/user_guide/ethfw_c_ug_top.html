<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>Ethernet Firmware: User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ethernet Firmware
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ethfw_c_ug_top.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ethfw_c_ug_features_list">Supported Features</a></li>
<li class="level1"><a href="#ethfw_master_core">Master Core (EthFw)</a></li>
<li class="level1"><a href="#ethfw_remote_clients">Remote Core Clients</a><ul><li class="level2"><a href="#ethfw_client_rtos">RTOS Client</a><ul><li class="level3"><a href="#ethfw_client_rtos_mcu30">Porting RTOS client to Main R5F 1 Core 0</a></li>
</ul>
</li>
<li class="level2"><a href="#ethfw_client_linux">Linux Client</a></li>
<li class="level2"><a href="#ethfw_client_qnx">QNX Client</a></li>
<li class="level2"><a href="#ethfw_client_autosar">AUTOSAR Client</a></li>
<li class="level2"><a href="#ethfw_component_location">Component Location</a></li>
</ul>
</li>
<li class="level1"><a href="#ethfw_maconly">MAC-only</a><ul><li class="level2"><a href="#ethfw_mac_port">Hardware physical ports</a></li>
<li class="level2"><a href="#ethfw_local_switch_port">Local switch port</a></li>
<li class="level2"><a href="#ethfw_virtual_switch_port">Virtual switch port</a></li>
<li class="level2"><a href="#ethfw_virtual_mac_port">Virtual MAC port</a></li>
<li class="level2"><a href="#ethfw_additional_maconly">Configuring additional ports in MAC-only mode</a></li>
</ul>
</li>
<li class="level1"><a href="#ethfw_port_cfg">Default Port Configuration</a><ul><li class="level2"><a href="#ethfw_j721e_port_cfg">J721E Port Configuration</a></li>
<li class="level2"><a href="#ethfw_j7200_port_cfg">J7200 Port Configuration</a></li>
<li class="level2"><a href="#ethfw_j784s4_port_cfg">J784S4 Port Configuration</a></li>
</ul>
</li>
<li class="level1"><a href="#ethfw_intercore_eth">Inter-core Virtual Ethernet</a><ul><li class="level2"><a href="#ethfw_intercore_topology">Topology and Design overview</a></li>
<li class="level2"><a href="#ethfw_intercore_r5server">EthFw Server integration</a></li>
<li class="level2"><a href="#ethfw_intercore_r5client">R5F RTOS Client integration</a></li>
<li class="level2"><a href="#ethfw_intercore_a72client">A72 Linux Client integration</a></li>
</ul>
</li>
<li class="level1"><a href="#ethfw_mcast_support">Multicast and Broadcast Support</a><ul><li class="level2"><a href="#ethfw_shared_mcast">Shared Multicast</a></li>
<li class="level2"><a href="#ethfw_exclusive_mcast">Exclusive Multicast</a></li>
<li class="level2"><a href="#ethfw_reserved_mcast">Reserved Multicast</a></li>
</ul>
</li>
<li class="level1"><a href="#ethfw_c_ug_ethfw_demos">EthFw Demos</a><ul><li class="level2"><a href="#ethfw_switching_demo">EthFw Switching &amp; TCP/IP Apps Demo</a></li>
<li class="level2"><a href="#ethfw_intervlan_demo">Inter-VLAN Routing Demo</a></li>
</ul>
</li>
<li class="level1"><a href="#ethfw_instal_top">Dependencies</a><ul><li class="level2"><a href="#ethfw_depend_hw">Hardware Dependencies</a><ul><li class="level3"><a href="#ethfw_depend_evm_j721e">J721E/J7200 EVM</a></li>
<li class="level3"><a href="#ethfw_depend_evm_gesi_j721e">J721E GESI Expansion Board</a></li>
<li class="level3"><a href="#ethfw_depend_evm_quadport_j721e">J721E Quad-Port Eth Expansion Board</a></li>
<li class="level3"><a href="#ethfw_depend_evm_quadport_j7200">J7200 Quad-Port Eth Expansion Board</a></li>
<li class="level3"><a href="#ethfw_depend_evm_j784s4">J784S4 EVM</a></li>
<li class="level3"><a href="#ethfw_depend_evm_quadport_j784s4">J784S4 Quad-Port Eth Expansion Board</a></li>
</ul>
</li>
<li class="level2"><a href="#ethfw_depend_sw">Software Dependencies</a><ul><li class="level3"><a href="#ethfw_depend_pdk">PDK</a><ul><li class="level4"><a href="#ethfw_depend_pdk_csl">CSL</a></li>
<li class="level4"><a href="#ethfw_depend_pdk_udma">UDMA</a></li>
<li class="level4"><a href="#ethfw_depend_pdk_enet">Enet LLD</a></li>
</ul>
</li>
<li class="level3"><a href="#ethfw_depend_lwip">lwIP</a></li>
<li class="level3"><a href="#ethfw_depend_tsn">TSN stack</a></li>
<li class="level3"><a href="#ethfw_depend_lwip_proxyarp">Ethernet Firmware Proxy ARP</a></li>
<li class="level3"><a href="#ethfw_depend_safertos">SafeRTOS</a></li>
</ul>
</li>
<li class="level2"><a href="#ethfw_instal_ccs">IDE (CCS)</a></li>
</ul>
</li>
<li class="level1"><a href="#ethfw_instal_steps">Installation Steps</a></li>
<li class="level1"><a href="#ethfw_dir">Directory Structure</a><ul><li class="level2"><a href="#ethfw_post_install_j721e">Post Install Directory Structure</a></li>
<li class="level2"><a href="#ethfw_dir_utils">Utilities Directory Structure</a></li>
<li class="level2"><a href="#ethfw_dir_demo">Demo Application Sources Directory Structure</a></li>
<li class="level2"><a href="#ethfw_dir_switch_demos">EthFw Demonstration Applications</a></li>
</ul>
</li>
<li class="level1"><a href="#ethfw_build_top">Build</a><ul><li class="level2"><a href="#ethfw_build_setup_env">Setup Environment</a></li>
<li class="level2"><a href="#ethfw_build">Build</a><ul><li class="level3"><a href="#ethfw_build_all">Build All</a></li>
<li class="level3"><a href="#ethfw_safertos_build_all">SafeRTOS Build</a></li>
<li class="level3"><a href="#ethfw_qnx_build_all">QNX Build</a></li>
</ul>
</li>
<li class="level2"><a href="#ethfw_build_clean">Clean</a><ul><li class="level3"><a href="#ethfw_build_clean_all">Clean All</a></li>
<li class="level3"><a href="#ethfw_build_clean_binaries">Remove build output</a></li>
</ul>
</li>
<li class="level2"><a href="#ethfw_build_profiles">Profiles</a></li>
<li class="level2"><a href="#ethfw_build_eg_linker">Examples Linker File (Select memory location to hold example binary)</a></li>
</ul>
</li>
<li class="level1"><a href="#ethfw_run_eg">Running Examples</a><ul><li class="level2"><a href="#ethfw_run_ccs_load_binary">Load Example Binaries</a></li>
</ul>
</li>
<li class="level1"><a href="#ethfw_uninstall">Un Installation</a></li>
<li class="level1"><a href="#ethfw_known_issues">Known issues</a></li>
<li class="level1"><a href="#ethfw_cflag">Compiler Flags used</a><ul><li class="level2"><a href="#ethfw_cflag_debug">Demo Application - Profile: Debug</a></li>
<li class="level2"><a href="#ethfw_cflag_release">Demo Application - Profile: Release</a></li>
</ul>
</li>
<li class="level1"><a href="#ethfw_supported_family">Supported Device Families</a></li>
<li class="level1"><a href="#ethfw_rev_history">Document Revision History</a></li>
</ul>
</div>
<div class="textblock"><p>Ethernet Firmware enables multiple client drivers to run independently on the remaining cores in the system. For instance, A-cores can run HLOS like Linux or QNX, and other R5F cores can run FreeRTOS or AUTOSAR software. Client drivers communicate through the central Ethernet Firmware module for any necessary switch configuration. Once setup packet are directly steered to the designated cores based on the flow steered criteria described before.</p>
<p>This user guide presents the list of features supported by the Ethernet Firmware (EthFw), and describes the steps required to build and run the EthFw demo applications.</p>
<hr/>
 <h1><a class="anchor" id="ethfw_c_ug_features_list"></a>
Supported Features</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature  </th><th class="markdownTableHeadNone">Comments -&mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">L2 switching  </td><td class="markdownTableBodyNone">Support for configuration of the Ethernet Switch to enable L2 switching between external ports with VLAN, multi-cast   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Inter-VLAN routing  </td><td class="markdownTableBodyNone">Inter-VLAN routing configuration in hardware with software fall-back support   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lwIP integration  </td><td class="markdownTableBodyNone">Integration of TCP/IP stack enabling TCP, UDP.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">MAC-only  </td><td class="markdownTableBodyNone">Port configuration in MAC-only mode for traffic exclusively forwarded to host port, excludes the designated port(s) from switching logic   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Intercore Virtual Ethernet  </td><td class="markdownTableBodyNone">Shared memory-based virtual Ethernet adapter communication between cores   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="2">Multi-core broadcast an multicast support  </td><td class="markdownTableBodyNone">Multi-core concurrent reception of broadcast and multicast traffic using SW based fan-out   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Ability to send broadcast and multicast traffic to multiple cores   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Remote configuration server  </td><td class="markdownTableBodyNone">Firmware app hosting the IPC server to serve remote clients like Linux Virtual MAC driver   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Resource management library  </td><td class="markdownTableBodyNone">Resource management library for CPSW resource sharing across cores   </td></tr>
</table>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_master_core"></a>
Master Core (EthFw)</h1>
<p>The multiport CPSW switch present in devices of the Jacinto family is an Ethernet peripheral shared among the different processing cores within the SoC. Ethernet Firmware acts as the owner of the CPSW switch and provides a remote configuration infrastructure for other processing cores running different operating systems.</p>
<p>Ethernet Firmware enables TCP/IP stack and gPTP stack, includes software and hardware interVLAN demos, as well as helper utils libraries (i.e. network statistics).</p>
<p>The following diagram shows the main components of the Ethernet Firmware software architecture.</p>
<div class="image">
<img src="switch_software_stack.png" alt="switch_software_stack.png"/>
<div class="caption">
Ethernet Firmware software architecture</div></div>
<p> The TCP/IP stack integrated in the Ethernet Firmware is based on the open source lwIP stack enabled on top of Enet LLD.</p>
<p>Ethernet Firmware sets up packet classifiers to route traffic to the different remote processing cores. Routing criterias are based on the switch ingress port number or Layer-2 destination MAC address, depending on the virtual port type requested by the remote cores. Packets which don't match any of the configured classifier criteria are routed to a default UDMA flow that is owned by Ethernet Firmware.</p>
<p>For multicast, if the traffic is exclusively requested by a single core it can be directly steered to the designated core by programming the hardware classifier module through EthFw. When multiple cores need to receive the same multicast flow, then it is always steered to the Ethernet Firmware which plays the role of central hub that replicates and fans out. Refer to the <a class="el" href="ethfw_c_ug_top.html#ethfw_mcast_support">Multicast and Broadcast Support</a> section for more information.</p>
<p>Ethernet Firmware runs gPTP stack which operates either as master or slave clock based on the gPTP configurations set, supporting both software and hardware adjustments for the CPTS clock. This PTP implementation sets up CPSW ALE classifiers with PTP multicast MAC address and PTP EtherType PTP classifier as match criteria to have PTP traffic routed to dedicated UDMA RX flow.</p>
<p>The remote configuration infrastructure provided by Ethernet Firmware is built on top of the <em>remote_device</em> framework. Ethernet Firmware plays the role of a server which accepts and processes commands from the remote clients and carry out operations such as attaching/detaching, registering a MAC address or IP, etc, on the client's behalf.</p>
<p>CPSW register configuration is carried out exclusively by Ethernet Firmware, remote cores are not expected/allowed to perform any CPSW5G/CPSW9G register access, though that is not enforced at the time of this writing. Ethernet Firmware uses Enet LLD for low-level CPSW5G/CPSW9G driver support and for Ethernet PHY configuration. Enet LLD internally uses UDMA LLD for packet exchange with the CPSW switch.</p>
<p>The following diagram shows a view of the Ethernet Firmware components and the expected ownership.</p>
<div class="image">
<img src="building_block_owners.png" alt="building_block_owners.png"/>
<div class="caption">
Component ownership in EthFw</div></div>
<p> <a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_remote_clients"></a>
Remote Core Clients</h1>
<hr/>
 <h2><a class="anchor" id="ethfw_client_rtos"></a>
RTOS Client</h2>
<p>Ethernet Firmware component in SDK provides a FreeRTOS client example application running on Main R5F 0 core 1. This application showcases lwIP TCP/IP stack and multicore time synchronization built on top of Ethernet Firmware's IPC-based remote config infrastructure.</p>
<div class="image">
<img src="rtos_client.png" alt="rtos_client.png"/>
<div class="caption">
EthFw with RTOS client</div></div>
<p> The following lwIP netifs are enabled in the RTOS client application:</p>
<ul>
<li>CPSW client drivers:<ul>
<li>Virtual MAC port based netif - Dedicated MAC port from CPSW is excluded from regular packet switching and allocated exclusive for this R5F core.</li>
<li>Virtual switch port based netif - Virtual port which carries unicast RX traffic from hardware MAC ports and TX traffic to hardware MAC ports.</li>
</ul>
</li>
<li>Shared memory virtual driver:<ul>
<li>Intercore based netif - Used for broadcast/multicast packet exchange with R5F core running Ethernet Firmware. Refer to the <a class="el" href="ethfw_c_ug_top.html#ethfw_intercore_eth">Inter-core Virtual Ethernet</a> section for more details about intercore Ethernet.</li>
</ul>
</li>
</ul>
<p>The two CPSW virtual port netifs reuse the same Enet LLD based lwIP implementation.</p>
<p>The RTOS core attaches to the Ethernet Firmware server using the <em>Eth Remote Config Client</em> library which is built on top of <em>remote_device</em> framework.</p>
<p>The multicore time synchronization mechanism implemented in RTOS client consists of a linear correction in software of a local timer owned by the RTOS core which is periodically synchronized with the CPTS clock via HW push event 2.</p>
<h3><a class="anchor" id="ethfw_client_rtos_mcu30"></a>
Porting RTOS client to Main R5F 1 Core 0</h3>
<p>Ethernet Firmware provides RTOS client support only on Main R5F 0 core 1 (<em>mcu2_1</em>) in all supported SoCs. Consequently, it's recommended to use <em>mcu2_1</em> processing core if virtual network interface support is required on an RTOS core.</p>
<p>However, in SoCs with multiple R5F cores, like J721E, system design may require virtual network support on a different R5F core, instead of Main R5F 0 Core 1. This requires porting effort on top of Enet LLD and Ethernet Firmware provided in standard TI SDK. The scope of the required porting changes will be discussed next, in the context of Main R5F 1 core 0 (<em>mcu3_0</em>) in J721E.</p>
<ul>
<li>Enet LLD:<ul>
<li>Add <em>mcu3_0</em> core in driver's CORELIST. This will be enable core Enet LLD support on Main R5F 1 core 0.</li>
<li>Replace <em>mcu2_1</em> with <em>mcu3_0</em> in intercore and lwipific libraries. Mainly renaming MCU2_1 macros to MCU3_0, but more importantly, updating the IPC core id (IPC_MCU2_1 -&gt; IPC_MCU3_0).</li>
</ul>
</li>
<li>Ethernet Firmware (server application):<ul>
<li>Replace IPC core id of the RTOS client (IPC_MCU2_1 -&gt; IPC_MCU3_0) in EthFw library, CpswProxy server and client, as well as EthFw server application.</li>
<li>Update the IPC core id where virtual switch port and virtual MAC port interfaces are enabled on.</li>
<li>Update memory addresses used for MCU3_0 IPC (0xA3000000 -&gt; 0xA4000000).</li>
</ul>
</li>
<li>RTOS client application:<ul>
<li>Update IPC multiproc configuration to exclude <em>mcu3_0</em> and include <em>mcu2_1</em>.</li>
<li>Update memory addresses used for MCU3_0 IPC (0xA3000000 -&gt; 0xA4000000).</li>
<li>Rename Enet LLD intercore macros as per corresponding changes in Enet LLD for mcu3_0 support.</li>
</ul>
</li>
</ul>
<p>It's worth noting that above list summarizes the software changes needed for running RTOS client on <em>mcu3_0</em> instead of <em>mcu2_1</em>. It must not be confused with adding <em>mcu3_0</em> support in addition to <em>mcu2_1</em>, which is not in the scope of this discussion.</p>
<p>The following Enet LLD and Ethernet Firmware <a href="j721e_mcu3_0_rtos_client.zip">patches</a> are provided as reference to illustrate the actual software changes corresponding to the summary shown earlier. These changes are meant as reference for prototyping, and are provided as is.</p>
<hr/>
 <h2><a class="anchor" id="ethfw_client_linux"></a>
Linux Client</h2>
<p>TI Linux kernel provides support for the two types of CPSW client drivers, <em>virtual MAC port</em> and <em>virtual switch port</em>, through the j721e-cpsw-virt-mac driver. Both interfaces types are enabled by default in TI Processor SDK Linux.</p>
<p>The following diagram presents a simplified view of the main components involved in the Linux client usecase.</p>
<div class="image">
<img src="linux_client.png" alt="linux_client.png"/>
<div class="caption">
EthFw with Linux client</div></div>
<p> The <em>rpmsg_kdrv_switch</em> client driver is compatible with the <em>remote_device</em> server side running on RTOS master core (Ethernet Firmware). This driver is used to exchange control messages with Ethernet Firmware to establish a virtual port connection.</p>
<p>It's important to note that the Ethernet packet exchange doesn't happen via IPC. Instead, it happens completely in hardware via UDMA TX channel and RX flow.</p>
<p>For further information, please refer to <a href="http://software-dl.ti.com/jacinto7/esd/processor-sdk-linux-jacinto7/latest/exports/docs/linux/Foundational_Components/Kernel/Kernel_Drivers/Network/CPSWng_virt_mac.html">CPSWng_virt_mac</a> documentation in Processor SDK Linux.</p>
<hr/>
 <h2><a class="anchor" id="ethfw_client_qnx"></a>
QNX Client</h2>
<p>TI's baseport for QNX provides support for <em>virtual switch port</em> network interface through its <em>devnp_cpsw9g</em> driver. <em>Virtual MAC port</em> (MAC-only mode) is currently not supported by QNX client.</p>
<p>The following diagram shows a simplified view of the main components involved in the QNX client's virtual port implementation.</p>
<div class="image">
<img src="qnx_client.png" alt="qnx_client.png"/>
<div class="caption">
EthFw with QNX client</div></div>
<p> TI's <em>devnp_cpsw9g</em> driver implements the driver interface of the QNX networking stack (io-pkt), so the virtual MAC port network interface is exposed transparently to the user as any other native networking interface.</p>
<p><em>devnp_cpsw9g</em> driver uses Ethernet Firmware's remote configuration infrastructure in order to attach/detach the virtual port, register its MAC address, IP address, etc. This is the same remote configuration API used by other remote clients such as RTOS core, and consequently also sits on top of the <em>remote_device</em> framework. The lower level IPC functionality is provided by the <em>IPC RM</em> (QNX resmgr).</p>
<p>Ethernet packet exchange with the CPSW switch happens in hardware through an UDMA TX channel and RX flow, completely independent of the Ethernet Firmware. <em>devnp_cpsw9g</em> driver uses Enet LLD data path APIs natively to submit and retrieve Ethernet packets.</p>
<hr/>
 <h2><a class="anchor" id="ethfw_client_autosar"></a>
AUTOSAR Client</h2>
<p>Ethernet Firmware is also able to attach to a remote client running AUTOSAR. The AUTOSAR client must use TI's MCAL Eth VirtMAC driver. This is a MCAL Eth driver with TI customizations for virtual MAC functionality.</p>
<p>A simplified view of the main entities involved in the AUTOSAR remote client usecase are shown in the following diagram.</p>
<div class="image">
<img src="autosar_client.png" alt="autosar_client.png"/>
<div class="caption">
EthFw with AUTOSAR client</div></div>
<p> The remote core configuration is implemented on top of TI MCAL IPC CDD. The <em>remote_core</em> framework used for RTOS and Linux clients is not relevant in the AUTOSAR scenario.</p>
<p>Ethernet packet exchange with the CPSW switch doesn't happen via IPC, but in hardware via UDMA TX channel and RX flow.</p>
<p>In the current release, AUTOSAR client only supports <em>virtual switch port</em>. <em>Virtual MAC port</em> (MAC-only mode) is not supported.</p>
<p>Note that the AUTOSAR client in the SDK has enabled on Main R5F 0 core 1 with remote endpoint id as 28 and MCU R5F 0 core 0 with remote endpoint id as 38.</p>
<hr/>
 <h2><a class="anchor" id="ethfw_component_location"></a>
Component Location</h2>
<p>The location within the SDK directory structure of the software components which are relevant for Ethernet Firmware usecases is shown in the following figure. Note that this figure presents a consolidated view of the Ethernet Firmware and all the supported remote clients, but that doesn't mean that all clients can be supported simultaneously.</p>
<div class="image">
<img src="EthFw_component_location.png" alt="EthFw_component_location.png"/>
<div class="caption">
Location of the Ethernet Firmware related components in SDK</div></div>
<p> <a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_maconly"></a>
MAC-only</h1>
<p>CPSW switch supports a feature called MAC-only mode which allows all incoming traffic from a given MAC port to be transferred only to the host port. This effectively excludes the MAC ports configured in this mode for rest of packet switching happening in the CPSW switch.</p>
<p>Starting with SDK 8.1, Ethernet Firmware has enabled MAC-only mode on selected MAC ports. To better understand the physical and logical entities involved in a system where MAC-only mode has been enabled, let's start by defining key concepts:</p>
<ul>
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_mac_port">Hardware physical ports</a> - The CPSW switch MAC ports.</li>
<li><em>Logical switch ports</em> - Defined based on packet header match criteria, typically created based on destination MAC address, VLAN IDs, etc. Two possible types:<ul>
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_local_switch_port">Local switch port</a> - owned exclusively by Ethernet Firmware.</li>
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_virtual_switch_port">Virtual switch port</a> - owned by remote clients (Linux, QNX, MCAL, RTOS).</li>
</ul>
</li>
<li><em>Logical MAC-only ports</em> - Defined with 1-to-1 correspondence to physical ports (port configured in MAC-only mode), owned by remote clients.<ul>
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_virtual_mac_port">Virtual MAC port</a> - owned by remote clients (Linux, RTOS).</li>
</ul>
</li>
</ul>
<div class="image">
<img src="EthFw_PortCfg_generic.png" alt="EthFw_PortCfg_generic.png"/>
<div class="caption">
Ethernet Firmware logical ports and hardware ports</div></div>
<p> The default port configuration for J721E and J7200 are shown in <a class="el" href="ethfw_c_ug_top.html#ethfw_j721e_port_cfg">J721E Port Configuration</a> <a class="el" href="ethfw_c_ug_top.html#ethfw_j7200_port_cfg">J7200 Port Configuration</a> and <a class="el" href="ethfw_c_ug_top.html#ethfw_j784s4_port_cfg">J784S4 Port Configuration</a> subsections, respectively.</p>
<p>The port's default VLAN for MAC ports configured in MAC-only mode is <code>0</code>, and for MAC ports configured in switch mode is <code>1</code>. They can be changed via <code>EthFw_Config::dfltVlanIdMacOnlyPorts</code> and <code>EthFw_Config::dfltVlanIdSwitchPorts</code>, respectively.</p>
<h2><a class="anchor" id="ethfw_mac_port"></a>
Hardware physical ports</h2>
<p>These are the actual hardware MAC ports of the CPSW switch. They can be configured in MAC-only or switch (non MAC-only) mode.</p>
<p>The MAC ports which are to be enabled by the Ethernet Firmware as passed as a parameter of <code>EthFw_Config</code> structure. For example, below code snippet shows a configuration which enables all 8 MAC ports in J721E CPSW9G.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> Enet_MacPort gEthAppPorts[] =</div><div class="line">{</div><div class="line">    ENET_MAC_PORT_1, <span class="comment">/* RGMII */</span></div><div class="line">    ENET_MAC_PORT_3, <span class="comment">/* RGMII */</span></div><div class="line">    ENET_MAC_PORT_4, <span class="comment">/* RGMII */</span></div><div class="line">    ENET_MAC_PORT_8, <span class="comment">/* RGMII */</span></div><div class="line"><span class="preprocessor">#if defined(ENABLE_QSGMII_PORTS)</span></div><div class="line">    ENET_MAC_PORT_2, <span class="comment">/* QSGMII main */</span></div><div class="line">    ENET_MAC_PORT_5, <span class="comment">/* QSGMII sub */</span></div><div class="line">    ENET_MAC_PORT_6, <span class="comment">/* QSGMII sub */</span></div><div class="line">    ENET_MAC_PORT_7, <span class="comment">/* QSGMII sub */</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> int32_t EthApp_initEthFw(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    EthFw_Config ethFwCfg;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    ethFwCfg.ports    = &amp;gEthAppPorts[0];</div><div class="line">    ethFwCfg.numPorts = ARRAY_SIZE(gEthAppPorts);</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ethfw_local_switch_port"></a>
Local switch port</h2>
<p>This is a logical port owned by the Ethernet Firmware.</p>
<p>Ethernet packets are exchanged with the CPSW switch through its <em>host port</em> using a UDMA RX flow and a TX channel.</p>
<p>CPSW's default thread is set to this port's UDMA RX flow, also called <em>default RX flow</em>. Traffic which is not matched by any CPSW classifier gets routed to this port.</p>
<h2><a class="anchor" id="ethfw_virtual_switch_port"></a>
Virtual switch port</h2>
<p>This is the traditional logical port owned by remote client cores, controlled via Ethernet Firmware's IPC-based remote API.</p>
<p>Ethernet packets are also exchanged with the CPSW switch through its <em>host port</em> using a UDMA RX flow and a TX channel.</p>
<p>RX traffic (to remote core) is segregated via CPSW ALE classifier with <em>unicast MAC address</em> match criteria. TX traffic (from remote core) is sent as <em>non-directed</em> packets.</p>
<p>It's worth noting that virtual switch ports are not directly associated with any specific hardware MAC port, as these virtual ports can received traffic from any MAC port as long as the packets match the unicast MAC address classification criteria.</p>
<p>SDK 8.0 or older supported only this type of virtual port.</p>
<p>Virtual port (<em>virtual switch</em> or <em>virtual MAC</em>) are allocated to a specific core.</p>
<p>For example, below code snippet shows the virtual switch configuration:</p><ul>
<li>For remote_device based clients in <code>gEthApp_virtPortCfg</code> where <em>virtual switch port 0</em> is allocated for A72 core, and <em>virtual switch port 1</em> is allocated for Main R5F 0 Core 1.</li>
<li>For AUTOSAR clients in <code>gEthApp_autosarVirtPortCfg</code> where <em>virtual switch port 1</em> is allocated for Main R5F 0 Core 1 and <em>virtual switch port 2</em> is allocated for MCU R5F 0 Core 0.</li>
</ul>
<p>It's worth noting that in this specific configuration <em>virtual switch port 1</em> can be used by an RTOS client or AUTOSAR client, depending on the OS running on Main R5F 0 Core 1.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> EthFw_VirtPortCfg gEthApp_virtPortCfg[] =</div><div class="line">{</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MPU1_0,</div><div class="line">        .portId       = ETHREMOTECFG_SWITCH_PORT_0,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MCU2_1,</div><div class="line">        .portId       = ETHREMOTECFG_SWITCH_PORT_1,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MPU1_0,</div><div class="line">        .portId       = ETHREMOTECFG_MAC_PORT_1,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MCU2_1,</div><div class="line">        .portId       = ETHREMOTECFG_MAC_PORT_4,</div><div class="line">    },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> EthFw_VirtPortCfg gEthApp_autosarVirtPortCfg[] =</div><div class="line">{</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MCU2_1,</div><div class="line">        .portId       = ETHREMOTECFG_SWITCH_PORT_1,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MCU1_0,</div><div class="line">        .portId       = ETHREMOTECFG_SWITCH_PORT_2,</div><div class="line">    },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> int32_t EthApp_initEthFw(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    EthFw_Config ethFwCfg;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* Set virtual port configuration parameters */</span></div><div class="line">    ethFwCfg.virtPortCfg  = &amp;gEthApp_virtPortCfg[0];</div><div class="line">    ethFwCfg.numVirtPorts = ARRAY_SIZE(gEthApp_virtPortCfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Set AUTOSAR virtual port configuration parameters */</span></div><div class="line">    ethFwCfg.autosarVirtPortCfg  = &amp;gEthApp_autosarVirtPortCfg[0];</div><div class="line">    ethFwCfg.numAutosarVirtPorts = ARRAY_SIZE(gEthApp_autosarVirtPortCfg);</div><div class="line"></div><div class="line">   ...</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ethfw_virtual_mac_port"></a>
Virtual MAC port</h2>
<p>This is also a logical port owned by remote clients and controlled via Ethernet Firmware's IPC-based remote API.</p>
<p>Ethernet packets are also exchanged with the CPSW switch through its <em>host port</em> using a UDMA RX flow and a TX channel.</p>
<p>RX traffic (to remote core) is segregated via CPSW ALE classifier with <em>port</em> match criteria. TX traffic (from remote core) is sent as <em>directed</em> packets.</p>
<p>These virtual ports are directly associated with a hardware MAC port which is configured in MAC-only mode.</p>
<p>Below code snippet (which is same as shown in previous section for <a class="el" href="ethfw_c_ug_top.html#ethfw_virtual_switch_port">Virtual switch port</a>) shows a configuration where <em>virtual MAC port 1</em> is allocated for A72, and <em>virtual MAC port 4</em> is allocated for Main R5F 0 Core 1. It's worth noting that virtual MAC ports are only supported in Linux and RTOS client, hence no virtual MAC ports are allocated for AUTOSAR client.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> EthFw_VirtPortCfg gEthApp_virtPortCfg[] =</div><div class="line">{</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MPU1_0,</div><div class="line">        .portId       = ETHREMOTECFG_SWITCH_PORT_0,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MCU2_1,</div><div class="line">        .portId       = ETHREMOTECFG_SWITCH_PORT_1,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MPU1_0,</div><div class="line">        .portId       = ETHREMOTECFG_MAC_PORT_1,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MCU2_1,</div><div class="line">        .portId       = ETHREMOTECFG_MAC_PORT_4,</div><div class="line">    },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> EthFw_VirtPortCfg gEthApp_autosarVirtPortCfg[] =</div><div class="line">{</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MCU2_1,</div><div class="line">        .portId       = ETHREMOTECFG_SWITCH_PORT_1,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MCU1_0,</div><div class="line">        .portId       = ETHREMOTECFG_SWITCH_PORT_2,</div><div class="line">    },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> int32_t EthApp_initEthFw(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    EthFw_Config ethFwCfg;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* Set virtual port configuration parameters */</span></div><div class="line">    ethFwCfg.virtPortCfg  = &amp;gEthApp_virtPortCfg[0];</div><div class="line">    ethFwCfg.numVirtPorts = ARRAY_SIZE(gEthApp_virtPortCfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Set AUTOSAR virtual port configuration parameters */</span></div><div class="line">    ethFwCfg.autosarVirtPortCfg  = &amp;gEthApp_autosarVirtPortCfg[0];</div><div class="line">    ethFwCfg.numAutosarVirtPorts = ARRAY_SIZE(gEthApp_autosarVirtPortCfg);</div><div class="line"></div><div class="line">   ...</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ethfw_additional_maconly"></a>
Configuring additional ports in MAC-only mode</h2>
<p>The default port configuration of Ethernet Firmware can be changed to fit the specific architecture requirements of each system.</p>
<p>If additional ports need to be configured in MAC-only mode, one needs to follow these steps:</p>
<ol type="1">
<li>Add the new <em>MAC port</em> to the port array passed via <code>EthFw_Config::port</code> config parameter.</li>
<li>Add a new <em>virtual MAC port</em> corresponding to the hardware <em>MAC port</em> of interest. The virtual port configuration is passed via <code>EthFw_Config::virtPortCfg</code> config parameter. The virtual port mode must be set to <code>ETHREMOTECFG_MAC_PORT_&lt;n&gt;</code> which is an enum of type <code>EthRemoteCfg_VirtPort</code>.</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">static</span> Enet_MacPort gEthAppPorts[] =</div><div class="line">{</div><div class="line">    ...</div><div class="line">    ENET_MAC_PORT_5, <span class="comment">/* new MAC port being added */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> EthFw_VirtPortCfg gEthApp_virtPortCfg[] =</div><div class="line">{</div><div class="line">    ...</div><div class="line">    {</div><div class="line">        .remoteCoreId = IPC_MCU2_1,              <span class="comment">/* new MAC port allocated for MCU2_1 RTOS usage */</span></div><div class="line">        .portId       = ETHREMOTECFG_MAC_PORT_5, <span class="comment">/* new MAC port in MAC-only mode */</span></div><div class="line">    },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> int32_t EthApp_initEthFw(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    EthFw_Config ethFwCfg;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    ethFwCfg.ports        = &amp;gEthAppPorts[0];</div><div class="line">    ethFwCfg.numPorts     = ARRAY_SIZE(gEthAppPorts);</div><div class="line">    ethFwCfg.virtPortCfg  = &amp;gEthApp_virtPortCfg[0];</div><div class="line">    ethFwCfg.numVirtPorts = ARRAY_SIZE(gEthApp_virtPortCfg);</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>On the other hand, if the new MAC port or an existing one needs to be changed from MAC-only mode to switch mode, one can simply remove it from the <code>EthFw_VirtPortCfg</code> array.</p>
<p>Resource availability and allocation must be taken into account when adding additional virtual ports, not only in MAC-only mode but also in switch mode. Each virtual port will require one UDMA TX channel and one UDMA RX flow, both are resources partitioned for each core in the SoC, hence repartitioning might be needed. Additionally, each virtual port will require a MAC address which is also a limited resource.</p>
<p>Ethernet Firmware relies on Enet LLD's utils library to populate its MAC address pool (see <code>EnetAppUtils_initResourceConfig()</code>). The MAC address pool is populated with addresses read from EEPROMs located in the different expansion boards in TI EVM. Note that a static MAC address pool is used as a workaround in TI EVMs for cases where I2C bus contention could happen (i.e. when integrating with Linux). It's expected that the MAC address pool population mechanism is adapted when integrating Ethernet Firmware to different platforms.</p>
<p>The utilization of these resources by Ethernet Firmware on Main R5F 0 Core 0 is as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Resource  </th><th class="markdownTableHeadCenter">Count  </th><th class="markdownTableHeadLeft">EthFw Usage (mcu2_0)   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">TX channel  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyLeft"><ul>
<li>
lwIP netif (1)</li>
<li>
gPTP (1)</li>
<li>
SW interVLAN (1)</li>
</ul>
</td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">RX flow  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyLeft"><ul>
<li>
lwIP netif (1)</li>
<li>
gPTP (1)</li>
<li>
Proxy ARP (1)</li>
<li>
SW interVLAN (1)</li>
<li>
Enet LLD default flow (1)</li>
</ul>
</td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MAC address  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyLeft"><ul>
<li>
lwIP netif (1)</li>
</ul>
</td></tr>
</table>
<p>UDMA TX channels are a resource especially limited as there is only a total of 8 TX channels available. So, there are 5 TX channels to be shared among the differrent remote client cores and their virtual ports.</p>
<p>With Ethernet Firmware's default port configuration, the following resources will be used by Linux remote client on A72 core.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Resource  </th><th class="markdownTableHeadCenter">Count  </th><th class="markdownTableHeadLeft">Linux Client Usage   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">TX channel  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyLeft"><ul>
<li>
Virtual switch port (1)</li>
<li>
Virtual MAC port (1)</li>
</ul>
</td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">RX flow  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyLeft"><ul>
<li>
Virtual switch port (1)</li>
<li>
Virtual MAC port (1)</li>
</ul>
</td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MAC address  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyLeft"><ul>
<li>
Virtual switch port (1)</li>
<li>
Virtual MAC port (1)</li>
</ul>
</td></tr>
</table>
<p>With Ethernet Firmware's default port configuration, the following resources will be used by RTOS remote client on Main R5F 0 Core 1.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Resource  </th><th class="markdownTableHeadCenter">Count  </th><th class="markdownTableHeadLeft">RTOS Client Usage   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">TX channel  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyLeft"><ul>
<li>
Virtual switch lwIP netif (1)</li>
<li>
Virtual MAC port lwIP netif (1)</li>
</ul>
</td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">RX flow  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyLeft"><ul>
<li>
Virtual switch lwIP netif (1)</li>
<li>
Virtual MAC port lwIP netif (1)</li>
</ul>
</td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MAC address  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyLeft"><ul>
<li>
Virtual switch lwIP netif (1)</li>
<li>
Virtual MAC port lwIP netif (1)</li>
</ul>
</td></tr>
</table>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<h1><a class="anchor" id="ethfw_port_cfg"></a>
Default Port Configuration</h1>
<h2><a class="anchor" id="ethfw_j721e_port_cfg"></a>
J721E Port Configuration</h2>
<p>There are four MAC ports enabled by default in Ethernet Firmware for J721E SoC. These are the RGMII MAC ports in GESI board.</p>
<p>Two MAC ports are configured in MAC-only mode and allocated for A72 (Linux) and Main R5F Core 1 (RTOS) usage. The remaining two MAC ports are configured in switch mode.</p>
<div class="image">
<img src="EthFw_PortCfg_j721e_evm.png" alt="EthFw_PortCfg_j721e_evm.png"/>
<div class="caption">
J721E default port configuration</div></div>
<p> The following table shows the full list of MAC ports in J721E EVM, the board they are located and their MAC mode.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">MAC Port  </th><th class="markdownTableHeadCenter">PHY Addr  </th><th class="markdownTableHeadCenter">Board  </th><th class="markdownTableHeadLeft">MAC mode   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MAC Port 1  </td><td class="markdownTableBodyCenter">12  </td><td class="markdownTableBodyCenter">GESI  </td><td class="markdownTableBodyLeft">MAC-only   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MAC Port 2  </td><td class="markdownTableBodyCenter">16  </td><td class="markdownTableBodyCenter">QSGMII  </td><td class="markdownTableBodyLeft">Switch Port   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MAC Port 3  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">GESI  </td><td class="markdownTableBodyLeft">Switch Port   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MAC Port 4  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">GESI  </td><td class="markdownTableBodyLeft">MAC-only   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MAC Port 5  </td><td class="markdownTableBodyCenter">17  </td><td class="markdownTableBodyCenter">QSGMII  </td><td class="markdownTableBodyLeft">Switch Port   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MAC Port 6  </td><td class="markdownTableBodyCenter">18  </td><td class="markdownTableBodyCenter">QSGMII  </td><td class="markdownTableBodyLeft">Switch Port   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MAC Port 7  </td><td class="markdownTableBodyCenter">19  </td><td class="markdownTableBodyCenter">QSGMII  </td><td class="markdownTableBodyLeft">Switch Port   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MAC Port 8  </td><td class="markdownTableBodyCenter">15  </td><td class="markdownTableBodyCenter">GESI  </td><td class="markdownTableBodyLeft">Switch Port   </td></tr>
</table>
<h2><a class="anchor" id="ethfw_j7200_port_cfg"></a>
J7200 Port Configuration</h2>
<p>All the four MAC ports of CPSW5G are enabled by default in Ethernet Firmware for J7200 SoC. These are the four QSGMII MAC ports in QSGMII (QpENet) expansion board.</p>
<p>Two MAC ports are configured in MAC-only mode and allocated for A72 (Linux) and Main R5F Core 1 (RTOS) usage. The remaining two MAC ports are configured in switch mode.</p>
<div class="image">
<img src="EthFw_PortCfg_j7200_evm.png" alt="EthFw_PortCfg_j7200_evm.png"/>
<div class="caption">
J7200 default port configuration</div></div>
<p> The following table shows the full list of MAC ports in J7200 EVM, the board they are located and their MAC mode.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">MAC Port  </th><th class="markdownTableHeadCenter">PHY Addr  </th><th class="markdownTableHeadCenter">Board  </th><th class="markdownTableHeadLeft">MAC mode   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MAC Port 1  </td><td class="markdownTableBodyCenter">16  </td><td class="markdownTableBodyCenter">QSGMII  </td><td class="markdownTableBodyLeft">MAC-only   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MAC Port 2  </td><td class="markdownTableBodyCenter">17  </td><td class="markdownTableBodyCenter">QSGMII  </td><td class="markdownTableBodyLeft">Switch Port   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MAC Port 3  </td><td class="markdownTableBodyCenter">18  </td><td class="markdownTableBodyCenter">QSGMII  </td><td class="markdownTableBodyLeft">Switch Port   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MAC Port 4  </td><td class="markdownTableBodyCenter">19  </td><td class="markdownTableBodyCenter">QSGMII  </td><td class="markdownTableBodyLeft">MAC-only   </td></tr>
</table>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<h2><a class="anchor" id="ethfw_j784s4_port_cfg"></a>
J784S4 Port Configuration</h2>
<p>J784S4 EVM provides two <em>Enet</em> expansion connectors (<code>ENET-EXP-1</code> and <code>ENET-EXP-2</code>) where two expansion boards can be connected. QSGMII (QpENet) board can be connected to either expansion connector, but two QSGMII boards cannot be connected simultaneously due to board limitation.</p>
<p>Only four MAC ports of CPSW9G are enabled by default in Ethernet Firmware for J784S4 SoC. These are the four QSGMII MAC ports in QSGMII (QpENet) expansion board when connected in slot 1 (<code>ENET-EXP-1</code>).</p>
<p>Two MAC ports are configured in MAC-only mode and allocated for A72 (Linux) and Main R5F Core 1 (RTOS) usage. The remaining two MAC ports are configured in switch mode.</p>
<div class="image">
<img src="EthFw_PortCfg_j784s4_evm.png" alt="EthFw_PortCfg_j784s4_evm.png"/>
<div class="caption">
J784S4 default port configuration</div></div>
<p> The following table shows the full list of MAC ports in J784S4 EVM, the board they are located and their MAC mode.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">MAC Port  </th><th class="markdownTableHeadCenter">PHY Addr  </th><th class="markdownTableHeadCenter">Board  </th><th class="markdownTableHeadLeft">MAC mode   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MAC Port 1  </td><td class="markdownTableBodyCenter">16  </td><td class="markdownTableBodyCenter">QSGMII  </td><td class="markdownTableBodyLeft">MAC-only   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MAC Port 3  </td><td class="markdownTableBodyCenter">17  </td><td class="markdownTableBodyCenter">QSGMII  </td><td class="markdownTableBodyLeft">Switch Port   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MAC Port 4  </td><td class="markdownTableBodyCenter">18  </td><td class="markdownTableBodyCenter">QSGMII  </td><td class="markdownTableBodyLeft">MAC-only   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MAC Port 5  </td><td class="markdownTableBodyCenter">19  </td><td class="markdownTableBodyCenter">QSGMII  </td><td class="markdownTableBodyLeft">Switch Port   </td></tr>
</table>
<p>MAC ports 2, 6, 7 and 8 are not enabled.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_intercore_eth"></a>
Inter-core Virtual Ethernet</h1>
<p>Starting with SDK 8.1, the EthFw integrates Inter-core Virtual Ethernet driver which allows shared memory based Ethernet frame exchange between cores. This is modelled as virtual Ethernet adapter at each end.</p>
<ol type="1">
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_intercore_topology">Topology and Design overview</a></li>
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_intercore_r5server">EthFw Server integration</a></li>
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_intercore_r5client">R5F RTOS Client integration</a></li>
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_intercore_a72client">A72 Linux Client integration</a></li>
</ol>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
<h2><a class="anchor" id="ethfw_intercore_topology"></a>
Topology and Design overview</h2>
<p>Inter-core virtual network uses a star topology with the R5F_0 master core (EthFw server) acting as the central hub. Each node (core) in the network communicates directly with the master while communication between other nodes (A72 and R5F_1) is routed through the master. In addition to the Enet LLD network interfaces used to communicate with the CPSW switch, each participating core creates an inter-core network interface, which allows it to communicate with another core using standard TCP/IP protocol suite. This is aimed at modeling Ethernet-like communication between software running on-chip processing cores (R5Fs, A72). Traffic external to the SoC is handled through CPSW hardware IP that can steer traffic based on traffic flows directly to the respective cores.</p>
<p>The topology diagram below shows the integration of inter-core virtual Ethernet in Ethernet Firmware.</p>
<div class="image">
<img src="Intercore_eth_topology_overview.png" alt="Intercore_eth_topology_overview.png"/>
<div class="caption">
Inter-core Virtual Ethernet Topology</div></div>
<p> The main entities shown in this diagram are listed below:</p>
<ol type="1">
<li><b>R5F_0 master</b>: EthFw server core which forms the central hub of the inter-core network. Both client cores have a direct inter-core link to the R5F_0 master, as shown with <span style="color:green"><b>green arrows</b></span>. Inter-core communication between client cores e.g. A72 Linux client trying to ping R5F_1 client, goes through the R5F_0 master.</li>
<li><b>R5F_1 client</b>: This is the EthFw RTOS remote client.</li>
<li><b>A72 Linux client</b>: This is the EthFw Linux remote client.</li>
<li><b>Shared memory transport</b>: The software based packet transport used by inter-core network driver to exchange Ethernet packets. There is a dedicated set of shared queues and shared buffer pools for each pair of directly connected nodes. Please refer to the Enet LLD user guide for more details on the inter-core virtual Ethernet driver.</li>
<li><b>Multicast replication manager</b>: This software component on R5F_0 master (EthFw server) manages the fanout of shared multicast packets to the interested cores. It does so by dynamically updating the lwIP bridge FDB database to add/remove cores to/from the given multicast MAC address in response to the <a href="../api_guide/html_/group__CPSW__PROXY__API.html#ga89c45e9fcf6a7927ed1ee4079e4ee9c7"><b>multicast filter API</b></a> commands from the remote cores.</li>
<li><b>Data paths/flows</b>: Different data paths are used to route packets according to the type of traffic (Unicast, Broadcast and Multicast). The <b>black</b> arrows show core specific dedicated hardware flows which are used for unicast traffic originating from or bound to a given core as well as incoming <a class="el" href="ethfw_c_ug_top.html#ethfw_exclusive_mcast">exclusive multicast</a> traffic for a given core. Please refer to <a class="el" href="ethfw_c_ug_top.html#ethfw_mcast_support">Multicast and Broadcast Support</a> for details on <a class="el" href="ethfw_c_ug_top.html#ethfw_shared_mcast">shared multicast</a> and <a class="el" href="ethfw_c_ug_top.html#ethfw_exclusive_mcast">exclusive_multicast</a> traffic.</li>
</ol>
<p>Broadcast and shared multicast packets are always sent to the R5F_0 master core using the default flow shown by the <span style="color:red"><b>red arrow</b></span>. The master core creates copies of such packets in software which is shown by the <span style="color:blue"> <b>blue arrows</b></span> and sends them out to other cores using the inter-core Ethernet links shown by <span style="color:green"><b>green arrows</b></span>.</p>
<p>On RTOS cores, the inter-core virtual Ethernet driver provides a standard lwIP netif (network interface) to the application using which the application can exchange Ethernet packets with another core. The inter-core netifs are seamlessly integrated in EthFw (client and server) using lwIP bridgeif interface which allows the inter-core netifs to co-exist along-side the Enet LLD native or virtual client interface on the server and client respectively. The bridgeif provides a single unified network interface using which the application communicates with the CPSW switch or other cores without worrying about which netif to use for sending and receiving packets.</p>
<div class="image">
<img src="Intercore_virt_eth_rtos.png" alt="Intercore_virt_eth_rtos.png"/>
<div class="caption">
Inter-core virtual Ethernet architecture: RTOS &lt;-&gt; RTOS</div></div>
<p> Inter-core virtual Ethernet can also be used on Linux through a user space demo application provided in the SDK. This demo application creates a Linux TAP networking device and passes Ethernet packets back and forth between the TAP device and the inter-core transport shared queues to communicate with the inter-core netif on EthFw server. The TAP network interface can be bridged with the Enet LLD client driver interface to provide a single unified network interface to the network stack, just like the R5F cores. The bridge will automatically select the correct interface to send the packets based on the destination IP address.</p>
<div class="image">
<img src="Intercore_virt_eth_linux.png" alt="Intercore_virt_eth_linux.png"/>
<div class="caption">
Inter-core virtual Ethernet architecture: RTOS &lt;-&gt; Linux</div></div>
<p> <a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
<h2><a class="anchor" id="ethfw_intercore_r5server"></a>
EthFw Server integration</h2>
<p>The EthFw server acts as the central hub of the inter-core virtual network, therefore it instantiates two inter-core netifs, one to communicate with the EthFw R5F remote client and another for the A72 (Linux) remote client. The inter-core netifs, along-with the Enet LLD netif are all added to the lwIP bridgeif which provides a single unified interface to the network stack/application. Refer to <a class="el" href="ethfw_c_ug_top.html#ethfw_intercore_topology">Topology and Design overview</a> diagram which shows the various netifs, including the lwIP bridge, created on the R5F_0 server core.</p>
<p><b>Note</b>: The network stack / application sees only a single set of IP and MAC addresses which belong to the bridgeif. The individual netifs, including the Enet LLD netif, are neither visible to the network stack / application, nor do they get IP or MAC addresses.</p>
<p>Please refer to the following code in <code>&lt;ethfw&gt;/apps/app_remoteswitchcfg_server/mcu_2_0/main.c</code> to understand how these netifs are instantiated and added to the bridge:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if defined(ETHAPP_ENABLE_INTERCORE_ETH)</span></div><div class="line">    <span class="comment">/* Create Enet LLD ethernet interface */</span></div><div class="line">    netif_add(&amp;netif, NULL, NULL, NULL, NULL, LWIPIF_LWIP_init, tcpip_input);</div><div class="line"></div><div class="line">    <span class="comment">/* Create inter-core virtual ethernet interface: MCU2_0 &lt;-&gt; MCU2_1 */</span></div><div class="line">    netif_add(&amp;netif_ic[ETHAPP_NETIF_IC_MCU2_0_MCU2_1_IDX], NULL, NULL, NULL,</div><div class="line">              (<span class="keywordtype">void</span>*)&amp;netif_ic_state[IC_ETH_IF_MCU2_0_MCU2_1],</div><div class="line">              LWIPIF_LWIP_IC_init, tcpip_input);</div><div class="line"></div><div class="line">    <span class="comment">/* Create inter-core virtual ethernet interface: MCU2_0 &lt;-&gt; A72 */</span></div><div class="line">    netif_add(&amp;netif_ic[ETHAPP_NETIF_IC_MCU2_0_A72_IDX], NULL, NULL, NULL,</div><div class="line">              (<span class="keywordtype">void</span>*)&amp;netif_ic_state[IC_ETH_IF_MCU2_0_A72],</div><div class="line">              LWIPIF_LWIP_IC_init, tcpip_input);</div><div class="line"></div><div class="line">    <span class="comment">/* Create bridge interface */</span></div><div class="line">    bridge_initdata.max_ports = ETHAPP_LWIP_BRIDGE_MAX_PORTS;</div><div class="line">    bridge_initdata.max_fdb_dynamic_entries = ETHAPP_LWIP_BRIDGE_MAX_DYNAMIC_ENTRIES;</div><div class="line">    bridge_initdata.max_fdb_static_entries = ETHAPP_LWIP_BRIDGE_MAX_STATIC_ENTRIES;</div><div class="line">    EnetUtils_copyMacAddr(&amp;bridge_initdata.ethaddr.addr[0U], &amp;gEthAppObj.hostMacAddr[0U]);</div><div class="line"></div><div class="line">    netif_add(&amp;netif_bridge, &amp;ipaddr, &amp;netmask, &amp;gw, &amp;bridge_initdata, bridgeif_init, netif_input);</div><div class="line"></div><div class="line">    <span class="comment">/* Add all netifs to the bridge and create coreId to bridge portId map */</span></div><div class="line">    bridgeif_add_port(&amp;netif_bridge, &amp;netif);</div><div class="line">    gEthApp_lwipBridgePortIdMap[IPC_MCU2_0] = ETHAPP_BRIDGEIF_CPU_PORT_ID;</div><div class="line"></div><div class="line">    bridgeif_add_port(&amp;netif_bridge, &amp;netif_ic[0]);</div><div class="line">    gEthApp_lwipBridgePortIdMap[IPC_MCU2_1] = ETHAPP_BRIDGEIF_PORT1_ID;</div><div class="line"></div><div class="line">    bridgeif_add_port(&amp;netif_bridge, &amp;netif_ic[1]);</div><div class="line">    gEthApp_lwipBridgePortIdMap[IPC_MPU1_0] = ETHAPP_BRIDGEIF_PORT2_ID;</div><div class="line"></div><div class="line">    <span class="comment">/* Set bridge interface as the default */</span></div><div class="line">    netif_set_default(&amp;netif_bridge);</div><div class="line"><span class="preprocessor">#else</span></div></div><!-- fragment --><p> <a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
<h2><a class="anchor" id="ethfw_intercore_r5client"></a>
R5F RTOS Client integration</h2>
<p>The EthFw client on R5F_1 instantiates only one inter-core netif to communicate directly with the EthFw server on R5F_0. Similar to the EthFW server, an lwIP bridgeif is created and both the inter-core netif and the Enet LLD virtual netif are added to the bridge to provide a unified network interface to the application.</p>
<p>Refer to <a class="el" href="ethfw_c_ug_top.html#ethfw_intercore_topology">Topology and Design overview</a> diagram which shows the various netifs, including the lwIP bridge, created on the R5F_1 client core.</p>
<p><b>Note</b>: The network stack / application sees only a single set of IP and MAC addresses which belong to the bridgeif. The individual netifs, including the Enet LLD netif, are neither visible to the network stack / application, nor do they get IP or MAC addresses.</p>
<p>Please refer to the following code in <code>&lt;ethfw&gt;/apps/app_remoteswitchcfg_client/mcu_2_1/main.c</code> to understand how these netifs are instantiated and added to the bridge:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if defined(ETHAPP_ENABLE_INTERCORE_ETH)</span></div><div class="line">    <span class="comment">/* Create Enet LLD ethernet interface */</span></div><div class="line">    netif_add(netif, NULL, NULL, NULL, NULL, LWIPIF_LWIP_init, tcpip_input);</div><div class="line"></div><div class="line">    <span class="comment">/* Create inter-core virtual ethernet interface: MCU2_1 &lt;-&gt; MCU2_0 */</span></div><div class="line">    netif_add(&amp;netif_ic, NULL, NULL, NULL,</div><div class="line">              (<span class="keywordtype">void</span>*)&amp;netif_ic_state[IC_ETH_IF_MCU2_1_MCU2_0],</div><div class="line">              LWIPIF_LWIP_IC_init, tcpip_input);</div><div class="line"></div><div class="line">    <span class="comment">/* Create bridge interface */</span></div><div class="line">    bridge_initdata.max_ports = ETHAPP_LWIP_BRIDGE_MAX_PORTS;</div><div class="line">    bridge_initdata.max_fdb_dynamic_entries = ETHAPP_LWIP_BRIDGE_MAX_DYNAMIC_ENTRIES;</div><div class="line">    bridge_initdata.max_fdb_static_entries = ETHAPP_LWIP_BRIDGE_MAX_STATIC_ENTRIES;</div><div class="line">    EnetUtils_copyMacAddr(&amp;bridge_initdata.ethaddr.addr[0U], &amp;virtNetif-&gt;macAddr[0U]);</div><div class="line"></div><div class="line">    netif_add(&amp;netif_bridge, &amp;ipaddr, &amp;netmask, &amp;gw, &amp;bridge_initdata, bridgeif_init, netif_input);</div><div class="line"></div><div class="line">    <span class="comment">/* Add all network interfaces to the bridge */</span></div><div class="line">    bridgeif_add_port_with_opts(&amp;netif_bridge, netif, BRIDGEIF_PORT_CPSW);</div><div class="line">    bridgeif_add_port_with_opts(&amp;netif_bridge, &amp;netif_ic, BRIDGEIF_PORT_VIRTUAL);</div><div class="line"></div><div class="line">    <span class="comment">/* Set bridge interface as the default */</span></div><div class="line">    netif_set_default(&amp;netif_bridge);</div><div class="line">    netif_set_status_callback(&amp;netif_bridge, EthApp_lwipNetifStatusCb);</div><div class="line"><span class="preprocessor">#else</span></div></div><!-- fragment --><p> <a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
<h2><a class="anchor" id="ethfw_intercore_a72client"></a>
A72 Linux Client integration</h2>
<p>Inter-core virtual Ethernet can also be used on the A72 Linux remote client, however lwIP is not used on Linux so we cannot use the inter-core virtual driver directly. Instead, the adaptation layer between the Linux network stack and the inter-core transport is implemented in a user space demo application called <b>TAP</b>, which is provided under <code>&lt;ethfw&gt;/apps/tap/</code>. This user space application creates a Linux TAP networking device and passes Ethernet packets back and forth between the TAP device and the inter-core transport shared queues to communicate with the inter-core netif on EthFw server. Further, the TAP network interface can be bridged with the Enet LLD client interface to provide a single unified interface to the network stack, just like the R5F cores.</p>
<p><b>Note</b>: The TAP driver implementation is provided as a reference only to demonstrate and test the intercore functionality in Linux. It comes with limited feature support, such as polling mode operation only, basic packet handling.</p>
<p>Please refer to the following code in <code>&lt;ethfw&gt;/apps/tap/tapif.c</code>:</p>
<div class="fragment"><div class="line"><span class="comment">/* Open TAP device and get TAP device descriptor */</span></div><div class="line">tap_fd = tap_open(tap_device_name);</div><div class="line"><span class="keywordflow">if</span> (tap_fd &lt; 0) {</div><div class="line">    perror(<span class="stringliteral">&quot;Allocating interface&quot;</span>);</div><div class="line">    assert(tap_fd &gt;= 0);</div><div class="line">}</div><div class="line">printf(<span class="stringliteral">&quot;Opened TAP Device successfully\n&quot;</span>);</div><div class="line">fflush(stdout);</div><div class="line"></div><div class="line"><span class="comment">/* Try to open the memory and fetch its file descriptor */</span></div><div class="line">mem_fd = open(<span class="stringliteral">&quot;/dev/mem&quot;</span>, O_RDWR | O_SYNC);</div><div class="line"><span class="keywordflow">if</span> (mem_fd == -1) {</div><div class="line">    printf(<span class="stringliteral">&quot;Failed to open /dev/mem\n&quot;</span>);</div><div class="line">    fflush(stdout);</div><div class="line">    assert(0 &amp;&amp; <span class="stringliteral">&quot;Failed to access shared memory&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*Create a mapping between the physical addresses and virtual addresses */</span></div><div class="line"><span class="comment">/* for the Queue Region using mmap*/</span></div><div class="line">IcQ_globalQTable_Handle =</div><div class="line">            (IcQ_Handle)mmap(NULL, q_len, PROT_READ | PROT_WRITE,</div><div class="line">            MAP_SHARED, mem_fd, q_base_addr);</div><div class="line"><span class="comment">/* Check for failure in mapping */</span></div><div class="line">assert(IcQ_globalQTable_Handle != MAP_FAILED &amp;&amp; <span class="stringliteral">&quot;Queue Mapping Failed&quot;</span>);</div><div class="line">printf(<span class="stringliteral">&quot;Queue Mapping Succeeded\n&quot;</span>);</div><div class="line">fflush(stdout);</div><div class="line"></div><div class="line"><span class="comment">/*Create a mapping between the physical addresses and virtual addresses */</span></div><div class="line"><span class="comment">/* for the Buffer Region using mmap*/</span></div><div class="line">BufpoolTable_Handle = (Bufpool_Handle)mmap(NULL, bufpool_len,</div><div class="line">                            PROT_READ | PROT_WRITE, MAP_SHARED,</div><div class="line">                            mem_fd, bufpool_base_addr);</div><div class="line"><span class="comment">/* Check for failure in mapping */</span></div><div class="line">assert(BufpoolTable_Handle != MAP_FAILED &amp;&amp; <span class="stringliteral">&quot;Bufpool Mapping Failed&quot;</span>);</div><div class="line">printf(<span class="stringliteral">&quot;Bufpool Mapping Succeeded\n&quot;</span>);</div><div class="line">fflush(stdout);</div><div class="line"></div><div class="line"><span class="comment">/* Define txQ_Handle and rxQ_Handle */</span></div><div class="line">txQ_Handle =</div><div class="line">    (IcQ_Handle)&amp;(IcQ_globalQTable_Handle[tx_q_id]);</div><div class="line">rxQ_Handle =</div><div class="line">    (IcQ_Handle)&amp;(IcQ_globalQTable_Handle[rx_q_id]);</div><div class="line"></div><div class="line">printf(<span class="stringliteral">&quot;Assigned Queue Handles\n&quot;</span>);</div></div><!-- fragment --><p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
<h1><a class="anchor" id="ethfw_mcast_support"></a>
Multicast and Broadcast Support</h1>
<p>Starting with SDK 8.1, the Ethernet firmware supports client cores to receive multicast and broadcast traffic.</p>
<p>Broadcast support is automatically enabled through inter-core virtual Ethernet mechanism which allows sending broadcast traffic to all the client cores, provided that inter-core virtual Ethernet is enabled on that client.</p>
<p>For multicast support, a new <a href="../api_guide/html_/group__CPSW__PROXY__API.html#ga89c45e9fcf6a7927ed1ee4079e4ee9c7"><b>multicast filter API</b></a> is provided by EthFw which allows client cores to subscribe-to/unsubscribe-from multicast addresses. The Ethernet Firmware differentiates between two types of multicast addresses:</p>
<ol type="1">
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_shared_mcast">Shared Multicast</a></li>
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_exclusive_mcast">Exclusive Multicast</a></li>
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_reserved_mcast">Reserved Multicast</a></li>
</ol>
<p>Note that the cores requesting a multicast address do not need to know if a particular multicast address is shared or exclusive. This accounting is handled by the EthFw server and is completely transparent to the requesting client core.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
<h2><a class="anchor" id="ethfw_shared_mcast"></a>
Shared Multicast</h2>
<p>Shared multicast allows multiple client cores to subscribe to the same multicast address. To support this, EthFw maintains a list of pre-defined multicast addresses which are treated as <b>shared</b>.</p>
<ol type="1">
<li>More than one core can request these multicast addresses through the <a href="../api_guide/html_/group__CPSW__PROXY__API.html#ga89c45e9fcf6a7927ed1ee4079e4ee9c7"><b>multicast filter API</b></a>.</li>
<li>Traffic for these multicast addresses is always routed to the EthFw server from where it is fanned out to all the client cores that requested that particular multicast address.</li>
<li>Shared multicast fanout is performed in software using inter-core virtual Ethernet mechanism, therefore it is suited for low to medium bandwidth multicast traffic only.</li>
<li>The <b>shared multicast address list</b> is defined in source as shown below so the user will need to modify and rebuild the EthFw binaries if they need to change these addresses:</li>
</ol>
<p>Please refer to the following code in <code>&lt;ethfw&gt;/apps/app_remoteswitchcfg_server/mcu_2_0/main.c</code>:</p>
<div class="fragment"><div class="line"><span class="comment">/* Must not exceed ETHAPP_MAX_SHARED_MCAST_ADDR entries */</span></div><div class="line"><span class="keyword">static</span> EthApp_SharedMcastAddrTable gEthApp_sharedMcastAddrTable[] =</div><div class="line">{</div><div class="line">    {</div><div class="line">        <span class="comment">/* MCast IP ADDR: 224.0.0.1 */</span></div><div class="line">        .macAddr = {0x01,0x00,0x5E,0x00,0x00,0x01},</div><div class="line">        .portMask= 0U,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        <span class="comment">/* MCast IP ADDR: 224.0.0.251 */</span></div><div class="line">        .macAddr = {0x01,0x00,0x5E,0x00,0x00,0xFB},</div><div class="line">        .portMask= 0U,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        <span class="comment">/* MCast IP ADDR: 224.0.0.252 */</span></div><div class="line">        .macAddr = {0x01,0x00,0x5E,0x00,0x00,0xFC},</div><div class="line">        .portMask= 0U,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .macAddr = {0x33,0x33,0x00,0x00,0x00,0x01},</div><div class="line">        .portMask= 0U,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .macAddr = {0x33,0x33,0xFF,0x1D,0x92,0xC2},</div><div class="line">        .portMask= 0U,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .macAddr = {0x01,0x80,0xC2,0x00,0x00,0x00},</div><div class="line">        .portMask= 0U,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .macAddr = {0x01,0x80,0xC2,0x00,0x00,0x03},</div><div class="line">        .portMask= 0U,</div><div class="line">    },</div><div class="line">};</div></div><!-- fragment --><p> <a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
<h2><a class="anchor" id="ethfw_exclusive_mcast"></a>
Exclusive Multicast</h2>
<p>Exclusive multicast addresses are allocated to only one core at any given time and the corresponding multicast traffic is routed to that core directly using a dedicated hardware flow.</p>
<ol type="1">
<li>Any multicast addresses that do not belong to the shared multicast address list are considered exclusive and ownership of such multicast addresses is granted to the first requesting core. Any other cores requesting the same exclusive multicast address after it has already been allocated, will get a failure.</li>
<li>Exclusive multicast traffic is routed directly to the allocated core through a dedicated hardware flow therefore it is suitable for high bandwidth single-core multicast traffic.</li>
</ol>
<hr/>
<h2><a class="anchor" id="ethfw_reserved_mcast"></a>
Reserved Multicast</h2>
<p>Reserved multicast addresses are exclusive multicast addresses that are allocated only to the core running Ethernet Firmware. Any other core requesting for a reserved multicast address will get a failure.</p>
<p>PTP-related multicast addresses are defined as reserved multicast addresses in Ethernet Firmware's default configuration. This is needed because Ethernet Firmware runs the PTP stack and is the sole destination of PTP packets.</p>
<div class="fragment"><div class="line"><span class="comment">/* Note: Must not exceed ETHFW_RSVD_MCAST_LIST_LEN */</span></div><div class="line"><span class="keyword">static</span> uint8_t gEthApp_rsvdMcastAddrTable[][ENET_MAC_ADDR_LEN] =</div><div class="line">{</div><div class="line">    <span class="comment">/* PTP - Peer delay messages */</span></div><div class="line">    {</div><div class="line">        0x01, 0x80, 0xc2, 0x00, 0x00, 0x0E,</div><div class="line">    },</div><div class="line">    <span class="comment">/* PTP - Non peer delay messages */</span></div><div class="line">    {</div><div class="line">        0x01, 0x1b, 0x19, 0x00, 0x00, 0x00,</div><div class="line">    },</div><div class="line">};</div></div><!-- fragment --><p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_c_ug_ethfw_demos"></a>
EthFw Demos</h1>
<p>The EthFw demos showcase the integration and usage of the Ethernet Firmware which provides a high-level interface for applications to configure and use the integrated Ethernet switch peripheral (CPSW5G/CPSW9G).</p>
<p>The following sample applications are key to demonstrate the capabilities of the CPSW9G/CPSW5G hardware as well as the EthFw stack.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Demo  </th><th class="markdownTableHeadNone">Comments -&mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">L2 Switching  </td><td class="markdownTableBodyNone">Configures CPSW5G/CPSW9G switch to enable switching between its external ports   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">L2/L3 address based classification  </td><td class="markdownTableBodyNone">Illustrates traffic steering to A72 (Linux) and R5F (RTOS) based on Layer-2 Ethernet header. iperf tool and web servers are used to demonstrate traffic steering to/from PCs connected to the switch   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Inter-VLAN Routing (SW)  </td><td class="markdownTableBodyNone">Showcases inter-VLAN routing using lookup and forward operations being done in SW (R5F). It also showcases low-level lookup and forwarding on top of Enet LLD   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Inter-VLAN Routing (HW)  </td><td class="markdownTableBodyNone">Illustrates hardware offload support for inter-VLAN routing, demonstrating the CPSW5G/CPSW9G hardware capabilities to achieve line rate routing without additional impact on R5F CPU load   </td></tr>
</table>
<h2><a class="anchor" id="ethfw_switching_demo"></a>
EthFw Switching &amp; TCP/IP Apps Demo</h2>
<p>This demo showcases switching capabilities of the integrated Ethernet Switch (CPSW9G or CPSW5G) found in J721E, J7200 and J784S4 devices for features like VLAN, Multicast, etc. It also demonstrates lwIP (TCP/IP stack) integration into the EthFw.</p>
<h2><a class="anchor" id="ethfw_intervlan_demo"></a>
Inter-VLAN Routing Demo</h2>
<p>This demo illustrates hardware and software based inter-VLAN routing. The hardware inter-VLAN routing makes use of the CPSW9G/CPSW5G hardware features which enable line-rate inter-VLAN routing without any additional CPU load on the EthFw core. The software inter-VLAN routing is implemented as a fall-back alternative.</p>
<p>The hardware inter-VLAN route demo exercises the CPSW ALE classifier feature, which is used per flow to characterize the route and configure the egress operation.</p>
<p>Available egress operations:</p><ul>
<li>Replace Destination (MAC) Address</li>
<li>Replace Source (MAC) Address</li>
<li>Replace VLAN ID</li>
<li>Optional decrement of Time To Live (TTL)</li>
<li>Supports IPv4 (TTL) and IPv6 (Hop Limit) fields</li>
<li>Packets with 0 or 1 TTL/Hop Limit are sent to the host for error processing</li>
</ul>
<p>For further information, please refer to the <a class="el" href="demo_ethfw_combined_top.html">Ethernet Firmware differentiating features demos</a> demo application documentation.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_instal_top"></a>
Dependencies</h1>
<p>Dependencies can be categorized as follows:</p>
<ol type="1">
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_depend_hw">Hardware Dependencies</a></li>
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_depend_sw">Software Dependencies</a></li>
</ol>
<p>Please note that the dependencies vary depending on the intended use (e.g. for integration vs running demo applications only).</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="ethfw_depend_hw"></a>
Hardware Dependencies</h2>
<p>EthFw is supported on the following EVMs and expansion boards listed below:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">SoC  </th><th class="markdownTableHeadNone">EVM  </th><th class="markdownTableHeadNone">Expansion boards -----&mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="2">J721E  </td><td class="markdownTableBodyNone" rowspan="2"><a class="el" href="ethfw_c_ug_top.html#ethfw_depend_evm_j721e">J721E/J7200 EVM</a>  </td><td class="markdownTableBodyNone"><a class="el" href="ethfw_c_ug_top.html#ethfw_depend_evm_gesi_j721e">J721E GESI Expansion Board</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="ethfw_c_ug_top.html#ethfw_depend_evm_quadport_j721e">J721E Quad-Port Eth Expansion Board</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">J7200  </td><td class="markdownTableBodyNone"><a class="el" href="ethfw_c_ug_top.html#ethfw_depend_evm_j721e">J721E/J7200 EVM</a>  </td><td class="markdownTableBodyNone"><a class="el" href="ethfw_c_ug_top.html#ethfw_depend_evm_quadport_j7200">J7200 Quad-Port Eth Expansion Board</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">J784S4  </td><td class="markdownTableBodyNone"><a class="el" href="ethfw_c_ug_top.html#ethfw_depend_evm_j784s4">J784S4 EVM</a>  </td><td class="markdownTableBodyNone"><a class="el" href="ethfw_c_ug_top.html#ethfw_depend_evm_quadport_j784s4">J784S4 Quad-Port Eth Expansion Board</a>   </td></tr>
</table>
<p><b>Note:</b> Quad-Port Eth expansion board is supported in all EVMs, but with different MAC port number assignments, hence they are listed in separate sections.</p>
<h3><a class="anchor" id="ethfw_depend_evm_j721e"></a>
J721E/J7200 EVM</h3>
<div class="image">
<img src="J7EVM_CPSW_TopView.png" alt="J7EVM_CPSW_TopView.png"/>
<div class="caption">
J721E/J7200 EVM connections</div></div>
<h3><a class="anchor" id="ethfw_depend_evm_gesi_j721e"></a>
J721E GESI Expansion Board</h3>
<div class="image">
<img src="GESI_Board.png" alt="GESI_Board.png"/>
<div class="caption">
J721E EVM GESI Board Top View</div></div>
<p> There are four RGMII PHYs in the J721E GESI board as shown in the following image. They will be referred to as <b>MAC Port 1</b>, <b>MAC Port 3</b>, <b>MAC Port 4</b> and <b>MAC Port 8</b> throughout this document.</p>
<div class="image">
<img src="GESI_RJ45_SideView.png" alt="GESI_RJ45_SideView.png"/>
<div class="caption">
GESI Board connections</div></div>
<p> Please refer to the SDK Description for details about installation and getting started of J721E EVM.</p>
<p><b>Note:</b> GESI expansion board is also available in J7200 EVM, but only one MAC port is routed to the CPSW5G in J7200, hence GESI board is not enabled and used by default in the Ethernet Firmware for J7200.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<h3><a class="anchor" id="ethfw_depend_evm_quadport_j721e"></a>
J721E Quad-Port Eth Expansion Board</h3>
<p>The Quad-Port Eth expansion board in J721E EVM provides four MAC ports in addition to the four MAC ports in GESI board.</p>
<p>It enables four MAC ports: <b>MAC Port 2</b>, <b>MAC Port 5</b>, <b>MAC Port 6</b> and <b>MAC Port 7</b>.</p>
<div class="image">
<img src="J721E_QPENet_Board.png" alt="J721E_QPENet_Board.png"/>
<div class="caption">
Quad Port Eth Board connections in J7200 EVM</div></div>
<p> Please refer to the SDK for more details about installation and getting started on J721E EVM.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<h3><a class="anchor" id="ethfw_depend_evm_quadport_j7200"></a>
J7200 Quad-Port Eth Expansion Board</h3>
<p>The Quad-Port Eth expansion board provides the connectivity to the four MAC ports in J7200's CPSW5G: <b>MAC Port 1</b>, <b>MAC Port 2</b>, <b>MAC Port 3</b> and <b>MAC Port 4</b>.</p>
<div class="image">
<img src="J7200_QPENet_Board.png" alt="J7200_QPENet_Board.png"/>
<div class="caption">
Quad Port Eth Board connections in J7200 EVM</div></div>
<p> Please refer to the SDK for more details about installation and getting started on J7200 EVM.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<h3><a class="anchor" id="ethfw_depend_evm_j784s4"></a>
J784S4 EVM</h3>
<div class="image">
<img src="J784S4EVM_CPSW_TopView.png" alt="J784S4EVM_CPSW_TopView.png"/>
<div class="caption">
J784S4 EVM connections</div></div>
<h3><a class="anchor" id="ethfw_depend_evm_quadport_j784s4"></a>
J784S4 Quad-Port Eth Expansion Board</h3>
<p>Currently, Ethernet Firmware supports only one Quad-Port Eth expansion board connected in expansion connectors labeled as <code>ENET-EXP-1</code>.</p>
<p>It enables four MAC ports: <b>MAC Port 1</b>, <b>MAC Port 3</b>, <b>MAC Port 4</b> and <b>MAC Port 5</b>.</p>
<div class="image">
<img src="J784S4_QPENet_Board.png" alt="J784S4_QPENet_Board.png"/>
<div class="caption">
Quad Port Eth Board connections in J784S4 EVM</div></div>
<p> Please refer to the SDK for more details about installation and getting started on J784S4 EVM.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="ethfw_depend_sw"></a>
Software Dependencies</h2>
<p>Below listed dependencies are part of Processor SDK package.</p>
<h3><a class="anchor" id="ethfw_depend_pdk"></a>
PDK</h3>
<p>Platform Development Kit (PDK) is a component within the Processor SDK RTOS which provides Chip Support Library (CSL), Low-Level Drivers (LLD), Boot, Diagnostics, etc.</p>
<p>The following sections list the PDK subcomponents that are required by the EthFw package.</p>
<p>Please refer to the Release Notes that came with this release for the compatible version of PDK/SDK.</p>
<h4><a class="anchor" id="ethfw_depend_pdk_csl"></a>
CSL</h4>
<p>Chip Support Library (CSL) implements peripheral register level and functional level APIs. CSL also provides peripheral base addresses, register offset, C macros to program peripheral registers.</p>
<p>EthFw uses CSL to determine peripheral addresses and program peripheral registers.</p>
<h4><a class="anchor" id="ethfw_depend_pdk_udma"></a>
UDMA</h4>
<p>Unified DMA (UDMA) is an integral part of the Jacinto 7 devices and is in charge of moving data between peripherals and memory.</p>
<p>PDK includes an UDMA LLD which provides APIs that the Enet LLD relies on to send and receive packets to the CPSW's host port.</p>
<h4><a class="anchor" id="ethfw_depend_pdk_enet"></a>
Enet LLD</h4>
<p>This is Ethernet driver module used to program the CPSW5G or CPSW9G (Switch) IP. EthFw receives commands/configuration from application and uses Enet LLD to configure CPSW5G/CPSW9G.</p>
<p>Enet LLD supports other Ethernet peripherals available in TI SoCs and provides a unified interface to program them.</p>
<h3><a class="anchor" id="ethfw_depend_lwip"></a>
lwIP</h3>
<p>lwIP is a free TCP/IP stack developed by Adam Dunkels at the Swedish Institute of Computer Science (SICS) and licensed under a modified BSD license (completely open-source).</p>
<p>The focus of the LwIP TCP/IP implementation is to reduce RAM usage while keeping a full scale TCP/IP stack thus making it suitable for our requirements.</p>
<p>LwIP supports the following features:</p>
<ul>
<li>IPv4 and IPv6 (Internet Protocol v4 and v6)</li>
<li>ICMP (Internet Control Message Protocol) for network maintenance and debugging</li>
<li>IGMP (Internet Group Management Protocol) for multicast traffic management</li>
<li>UDP (User Datagram Protocol)</li>
<li>TCP (Transmission Control Protocol)</li>
<li>DNS (Domain Name Server)</li>
<li>SNMP (Simple Network Management Protocol)</li>
<li>DHCP (Dynamic Host Configuration Protocol)</li>
<li>PPP (Point to Point Protocol)</li>
<li>ARP (Address Resolution Protocol)</li>
</ul>
<p>Starting in SDK 8.0, Ethernet Firmware has been migrated to lwIP stack. The actual integration of lwIP into J721E/J7200/J784S4 devices is done through Enet LLD, which implements the lwIP netif driver interface.</p>
<p>The Enet LLD lwIP driver interface implementation can be located at: <code>&lt;pdk&gt;/packages/ti/drv/enet/lwipif/src</code>.</p>
<p>The lwIP configuration file (lwipopts.h) contains the lwIP stack features that are enabled by default in the Enet LLD driver implementation, such as TCP, UDP, DHCP, etc. It's located at <code>&lt;pdk&gt;/packages/ti/transport/lwip/lwip-port/freertos/include/lwipopts.h</code>. User should also refer to this file if interested on enabling any of the different lwIP debug options.</p>
<p>The lwIP pool configuration file (lwippools.h) contains the different pools and their sizes required by the Enet LLD lwIP interface implementation. This file is located at <code>&lt;pdk&gt;/packages/ti/drv/transport/lwip/lwip-port/freertos/include/lwippools.h</code>.</p>
<h3><a class="anchor" id="ethfw_depend_tsn"></a>
TSN stack</h3>
<dl class="section note"><dt>Note</dt><dd>SDK 9.0 provides support only for gPTP stack. No other TSN protocol is supported.</dd></dl>
<p>Starting in SDK 9.0, a new gPTP stack is integrated on top of Enet LLD in PDK, it can be located at: <code>&lt;pdk&gt;/packages/ti/transport/tsn/tsn-stack</code>. The previous gPTP test stack used in SDK 8.x and older releases is no longer supported and has been fully removed from both, Enet LLD and Ethernet Firmware.</p>
<p>The new gPTP stack provides time synchronization for CPSW5G/CPSW9G on Main R5F0 core 0 for J721E, J7200 and J784S4. The stack is composed of the following modules:</p>
<ul>
<li><b>tsn_unibase</b> : Universal utility libraries that are platform-independent.</li>
<li><b>tsn_combase</b> : Communication utility libraries that provide support for functions like sockets, mutexes, and semaphores.</li>
<li><b>tsn_gptp</b>: Implementation of the IEEE 802.1 AS gptp protocol.</li>
</ul>
<p>This stack can be used for production and testing purposes. For more information about the stack, please refer to PDK documentation:</p>
<ul>
<li>API Guide is located under <em>Time Sensitive Networking (TSN) Stack</em> section of PDK API Guide.</li>
<li>User's Guide is located under <em>TSN Integration</em> section of the ENET module in PDK User's Guide.</li>
</ul>
<p>The utilisation of these resources by gPTP stack on Ethernet Firmware is as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Resource  </th><th class="markdownTableHeadCenter">Count  </th><th class="markdownTableHeadLeft">gPTP Usage (mcu2_0)   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">TX channel  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyLeft">To transmit PTP packets   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">RX flow  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyLeft">To receive PTP packets (filtered by PTP multicast and EtherType)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MAC address  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyLeft">Shared with TCP/IP lwIP netif   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The gPTP stack is supported only in FreeRTOS. It's not supported in SafeRTOS.</dd></dl>
<h3><a class="anchor" id="ethfw_depend_lwip_proxyarp"></a>
Ethernet Firmware Proxy ARP</h3>
<p>Enet LLD lwIP interface implementation provides a hook to let application <em>process</em> a packet and indicate whether the packet needs additional handling (i.e. be passed to the lwIP stack) or if the packet can be recycled (i.e. already handled by the application).</p>
<p>This feature enables Ethernet Firmware to implement Proxy ARP functionality needed to respond to ARP Request packets on behalf of Ethernet Firmware's remote core clients as broadcast packets are passed exclusively to Main R5F core 0, not to each individual remote core.</p>
<p>Ethernet Firmware sets up a dedicated UDMA RX flow where packets that have ARP EtherType and broadcast destination MAC address are routed to. While lwIP interface is processing packets from this RX flow, it will call the <em>packet processing</em> function registered by Ethernet Firmware. Ethernet Firmware then checks if the packet is meant for any of its remote core clients, if so, it responds on its behalf and packet is recycled as it needs not be passed to lwIP stack. If the packet is not meant to any of the remote cores, it's simply passed to the lwIP stack, ARP request packets meant for Ethernet Firmware itself fall into this processing category.</p>
<h3><a class="anchor" id="ethfw_depend_safertos"></a>
SafeRTOS</h3>
<p>Ethernet Firmware requires the following SafeRTOS kernel versions, depending on the SoC being used.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">SoC  </th><th class="markdownTableHeadNone">ISA  </th><th class="markdownTableHeadNone">SafeRTOS package version   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">J721E  </td><td class="markdownTableBodyNone">R5F  </td><td class="markdownTableBodyNone">009-004-199-024-219-001   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">J7200  </td><td class="markdownTableBodyNone">R5F  </td><td class="markdownTableBodyNone">009-002-199-024-243-001   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">J784S4  </td><td class="markdownTableBodyNone">R5F  </td><td class="markdownTableBodyNone">009-004-199-024-251-001   </td></tr>
</table>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="ethfw_instal_ccs"></a>
IDE (CCS)</h2>
<p>Install Code Composer Studio and setup a <b>Target Configuration</b> for use with J721E, J7200 or J784S4 EVM. Refer to the instructions in <em>CCS Setup</em> section of the Processor SDK RTOS documentation.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_instal_steps"></a>
Installation Steps</h1>
<hr/>
<p>Ethernet Firmware and its dependencies are part of the SDK, separate installation is not required.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_dir"></a>
Directory Structure</h1>
<p>Post installation of SDK, the following directory would be created. Please note that this is an indicative snap-shot, modules could be added/modified.</p>
<p>The top-level EthFw makefile as well as the auxiliary makefiles for build flags (<b>ethfw_build_flags.mak</b>) and build paths (<b>ethfw_tools_path.mak</b>) can be found at the EthFw top-level directory.</p>
<h2><a class="anchor" id="ethfw_post_install_j721e"></a>
Post Install Directory Structure</h2>
<div class="image">
<img src="c_ug_dir_top.png" alt="c_ug_dir_top.png"/>
<div class="caption">
Top Level Directory Structure</div></div>
<h2><a class="anchor" id="ethfw_dir_utils"></a>
Utilities Directory Structure</h2>
<p>The <b>utils</b> directory contains miscellaneous utilities required by the EthFw applications.</p>
<div class="image">
<img src="c_ug_dir_utils.png" alt="c_ug_dir_utils.png"/>
<div class="caption">
Utilities Directory Structure</div></div>
<h2><a class="anchor" id="ethfw_dir_demo"></a>
Demo Application Sources Directory Structure</h2>
<p>Source code of the EthFw demo applications is in the <b>apps</b> directory. For instance, below image shows the directory structure of the server application which implements L2 switch, inter-VLAN routing, etc.</p>
<div class="image">
<img src="c_ug_dir_l2_switching_demo.png" alt="c_ug_dir_l2_switching_demo.png"/>
<div class="caption">
EthFw Server-side Application Directory Structure</div></div>
<p> Pre-compiled binaries are also provided as part of the EthFw release, which can be found in the <b>out</b> directory. For instance, below image shows the EthFw output directory structure with pre-compiled server and client binaries.</p>
<div class="image">
<img src="c_ug_dir_j721_r5f_demo.png" alt="c_ug_dir_j721_r5f_demo.png"/>
<div class="caption">
Demo Binaries Directory Structure</div></div>
<p> <a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="ethfw_dir_switch_demos"></a>
EthFw Demonstration Applications</h2>
<p>Refer to <a class="el" href="demo_top.html">EthFw Demo Applications</a> section for a full list of EthFw demo applications.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_build_top"></a>
Build</h1>
<hr/>
<p> EthFw employs Concerto makefile-based build system. When building on a Windows based machine, tools such as <a href="https://www.cygwin.com/">Cygwin</a> could be used.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="ethfw_build_setup_env"></a>
Setup Environment</h2>
<p>The tool paths required by the build system are defined in the <code>ethfw_tools_path.mak</code> makefile. The default paths in <code>ethfw_tools_path.mak</code> are defined based on the assumption that the EthFw package has been installed inside the Processor SDK main directory.</p>
<p>Typically, the Processor SDK installation path is <code>~/ti</code> in Linux-based systems. So, a typical EthFw installation would be at <code>~/ti/ti-processor-sdk-rtos-j721e-evm-08_xx_yy_zz</code> or similarly for other SoCs. In this case, no additional environment setup steps are required.</p>
<p>If either Processor SDK or EthFw have been installed at different locations that those mentioned in previous paragraph, the following variables can be passed to the make command: </p><pre class="fragment">make &lt;target&gt; PSDK_PATH=&lt;Processor SDK installation path&gt; ETHFW_PATH=&lt;EthFw installation path&gt;
</pre><p>Please refer to the <a class="el" href="ethfw_c_ug_top.html#ethfw_build">Build</a> and <a class="el" href="ethfw_c_ug_top.html#ethfw_build_clean">Clean</a> sections for a list of recommended targets. Alternatively, run the following command to get the full list of valid targets: </p><pre class="fragment">make help
</pre><p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="ethfw_build"></a>
Build</h2>
<p>The make commands listed below require the environment setup according to <a class="el" href="ethfw_c_ug_top.html#ethfw_build_setup_env">Setup Environment</a> section.</p>
<h3><a class="anchor" id="ethfw_build_all"></a>
Build All</h3>
<p>Build EthFw components as well as its dependencies, including PDK, lwIP, etc.</p>
<p>For J721E: </p><pre class="fragment">make ethfw_all BUILD_SOC_LIST=J721E
</pre><p>For J7200: </p><pre class="fragment">make ethfw_all BUILD_SOC_LIST=J7200
</pre><p>For J784S4: </p><pre class="fragment">make ethfw_all BUILD_SOC_LIST=J784S4
</pre><p>By default, above commands will build Ethernet Firmware for FreeRTOS.</p>
<p>Verbose build can be enabled by setting the <b>SHOW_COMMANDS</b> variable as shown below: </p><pre class="fragment">make ethfw_all BUILD_SOC_LIST=&lt;SOC&gt; SHOW_COMMANDS=1
</pre><p>On successful compilation, the output folder would be created at <code>&lt;ethfw&gt;/out</code>.</p>
<h3><a class="anchor" id="ethfw_safertos_build_all"></a>
SafeRTOS Build</h3>
<p>The RTOS used in Ethernet Firmware build is determined by the following flags, which can be set in <code>ethfw_build_flags.mk</code> or passed to the make command:</p>
<ul>
<li><code>BUILD_APP_FREERTOS</code> enables FreeRTOS build of EthFw and RTOS client.</li>
<li><code>BUILD_APP_SAFERTOS</code> enables SafeRTOS build of EthFw and RTOS client. It requires SafeRTOS kernel installed in SDK installation path.</li>
</ul>
<p>The location of the SafeRTOS package can be changed through the <code>SAFERTOS_KERNEL_INSTALL_r5f_&lt;SOC&gt;</code> variable in <code>ethfw_tools_path.mak</code>. The SafeRTOS version validated for each SoC can also be found in <code>ethfw_tools_path.mak</code>.</p>
<p>Build for SafeRTOS only, FreeRTOS build disabled: </p><pre class="fragment">make ethfw_all BUILD_SOC_LIST=&lt;SOC&gt; BUILD_APP_FREERTOS=no BUILD_APP_SAFERTOS=yes
</pre><p>Build for SafeRTOS and FreeRTOS: </p><pre class="fragment">make ethfw_all BUILD_SOC_LIST=&lt;SOC&gt; BUILD_APP_FREERTOS=yes BUILD_APP_SAFERTOS=yes
</pre><h3><a class="anchor" id="ethfw_qnx_build_all"></a>
QNX Build</h3>
<p>Ethernet Firmware for QNX OS client integration on A72 is built with the standard make command: </p><pre class="fragment">make ethfw_all BUILD_SOC_LIST=&lt;SOC&gt;
</pre><p>It's worth noting that above command also builds EthFw binaries for integration with Linux and CCS, as well as RTOS client.</p>
<p>Alternatively, user may choose to build Ethernet Firmware server for QNX only using below command: </p><pre class="fragment">make ethfw_server_qnx BUILD_SOC_LIST=&lt;SOC&gt;
</pre><p>There are two main differences between QNX and Linux builds of Ethernet Firmware:</p>
<ul>
<li>For QNX integration, EthFW would not load the IPC resource table, unlike in Linux.</li>
<li><a class="el" href="ethfw_c_ug_top.html#ethfw_intercore_eth">Inter-core Virtual Ethernet</a> is disabled, as QNX virtual client currently doesn't support this feature.</li>
</ul>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="ethfw_build_clean"></a>
Clean</h2>
<p>The make commands listed below require the environment setup according to <a class="el" href="ethfw_c_ug_top.html#ethfw_build_setup_env">Setup Environment</a> section.</p>
<h3><a class="anchor" id="ethfw_build_clean_all"></a>
Clean All</h3>
<p>Clean EthFw components as well as its dependencies: </p><pre class="fragment">make ethfw_all_clean BUILD_SOC_LIST=&lt;SOC&gt;
</pre><h3><a class="anchor" id="ethfw_build_clean_binaries"></a>
Remove build output</h3>
<p>Remove EthFw build output directory only. </p><pre class="fragment">make scrub
</pre><p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="ethfw_build_profiles"></a>
Profiles</h2>
<ul>
<li><b>Debug</b>: Mostly used to development or debugging <pre class="fragment">make ethfw_all BUILD_SOC_LIST=&lt;SOC&gt; PROFILE=debug
</pre></li>
<li><b>Release</b>: Recommended to be used for optimized components and production builds <pre class="fragment">make ethfw_all BUILD_SOC_LIST=&lt;SOC&gt; PROFILE=release
</pre></li>
</ul>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="ethfw_build_eg_linker"></a>
Examples Linker File (Select memory location to hold example binary)</h2>
<p>The example applications use different memories and this could be changed and/or re-configured via linker command files.</p>
<ul>
<li><b>linker_mem_map.cmd</b> is auto generated file using PyTI_PSDK_RTOS tool which defines memory layout (addresses and sizes)<ul>
<li>Available at <code>&lt;ethfw_xx_yy_zz_bb&gt;/apps/app_&lt;name&gt;/&lt;core&gt;/linker_mem_map.cmd</code></li>
</ul>
</li>
<li><b>linker.cmd</b> defines the section mappings used by EthFw application<ul>
<li>Sets optimal memories for time critical symbols ("text_fast")</li>
<li>Available at <code>&lt;ethfw_xx_yy_zz_bb&gt;/apps/app_&lt;name&gt;/&lt;core&gt;/linker.cmd</code></li>
</ul>
</li>
</ul>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_run_eg"></a>
Running Examples</h1>
<hr/>
<h2><a class="anchor" id="ethfw_run_ccs_load_binary"></a>
Load Example Binaries</h2>
<p>Refer to <a class="el" href="demo_top.html">EthFw Demo Applications</a> section for a full list of EthFw demo applications.</p>
<p>For detailed steps to load and run the demo application, please refer to the <a class="el" href="demo_ethfw_combined_top.html#demo_ethfw_combined_setup_cfg">Demo Setup</a> section.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_uninstall"></a>
Un Installation</h1>
<hr/>
<p>Delete the complete <code>ethfw_xx_yy_zz_bb</code> folder.</p>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_known_issues"></a>
Known issues</h1>
<p>Please refer to the Ethernet Firmware Release Notes.</p>
<p><a class="el" href="ethfw_c_ug_top.html#ethfw_known_issues">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_cflag"></a>
Compiler Flags used</h1>
<hr/>
<h2><a class="anchor" id="ethfw_cflag_debug"></a>
Demo Application - Profile: Debug</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Flag  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-O0</code>  </td><td class="markdownTableBodyNone">Optimization level 0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=MAKEFILE_BUILD</code>  </td><td class="markdownTableBodyNone">Makefile-based build type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=TARGET_BUILD=2</code>  </td><td class="markdownTableBodyNone">Identifies the build profile as 'debug'   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D_DEBUG_=1</code>  </td><td class="markdownTableBodyNone">Identifies as debug build   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=ETHFW_CCS</code>  </td><td class="markdownTableBodyNone">Identifies ETHFW build for CCS boot, disabled for U-Boot/SBL build   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=SOC_J721E</code>  </td><td class="markdownTableBodyNone">Identifies the J721E SoC type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=J721E</code>  </td><td class="markdownTableBodyNone">Identifies the J721E device type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=SOC_J7200</code>  </td><td class="markdownTableBodyNone">Identifies the J7200 SoC type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=J7200</code>  </td><td class="markdownTableBodyNone">Identifies the J7200 device type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=SOC_J784S4</code>  </td><td class="markdownTableBodyNone">Identifies the J784S4 SoC type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=J784s4</code>  </td><td class="markdownTableBodyNone">Identifies the J784S4 device type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=R5Ft="R5Ft"</code>  </td><td class="markdownTableBodyNone">Identifies the core type as ARM R5F with Thumb2 enabled   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=TARGET_NUM_CORES=2</code>  </td><td class="markdownTableBodyNone">Identifies the core id as mcu2_0 (ETHFW server)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=TARGET_NUM_CORES=3</code>  </td><td class="markdownTableBodyNone">Identifies the core id as mcu2_1 (RTOS client)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=TARGET_ARCH=32</code>  </td><td class="markdownTableBodyNone">Identifies the target architecture as 32-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=ARCH_32</code>  </td><td class="markdownTableBodyNone">Identifies the architecture as 32-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=FREERTOS</code>  </td><td class="markdownTableBodyNone">Identifies as FreeRTOS operating system build   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=SAFERTOS</code>  </td><td class="markdownTableBodyNone">Identifies as SafeRTOS operating system build   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=ETHFW_PROXY_ARP_SUPPORT</code>  </td><td class="markdownTableBodyNone">Enable Proxy ARP support on EthFw server   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=ETHAPP_ENABLE_INTERCORE_ETH</code>  </td><td class="markdownTableBodyNone">Enable Intercore Virtual Ethernet support (disabled in QNX images)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=ETHAPP_ENABLE_IPERF_SERVER</code>  </td><td class="markdownTableBodyNone">Enable lwIP iperf server support (TCP only)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=ENABLE_QSGMII_PORTS</code>  </td><td class="markdownTableBodyNone">Enable QSGMII ports in QpENet expansion board (applicable only to J721E)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=ETHFW_BOOT_TIME_PROFILING</code>  </td><td class="markdownTableBodyNone">Enable special ETHFW configuration for boot time profiling (TI internal)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=ETHFW_DEMO_SUPPORT</code>  </td><td class="markdownTableBodyNone">Enable ETHFW demos, such as hardware and software interVLAN, GUI configurator tool, etc.   </td></tr>
</table>
<p>Other common flags:</p>
<div class="fragment"><div class="line">-Wno-extra -Wno-exceptions -ferror-limit=100 -Wno-parentheses-equality -Wno-unused-command-line-argument -Wno-gnu-variable-sized-type-not-at-end -Wno-unused-function -Wno-inconsistent-missing-override -Wno-address-of-packed-member -Wno-self-assign -Wno-ignored-attributes -Wno-bitfield-constant-conversion -Wno-unused-const-variable -Wno-unused-variable -Wno-format-security -Wno-excess-initializers -Wno-sometimes-uninitialized -Wno-empty-body -Wno-extern-initializer -Wno-absolute-value -Wno-missing-braces -Wno-ti-macros -Wno-pointer-sign -Wno-macro-redefined -Wno-main-return-type -Werror -O0 -ggdb3 -mfloat-abi=hard -mfpu=vfpv3 -D16 -mcpu=cortex-r5 -march=armv7-r -mthumb -fno-strict-aliasing  -ffunction-sections</div></div><!-- fragment --><p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="ethfw_cflag_release"></a>
Demo Application - Profile: Release</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Flag  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-O3</code>  </td><td class="markdownTableBodyNone">Optimization level 3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=MAKEFILE_BUILD</code>  </td><td class="markdownTableBodyNone">Makefile-based build type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=TARGET_BUILD=1</code>  </td><td class="markdownTableBodyNone">Identifies the build profile as 'release'   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=ETHFW_CCS</code>  </td><td class="markdownTableBodyNone">Identifies ETHFW build for CCS boot, disabled for U-Boot/SBL build   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=SOC_J721E</code>  </td><td class="markdownTableBodyNone">Identifies the J721E SoC type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=J721E</code>  </td><td class="markdownTableBodyNone">Identifies the J721E device type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=SOC_J7200</code>  </td><td class="markdownTableBodyNone">Identifies the J7200 SoC type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=J7200</code>  </td><td class="markdownTableBodyNone">Identifies the J7200 device type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=SOC_J784S4</code>  </td><td class="markdownTableBodyNone">Identifies the J784S4 SoC type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=J784S4</code>  </td><td class="markdownTableBodyNone">Identifies the J784S4 device type   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=R5Ft="R5Ft"</code>  </td><td class="markdownTableBodyNone">Identifies the core type as ARM R5F with Thumb2 enabled   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=TARGET_NUM_CORES=2</code>  </td><td class="markdownTableBodyNone">Identifies the core id as mcu2_0 (ETHFW server)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=TARGET_NUM_CORES=3</code>  </td><td class="markdownTableBodyNone">Identifies the core id as mcu2_1 (RTOS client)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=TARGET_ARCH=32</code>  </td><td class="markdownTableBodyNone">Identifies the target architecture as 32-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=ARCH_32</code>  </td><td class="markdownTableBodyNone">Identifies the architecture as 32-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=FREERTOS</code>  </td><td class="markdownTableBodyNone">Identifies as FreeRTOS operating system build   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=SAFERTOS</code>  </td><td class="markdownTableBodyNone">Identifies as SafeRTOS operating system build   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=ETHFW_PROXY_ARP_SUPPORT</code>  </td><td class="markdownTableBodyNone">Enable Proxy ARP support on EthFw server   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=ETHAPP_ENABLE_INTERCORE_ETH</code>  </td><td class="markdownTableBodyNone">Enable Intercore Virtual Ethernet support (disabled in QNX images)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=ETHAPP_ENABLE_IPERF_SERVER</code>  </td><td class="markdownTableBodyNone">Enable lwIP iperf server support (TCP only)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=ENABLE_QSGMII_PORTS</code>  </td><td class="markdownTableBodyNone">Enable QSGMII ports in QpENet expansion board (applicable only to J721E)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-D=ETHFW_BOOT_TIME_PROFILING</code>  </td><td class="markdownTableBodyNone">Enable special ETHFW configuration for boot time profiling (TI internal)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-D=ETHFW_DEMO_SUPPORT</code>  </td><td class="markdownTableBodyNone">Enable ETHFW demos, such as hardware and software interVLAN, GUI configurator tool, etc.   </td></tr>
</table>
<p>Other common flags:</p>
<div class="fragment"><div class="line">-Wno-extra -Wno-exceptions -ferror-limit=100 -Wno-parentheses-equality -Wno-unused-command-line-argument -Wno-gnu-variable-sized-type-not-at-end -Wno-unused-function -Wno-inconsistent-missing-override -Wno-address-of-packed-member -Wno-self-assign -Wno-ignored-attributes -Wno-bitfield-constant-conversion -Wno-unused-const-variable -Wno-unused-variable -Wno-format-security -Wno-excess-initializers -Wno-sometimes-uninitialized -Wno-empty-body -Wno-extern-initializer -Wno-absolute-value -Wno-missing-braces -Wno-ti-macros -Wno-pointer-sign -Wno-macro-redefined -Wno-main-return-type -Werror -O3 -mfloat-abi=hard -mfpu=vfpv3 -D16 -mcpu=cortex-r5 -march=armv7-r -mthumb -fno-strict-aliasing  -ffunction-sections</div></div><!-- fragment --><p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_supported_family"></a>
Supported Device Families</h1>
<hr/>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Device Family  </th><th class="markdownTableHeadNone">Variant  </th><th class="markdownTableHeadNone">Known by other name   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="3">Jacinto 7  </td><td class="markdownTableBodyNone">J721E  </td><td class="markdownTableBodyNone">-   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">J7200  </td><td class="markdownTableBodyNone">-   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">J784S4  </td><td class="markdownTableBodyNone">-   </td></tr>
</table>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="ethfw_rev_history"></a>
Document Revision History</h1>
<hr/>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Revision  </th><th class="markdownTableHeadNone">Date  </th><th class="markdownTableHeadNone">Author  </th><th class="markdownTableHeadNone">Description ------&mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.1  </td><td class="markdownTableBodyNone">01 Apr 2019  </td><td class="markdownTableBodyNone">Prasad J, Misael Lopez  </td><td class="markdownTableBodyNone">Created for v.0.08.00   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.2  </td><td class="markdownTableBodyNone">02 Apr 2019  </td><td class="markdownTableBodyNone">Prasad J  </td><td class="markdownTableBodyNone">0.8 Docs review meeting fixes   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.3  </td><td class="markdownTableBodyNone">12 Jun 2019  </td><td class="markdownTableBodyNone">Prasad J  </td><td class="markdownTableBodyNone">Updates for EVM demo (.85 release)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.4  </td><td class="markdownTableBodyNone">17 Jul 2019  </td><td class="markdownTableBodyNone">Misael Lopez  </td><td class="markdownTableBodyNone">Updates for v.0.09.00   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.5  </td><td class="markdownTableBodyNone">15 Oct 2019  </td><td class="markdownTableBodyNone">Misael Lopez, Santhana Bharathi  </td><td class="markdownTableBodyNone">Updates for v.1.00.00   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">1.0  </td><td class="markdownTableBodyNone">28 Jan 2020  </td><td class="markdownTableBodyNone">Misael Lopez  </td><td class="markdownTableBodyNone">Updates for SDK 6.02.00   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1.1  </td><td class="markdownTableBodyNone">31 Aug 2020  </td><td class="markdownTableBodyNone">Misael Lopez  </td><td class="markdownTableBodyNone">Added J7200 support for SDK 7.01 EA   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone">02 Nov 2020  </td><td class="markdownTableBodyNone">Misael Lopez  </td><td class="markdownTableBodyNone">Updated for Enet LLD migration   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1.3  </td><td class="markdownTableBodyNone">01 Dec 2021  </td><td class="markdownTableBodyNone">Nitin Sakhuja  </td><td class="markdownTableBodyNone">Adedd Inter-core Ethernet support for SDK 8.1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">1.4  </td><td class="markdownTableBodyNone">07 Dec 2021  </td><td class="markdownTableBodyNone">Misael Lopez  </td><td class="markdownTableBodyNone">Adedd MAC-only, server and client doc   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1.5  </td><td class="markdownTableBodyNone">01 Jul 2021  </td><td class="markdownTableBodyNone">Misael Lopez  </td><td class="markdownTableBodyNone">Updates for J784S4 support and SDK 8.02.01   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">1.6  </td><td class="markdownTableBodyNone">10 Feb 2023  </td><td class="markdownTableBodyNone">Misael Lopez  </td><td class="markdownTableBodyNone">Added SafeRTOS build info   </td></tr>
</table>
<p><a class="el" href="ethfw_c_ug_top.html">Back To Top</a> (<a class="el" href="ethfw_c_ug_top.html">User Guide</a>) </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
