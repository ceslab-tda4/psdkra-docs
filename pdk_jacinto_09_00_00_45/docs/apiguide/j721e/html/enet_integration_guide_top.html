<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>PDK API Guide for J721E: Enet Integration Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PDK API Guide for J721E
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('enet_integration_guide_top.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Enet Integration Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="GettingFamiliarWithAPIs"></a>
Getting Familiar with Enet LLD APIs</h1>
<hr/>
<p>The Enet LLD APIs can be broadly divided into two categories: control and data path. The control APIs can be used to configure all Ethernet hardware submodules like FDB, MAC port, host port, MDIO, statistics, as well as PHY drivers and resource management. The data path APIs are exclusive for the DMA-based data transfers between the TI SoC processing cores and the Ethernet peripheral.</p>
<p>The main APIs of the Enet LLD are the following:</p>
<ul>
<li><a class="el" href="group__ENET__MAIN__API.html#ga40325ec5d06d5d7788ec71609edd7ac0" title="Open and initializes the Enet driver for a peripheral.">Enet_open()</a></li>
<li><a class="el" href="group__ENET__MAIN__API.html#ga4710f1318cbf2089a92a50609a403c39" title="Close the Enet peripheral.">Enet_close()</a></li>
<li><a class="el" href="group__ENET__MAIN__API.html#gaf48cc1d13141375e4a404d3078785bce" title="Issue an operation on the Enet Peripheral.">Enet_ioctl()</a></li>
<li><a class="el" href="group__ENET__MAIN__API.html#ga6394f7b1160a819195c02c646952b10e" title="Poll for Ethernet events.">Enet_poll()</a></li>
<li><a class="el" href="group__ENET__MAIN__API.html#gae58c8009140824a5172ded24074de1b3" title="Run periodic tick on the Ethernet peripheral.">Enet_periodicTick()</a></li>
<li><a class="el" href="group__ENET__DMA__API.html#gabca588621f4ee706b03fc679a28f7dab" title="Enet DMA open RX channel.">EnetDma_openRxCh()</a></li>
<li><a class="el" href="group__ENET__DMA__API.html#ga252cb60a9a99c57c501d6231a01b02e1" title="Enet DMA close RX channel.">EnetDma_closeRxCh()</a></li>
<li><a class="el" href="group__ENET__DMA__API.html#ga307c5cd4018bcbe9d5ed4a68ad45aff4" title="Enet DMA open TX channel.">EnetDma_openTxCh()</a></li>
<li><a class="el" href="group__ENET__DMA__API.html#gab3b86ea3690a28867f7ec81628c323ab" title="Enet DMA close TX channel.">EnetDma_closeTxCh()</a></li>
<li><a class="el" href="group__ENET__DMA__API.html#ga818e945ac6f5d62b01186c9089673292" title="Retrieve queue of RX ready (full) packets from RX channel.">EnetDma_retrieveRxPktQ()</a></li>
<li><a class="el" href="group__ENET__DMA__API.html#ga6a80baccc431ce40d5d97a1f0d930252" title="Submit queue of RX free (empty) packets for reception to RX channel.">EnetDma_submitRxPktQ()</a></li>
<li><a class="el" href="group__ENET__DMA__API.html#ga0825a26fc168e6a68fa9948ac37125cc" title="Retrieve queue of TX free (empty) packets from TX channel.">EnetDma_retrieveTxPktQ()</a></li>
<li><a class="el" href="group__ENET__DMA__API.html#gac80790c3fbf88c40ce547c41c6164ae6" title="Submit a queue of ready (full) packets to TX channel.">EnetDma_submitTxPktQ()</a></li>
</ul>
<p>It's worth noting that the control path APIs are mainly IOCTL-based, and the data path APIs are direct functions in order to avoid any additional overhead associated with IOCTL calls as DMA data operations occur highly frequently.</p>
<h2><a class="anchor" id="IOCTL_description"></a>
IOCTL Interface</h2>
<hr/>
<p>IOCTLs are system calls that take an argument specifying the command code and can take none or additional parameters via <a class="el" href="structEnet__IoctlPrms.html">Enet_IoctlPrms</a> argument. IOCTL are used by all Enet submodules except for DMA.</p>
<p>The <a class="el" href="structEnet__IoctlPrms.html">Enet_IoctlPrms</a> parameter structure consists of input and output argument pointers and their corresponding size. The following helper macros are provided to help construct the IOCTL params:</p>
<ul>
<li><a class="el" href="group__ENET__MAIN__API.html#gaaad4b5efb9f5ea339451948acbb8b0cc" title="Set null args for an IOCTL command that takes no arguments.">ENET_IOCTL_SET_NO_ARGS(prms)</a>. Used for IOCTL commands that take no parameters.</li>
<li><a class="el" href="group__ENET__MAIN__API.html#ga4244317c67802020a93c2ed38c9dd797" title="Set the input args for an IOCTL command.">ENET_IOCTL_SET_IN_ARGS(prms, in)</a>. Used for IOCTL commands that take input parameters but don't output any parameter.</li>
<li><a class="el" href="group__ENET__MAIN__API.html#gab818bd5097baff64160ad178c39c076d" title="Set the output args for an IOCTL command.">ENET_IOCTL_SET_OUT_ARGS(prms, out)</a>. Used for IOCTL commands that don't take input parameters but return output parameters.</li>
<li><a class="el" href="group__ENET__MAIN__API.html#ga89441673a211ade1b8232ff9417ec09e" title="Set the input and output args for an IOCTL command.">ENET_IOCTL_SET_INOUT_ARGS(prms, in, out)</a>. Used for IOCTL commands that take input parameters and also return output parameters.</li>
</ul>
<p>where <code>prms</code> in a pointer to <a class="el" href="structEnet__IoctlPrms.html">Enet_IoctlPrms</a> variable, <code>in</code> is the pointer to IOCTL input argument and <code>out</code> is the pointer to IOCTL output argument.</p>
<p>It's recommended that the application doesn't set the <a class="el" href="structEnet__IoctlPrms.html">Enet_IoctlPrms</a> members individually, but only through the helper macros listed above.</p>
<p>Please refer to the individual IOCTL command to find out if it requires input and/or output parameters.</p>
<p><a class="el" href="enet_integration_guide_top.html">Back To Top</a></p>
<h1><a class="anchor" id="enet_integration_in_app"></a>
Integrating Enet LLD into User's Application</h1>
<hr/>
<p>Developers who wish to add network connectivity to the applications running on TI SoCs, will have to integrate Enet LLD by following the below sequence:</p>
<ol type="1">
<li><a class="el" href="enet_integration_guide_top.html#enet_init_sequence">Init Sequence</a>. One-time initialization before using any Enet LLD APIs.</li>
<li><a class="el" href="enet_integration_guide_top.html#enet_open_sequence">Peripheral Open Sequence</a>. Opens an Ethernet peripheral, it's called for each peripheral that the application intends to use, i.e. ICSSG0 and CPSW.</li>
<li><a class="el" href="enet_integration_guide_top.html#enet_openport_sequence">Port Open Sequence</a>. Opens a MAC port. For peripherals that provide multiple MAC port (i.e. CPSW9G that has 8 MAC ports), this sequence must be followed for each MAC port. This section also covers MAC-PHY and MAC-MAC links.</li>
<li><a class="el" href="enet_integration_guide_top.html#enet_pktrxtx_sequence">Packet Send/Receive Sequence</a>. DMA TX and RX channel open sequences as well as functions to use to submit and retrieve queue of packets to/from the driver.</li>
<li><a class="el" href="enet_integration_guide_top.html#enet_pktts_sequence">Packet Timestamping Sequence</a>. TX and RX packet timestamping sequence to enable timestamping and retrieval mechanism.</li>
<li><a class="el" href="enet_integration_guide_top.html#enet_closeport_sequence">Port Close Sequence</a>. Closes a MAC port. Application has to close all MAC ports which were opened in step 3 when no longer needs those ports.</li>
<li><a class="el" href="enet_integration_guide_top.html#enet_close_sequence">Peripheral Close Sequence</a>. Closes an Ethernet peripheral when the application no longer needs it. This sequence must be followed for each peripheral that was opened in step 2.</li>
<li><a class="el" href="enet_integration_guide_top.html#enet_deinit_sequence">Deinit Sequence</a>. One-time deinitialization once application is done using Enet LLD.</li>
</ol>
<p>Each of these sequences will be covered in detail in the following sections.</p>
<h2><a class="anchor" id="enet_init_sequence"></a>
Init Sequence</h2>
<p>This is a one-time initialization where the application sets the OSAL and utils functions that Enet LLD will use throughout its lifecycle.</p>
<p>At this stage Enet LLD also initializes its SoC layer which contains data about the Ethernet hardware available in the TI device.</p>
<p>The application should follow the next steps:</p>
<ol type="1">
<li>(Optional) <a class="el" href="group__ENET__MAIN__API.html#gac4b4dfb4dbba42909aa63fd568c55046">Enet_initOsalCfg()</a> to initialize the OSAL configuration (see <a class="el" href="structEnetOsal__Cfg.html">EnetOsal_Cfg</a>) with a default implementation. The default implementation of Enet OSAL interface is based on PDK OSAL layer. Typically, applications can directly use the default Enet OSAL implementation, unless Enet is being used on another OS (i.e. QNX) of if OS is not supported by PDK OSAL layer.</li>
<li>(Optional) <a class="el" href="group__ENET__MAIN__API.html#ga6370b438a831f249741d3fbd350b8463">Enet_initUtilsCfg()</a> to initialize utils configuration (see <a class="el" href="structEnetUtils__Cfg.html">EnetUtils_Cfg</a>) with a default implementation. The default implementation of Enet Utils interface is UART-based logging and one-to-one address translations (physical-to-virtual and virtual-to-physical). Applications may want to pass their own utils' print function if UART is not available. Similarly, if a MMU is present and used, applications may need to pass their own address translation functions corresponding to the MMU configuration. <pre class="fragment"> utilsCfg.print = UART_printf;
 utilsCfg.physToVirt = &amp;myPhysToVirtFxn;
 utilsCfg.virtToPhys = &amp;myVirtToPhysFxn;
</pre></li>
<li><a class="el" href="group__ENET__MAIN__API.html#gad22d4821f84e9199841146ebaadcc305">Enet_init()</a> to pass the OSAL and utils configurations setup in the previous two steps. The application can pass NULL to either the OSAL config or utils config if it intends to use the driver's default implementation.</li>
</ol>
<h2><a class="anchor" id="enet_open_sequence"></a>
Peripheral Open Sequence</h2>
<p>This is an initialization that needs to be done for each peripheral in the system. The configuration parameters described in this section are peripheral specific.</p>
<p>Application should follow the next steps:</p>
<ol type="1">
<li>Initialize the peripheral configuration parameters with default values using <a class="el" href="group__ENET__MAIN__API.html#ga9fa168341383aac623bc20867e79d6b1">Enet_initCfg()</a>. Although the application can fill all parameters manually, it's recommended to first get the driver's default values for all parameters and only overwrite the parameters of interest.<ul>
<li>CPSW peripheral configuration - <a class="el" href="structCpsw__Cfg.html">Cpsw_Cfg</a> structure has the configuration parameters for CPSW Enet Peripheral, such as:<ul>
<li>Configuration of DMA: <a class="el" href="group__ENET__UDMA__API.html#ga94b069644e134415ee9611dbe1bd2ece">EnetDma_Cfg</a>.</li>
<li>VLAN configuration (inner/outer VLAN, customer/service switch): <a class="el" href="structCpsw__VlanCfg.html">Cpsw_VlanCfg</a>.</li>
<li>Max packet length transmitted on egress: <a class="el" href="structCpsw__Cfg.html#ad62b7b5c4f099289bc5b0655506ef117">Cpsw_Cfg::txMtu</a>.</li>
<li>Configuration of the host (CPPI) port: <a class="el" href="structCpswHostPort__Cfg.html">CpswHostPort_Cfg</a>.</li>
<li>Configure of the ALE submodule: <a class="el" href="structCpswAle__Cfg.html">CpswAle_Cfg</a>.</li>
<li>Configure of the CPTS submodule: <a class="el" href="structCpswCpts__Cfg.html">CpswCpts_Cfg</a>.</li>
<li>Configuration of the MDIO submodule: <a class="el" href="structMdio__Cfg.html">Mdio_Cfg</a>.</li>
<li>Configuration of CPSW Resource Partition: <a class="el" href="structEnetRm__ResCfg.html">EnetRm_ResCfg</a>.</li>
</ul>
</li>
<li>ICSSG peripheral configuration - Similarly, ICSSG has its own dedicated configuration structure called <a class="el" href="structIcssg__Cfg.html">Icssg_Cfg</a> where the application passes ICSSG specific configuration parameters, such as:<ul>
<li>Configuration of the MDIO submodule: <a class="el" href="structMdio__Cfg.html">Mdio_Cfg</a>.</li>
<li>Configuration of TimeSync: <a class="el" href="structIcssgTimeSync__Cfg.html">IcssgTimeSync_Cfg</a>.</li>
<li>Configuration of DMA Resource Partition: <a class="el" href="structEnetRm__ResCfg.html">EnetRm_ResCfg</a>.</li>
<li>Configuration of host port's default: <a class="el" href="structEnetPort__VlanCfg.html">EnetPort_VlanCfg</a>. This is applicable only to ICSSG Switch peripherals which start by default in VLAN aware mode.</li>
</ul>
</li>
</ul>
</li>
<li>Once done with the configuration of the parameters, the UDMA driver has to be opened. Enet utils library provides a helper function called EnetAppUtils_udmaOpen() to open the UDMA driver, and returns a handle that can be passed to the peripheral configuration parameters, i.e. <a class="el" href="structCpsw__Cfg.html#a99b5f147f47eb768f2067bd5731f568d">Cpsw_Cfg::dmaCfg</a>.</li>
<li><a class="el" href="group__ENET__MAIN__API.html#ga40325ec5d06d5d7788ec71609edd7ac0">Enet_open()</a> to open a peripheral, passing the configuration parameters previously initialized. <a class="el" href="group__ENET__MAIN__API.html#ga40325ec5d06d5d7788ec71609edd7ac0">Enet_open()</a> function takes the following arguments:<ul>
<li>Peripheral type - This specifies the type or class of the peripheral, i.e. CPSW, ICSSG or other.</li>
<li>Instance number - This argument specifies the instance number of the peripheral. Refer to <a class="el" href="enetlld_top.html#enetlld_enetpers">Enet Peripherals</a> section for further information about specific peripheral types and instance numbers.</li>
<li>Configuration structure - A pointer to the peripheral-specific configuration structure, i.e. <a class="el" href="structCpsw__Cfg.html">Cpsw_Cfg</a> or <a class="el" href="structIcssg__Cfg.html">Icssg_Cfg</a>.</li>
<li>Size of the configuration structure.</li>
</ul>
</li>
<li>If the module is opened successfully, the API will return a valid handle pointer to the Enet driver. It's worth noting that there will be a unique Enet handle (<a class="el" href="enet__base_8h.html#aaf6a26638306b81ac1148da6da42f513">Enet_Handle</a>) for each peripheral opened.</li>
<li>Attach the core with the Resource Manager (RM) using <a class="el" href="enet__per_8h.html#a5e37e31ddf40acdd06e84bbf2cf413c0a35881d860c7370884c040a0a6d0c7ffd">ENET_PER_IOCTL_ATTACH_CORE</a>. IOCTL. To use IOCTLs, the application must have the following:<ul>
<li>Valid handle to the driver.</li>
<li>Core ID, which can be obtained using <a class="el" href="enet__soc_8h.html#ac34f14a8269455a613229af83d02ef4d">EnetSoc_getCoreId()</a>.</li>
<li>Valid IOCTL command.</li>
<li>Valid pointer to the IOCTL parameters.</li>
</ul>
</li>
<li>Once the application attaches the core with Resource Manager (RM), the IOCTL call will return core key which has to be used in all further RM-related calls.</li>
<li>A MAC address for the host port is to be obtained using Enet utils helper function EnetAppUtils_allocMac() and the corresponding entry in the ALE table can be added using EnetAppUtils_addHostPortEntry().</li>
<li>Allocate memory for Ring Accelerators, Ethernet packets, etc. Enet LLD examples use <code>EnetAppMemUtils</code> to take care of all memory allocation and freeing operations. The developer can take this as reference or can implement their own memory allocation functions.</li>
<li><p class="startli">ICSSG Switch runs in VLAN aware mode, so it requires the following IOCTLs to setup the VLAN:</p><ul>
<li>Add a VLAN entry for all ports (host port and the two MAC ports) using <a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbaea749baea1b03268eae19af4fdd10421">ICSSG_PER_IOCTL_VLAN_SET_ENTRY</a>.</li>
<li>Add a FDB entry for the VLAN Id using <a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbaf872f28fc60ce1535a4bec36ae46b449">ICSSG_FDB_IOCTL_ADD_ENTRY</a>.</li>
</ul>
<p class="startli">Refer to Enet Multiport example for a reference implementation.</p>
</li>
</ol>
<h2><a class="anchor" id="enet_openport_sequence"></a>
Port Open Sequence</h2>
<p>The MAC ports can be opened in MAC-to-PHY or MAC-to-MAC mode. In MAC-to-PHY mode, Enet LLD's PHY driver state machine will be used to configure the Ethernet PHY. In MAC-to-MAC mode, the PHY driver will be bypassed entirely.</p>
<p>The link speed and duplexity in MAC-to-PHY can be fixed or auto-negotiated, while in MAC-to-MAC, both link speed and duplexity can be fixed only and must be provided by application.</p>
<p>The steps to open and configure ports in either MAC-to-PHY or MAC-to-MAC modes are shown below.</p>
<h3>MAC-PHY link</h3>
<ol type="1">
<li>Set the port number in <a class="el" href="structEnetPer__PortLinkCfg.html">EnetPer_PortLinkCfg</a> structure.</li>
<li>Set the MAC port interface (RMII, RGMII, SGMII, etc) through the layer, sublayer and variant fields of <a class="el" href="structEnetPer__PortLinkCfg.html#a5b44defddd2475eb49d91b63693c86f9">EnetPer_PortLinkCfg::mii</a>.</li>
<li>The MAC port configuration parameters is peripheral dependent.<ul>
<li>CPSW MAC Port configuration:<ul>
<li>Use <a class="el" href="group__CPSW__MACPORT__MOD.html#ga0840800cbfc598300796592a959e0577">CpswMacPort_initCfg()</a> to initialize the CPSW MAC port configuration parameters to their default values. Overwrite any parameters as needed.</li>
<li>If loopback is to be enabled, set enableLoopback flag in MAC configuration to true. For loopback to be functional the secure flag in host port ALE entry must be set to false. The host port entry update can be done using the <a class="el" href="group__CPSW__ALE__MOD.html#ggabed7e8ccaf9e220220ce26e85697cb98a7bcf6d287ab7f189bafe5df389332263">CPSW_ALE_IOCTL_ADD_UCAST</a> command.</li>
</ul>
</li>
<li>ICSSG MAC Port configuration:<ul>
<li>Use <a class="el" href="group__DRV__ENET__ICSSG.html#gaf70332779a14ad506288283116114709">IcssgMacPort_initCfg()</a> to fill MAC port configuration parameters with default values provided by the ICSSG driver. The application can then overwrite any configuration parameter as needed, i.e. unicast flooding, multicast flooding, etc.</li>
<li>ICSSG Switch runs in VLAN aware mode, so the MAC port's default VLAN (<a class="el" href="structEnetPort__VlanCfg.html">EnetPort_VlanCfg</a>) must be passed via <a class="el" href="structIcssgMacPort__Cfg.html#aac69741e9121bf08b7da699c51226f51">IcssgMacPort_Cfg::vlanCfg</a>.</li>
<li>ICSSG Dual-MAC runs in VLAN unaware mode, so no default VLAN configuration is required.</li>
</ul>
</li>
</ul>
</li>
<li>Set PHY configuration parameters: generic and model specific.<ol type="a">
<li>Use <a class="el" href="group__DRV__ENETPHY.html#gaff5006a4c712434d31f67b3d5d4b3bf9">EnetPhy_initCfg()</a> to initialize the PHY generic parameters to their default values, such as auto-negotiation capabilities, strap enable/disable, loopback, etc.</li>
<li>Use PHY specific init config functions to initialize model specific parameters. This init config function is provided by the Ethernet PHYs supported in Enet LLD. For example, <a class="el" href="group__ENETPHY__DP83867.html#ga304aac6fd8cf554d7c01fd8e8a659e66">Dp83867_initCfg()</a> is used to initialize config params for DP83867 PHYs.</li>
<li>Application can also use the Enet helper function EnetBoard_getPhyCfg() to get PHY configuration information for PHYs in TI EVMs.</li>
</ol>
</li>
<li>Set the link speed and duplexity configuration in <a class="el" href="structEnetPer__PortLinkCfg.html#acb11a2278c001e8f5297f35fba6ea8dc">EnetPer_PortLinkCfg::linkCfg</a>.<ul>
<li>For auto-negotiation, use <a class="el" href="group__ENET__MAIN__API.html#gga0bef5cbad0a87693c51f5b607be13feba2fc673ea1a9100a3396e83e393ae6fae">ENET_SPEED_AUTO</a> or <a class="el" href="group__ENET__MAIN__API.html#gga3431e11a2089b5fd51a2059c8e80dc67a4b78a0c8fcc61de7734a2a2b8ff99671">ENET_DUPLEX_AUTO</a>.</li>
<li>For fixed (manual) configuration, use the fixed speeds and duplexity values in defined in <a class="el" href="group__ENET__MAIN__API.html#ga0bef5cbad0a87693c51f5b607be13feb">Enet_Speed</a> and <a class="el" href="group__ENET__MAIN__API.html#ga3431e11a2089b5fd51a2059c8e80dc67">Enet_Duplexity</a> enumerations.</li>
</ul>
</li>
<li>Once all the MAC and PHY configurations are done, the ports can be opened by calling the <a class="el" href="enet__per_8h.html#a5e37e31ddf40acdd06e84bbf2cf413c0ad5684ee47181741d4c11d9de6bd5fbe1">ENET_PER_IOCTL_OPEN_PORT_LINK</a> command.</li>
<li><em>CPSW Note</em>: To enable RMII on CPSW9G, external 50 MHz RMII clock from PHY is used on SOC RMII_REF_CLOCK pin. On GESI board, this clock is connected as resistor R225 is not populated. To get RMII_50MHZ_CLK, resistor R225 needs to be populated. We need to move R226 to R225 on GESI board to get this clock.</li>
<li>If all the above steps succeeded without any errors, then the Enet driver, the Ethernet peripheral and a MAC port have been opened successfully.</li>
<li>After opening the port, the driver will run its PHY state machine to configure the PHY and eventually get <em>link up</em> status. Application can query the port link using <a class="el" href="enet__per_8h.html#a5e37e31ddf40acdd06e84bbf2cf413c0a5d823381e45afc7c88a81552bae578fd">ENET_PER_IOCTL_IS_PORT_LINK_UP</a>.<ul>
<li>Application can check the PHY alive status (i.e. whether PHY is present on the MDIO bus) using the <a class="el" href="group__ENET__MOD__MDIO.html#gga3d1296252044e355873ecdb16dd19baba9281fd98f13f05a63e857ae6a8c0c3f7">ENET_MDIO_IOCTL_IS_ALIVE</a> command.</li>
</ul>
</li>
<li>Once link up is detected, application should do the following steps:<ul>
<li>CPSW:<ul>
<li>Set the ALE port state to <code>Forward</code> state using <a class="el" href="group__CPSW__ALE__MOD.html#ggabed7e8ccaf9e220220ce26e85697cb98a9e89ff165647c66926bf7685d3d84f08">CPSW_ALE_IOCTL_SET_PORT_STATE</a> IOCTL command.</li>
<li>Enable the host port of CPSW by calling the <a class="el" href="group__ENET__MOD__HOSTPORT.html#gga65ee5012f8178049e634eb8b7e42959ca64be6840551cb1b537bc6cfb8a0fba4e">ENET_HOSTPORT_IOCTL_ENABLE</a> command.</li>
</ul>
</li>
<li>ICSSG:<ul>
<li>Set the MAC port state to <code>Forward</code> state using <a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbae4452faf865471e87b9091577fd54d0f">ICSSG_PER_IOCTL_SET_PORT_STATE</a> IOCTL command.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The following code snippet shows how a MAC-PHY link is opened (step 1-6 above). CPSW MAC port 1 connected to a DP83867 RGMII PHY has been chosen for this example.</p>
<div class="fragment"><div class="line"><a class="code" href="structEnet__IoctlPrms.html">Enet_IoctlPrms</a> prms;</div><div class="line"><a class="code" href="structEnetPer__PortLinkCfg.html">EnetPer_PortLinkCfg</a> portLinkCfg;</div><div class="line"><a class="code" href="structEnetMacPort__LinkCfg.html">EnetMacPort_LinkCfg</a> *linkCfg = &amp;portLinkCfg.<a class="code" href="structEnetPer__PortLinkCfg.html#acb11a2278c001e8f5297f35fba6ea8dc">linkCfg</a>;</div><div class="line"><a class="code" href="structEnetMacPort__Interface.html">EnetMacPort_Interface</a> *mii = &amp;portLinkCfg.<a class="code" href="structEnetPer__PortLinkCfg.html#a5b44defddd2475eb49d91b63693c86f9">mii</a>;</div><div class="line"><a class="code" href="structCpswMacPort__Cfg.html">CpswMacPort_Cfg</a> cpswMacCfg;</div><div class="line"><a class="code" href="structEnetPhy__Cfg.html">EnetPhy_Cfg</a> *phyCfg = &amp;portLinkCfg.<a class="code" href="structEnetPer__PortLinkCfg.html#ac49dc7eafa9eb2498599e6dc74759f36">phyCfg</a>;</div><div class="line"><a class="code" href="structDp83867__Cfg.html">Dp83867_Cfg</a> dp83867Cfg;</div><div class="line"></div><div class="line"><span class="comment">/* Step 1 - MAC port 1 */</span></div><div class="line">portLinkCfg-&gt;<a class="code" href="structEnetPer__PortLinkCfg.html#a2c02466c17327b6963355acdeb3722a0">macPort</a> = <a class="code" href="group__ENET__MAIN__API.html#gga263f2a3003e793a56d3def727e2b6a4fa374942dc0d9af695a2844d886c069ff6">ENET_MAC_PORT_1</a>;</div><div class="line"></div><div class="line"><span class="comment">/* Step 2 - Set port type to RGMII */</span></div><div class="line">mii-&gt;<a class="code" href="structEnetMacPort__Interface.html#a506724797a467a263c1a1bddcaabf837">layerType</a>    = <a class="code" href="group__ENET__MOD__MACPORT.html#gga046d087375dda93eb619534f98d934d1a80614a8acf9d3f222c1c77813e93cc97">ENET_MAC_LAYER_GMII</a>;</div><div class="line">mii-&gt;<a class="code" href="structEnetMacPort__Interface.html#a3db3e6be82433d2f5d6c86d8abd3e93e">sublayerType</a> = <a class="code" href="group__ENET__MOD__MACPORT.html#ggab152ef6c56c6e2ae46bff9a98b370d12a76327445685a653eb966a703cee8b3e9">ENET_MAC_SUBLAYER_REDUCED</a>;</div><div class="line">mii-&gt;<a class="code" href="structEnetMacPort__Interface.html#a04a2368a6f261fedc2895faa27568e47">variantType</a>  = <a class="code" href="group__ENET__MOD__MACPORT.html#ggae9fcecf4a51faf27590a0576d7ae803fa3d8b72717e469c33a80bda14d5a81921">ENET_MAC_VARIANT_FORCED</a>;</div><div class="line"></div><div class="line"><span class="comment">/* Step 3 - Initialize MAC port configuration parameters */</span></div><div class="line"><a class="code" href="group__CPSW__MACPORT__MOD.html#ga0840800cbfc598300796592a959e0577">CpswMacPort_initCfg</a>(&amp;cpswMacCfg);</div><div class="line">portLinkCfg.<a class="code" href="structEnetPer__PortLinkCfg.html#ad70805ae17f447479f5bc53a850a4402">macCfg</a> = &amp;cpswMacCfg;</div><div class="line"></div><div class="line"><span class="comment">/* Step 4a - Set PHY generic configuration parameters */</span></div><div class="line"><a class="code" href="group__DRV__ENETPHY.html#gaff5006a4c712434d31f67b3d5d4b3bf9">EnetPhy_initCfg</a>(phyCfg);</div><div class="line">phyCfg-&gt;<a class="code" href="structEnetPhy__Cfg.html#a8ddec0dca674469bd9ff7c9d4aeb6aba">phyAddr</a> = 0U;</div><div class="line"></div><div class="line"><span class="comment">/* Step 4b - DP83867 PHY specific configuration */</span></div><div class="line"><a class="code" href="group__ENETPHY__DP83867.html#ga304aac6fd8cf554d7c01fd8e8a659e66">Dp83867_initCfg</a>(&amp;dp83867Cfg);</div><div class="line">dp83867Cfg.<a class="code" href="structDp83867__Cfg.html#a798d555a1a75422e9b6b18b82bcc9384">ledMode</a>[1] = <a class="code" href="group__ENETPHY__DP83867.html#ggabf70c55354619c5ad2cd74abe0751e0ea5623fa04afc316997d642a0c5dffaae5">DP83867_LED_LINKED_100BTX</a>;</div><div class="line">dp83867Cfg.<a class="code" href="structDp83867__Cfg.html#a798d555a1a75422e9b6b18b82bcc9384">ledMode</a>[2] = <a class="code" href="group__ENETPHY__DP83867.html#ggabf70c55354619c5ad2cd74abe0751e0ea716a6ba3faa945ac277346599c32c545">DP83867_LED_RXTXACT</a>;</div><div class="line">dp83867Cfg.<a class="code" href="structDp83867__Cfg.html#a798d555a1a75422e9b6b18b82bcc9384">ledMode</a>[3] = <a class="code" href="group__ENETPHY__DP83867.html#ggabf70c55354619c5ad2cd74abe0751e0ea11ffa2c16a786f82acb4ae8b49c14c00">DP83867_LED_LINKED_1000BT</a>;</div><div class="line"><a class="code" href="group__DRV__ENETPHY.html#ga5f7008641bf565765c557f55756937a4">EnetPhy_setExtendedCfg</a>(phyCfg, &amp;dp83867Cfg, <span class="keyword">sizeof</span>(dp83867Cfg));</div><div class="line"></div><div class="line"><span class="comment">/* Step 5 - Set link speed/duplexity to auto-negotiation */</span></div><div class="line">linkCfg-&gt;<a class="code" href="structEnetMacPort__LinkCfg.html#a8839c991fe644d6f50f46c6ab23aa684">speed</a>     = <a class="code" href="group__ENET__MAIN__API.html#gga0bef5cbad0a87693c51f5b607be13feba2fc673ea1a9100a3396e83e393ae6fae">ENET_SPEED_AUTO</a>;</div><div class="line">linkCfg-&gt;<a class="code" href="structEnetMacPort__LinkCfg.html#a1de48922a0688d1594234c63bfd9baf1">duplexity</a> = <a class="code" href="group__ENET__MAIN__API.html#gga3431e11a2089b5fd51a2059c8e80dc67a4b78a0c8fcc61de7734a2a2b8ff99671">ENET_DUPLEX_AUTO</a>;</div><div class="line"></div><div class="line"><span class="comment">/* Step 6 - Open port link */</span></div><div class="line"><a class="code" href="group__ENET__MAIN__API.html#ga4244317c67802020a93c2ed38c9dd797">ENET_IOCTL_SET_IN_ARGS</a>(&amp;prms, &amp;portLinkCfg);</div><div class="line">status = <a class="code" href="group__ENET__MAIN__API.html#gaf48cc1d13141375e4a404d3078785bce">Enet_ioctl</a>(hEnet, coreId, <a class="code" href="enet__per_8h.html#a5e37e31ddf40acdd06e84bbf2cf413c0ad5684ee47181741d4c11d9de6bd5fbe1">ENET_PER_IOCTL_OPEN_PORT_LINK</a>, &amp;prms);</div></div><!-- fragment --><h3>MAC-to-MAC link</h3>
<ol type="1">
<li>Set the port number in <a class="el" href="structEnetPer__PortLinkCfg.html#a2c02466c17327b6963355acdeb3722a0">EnetPer_PortLinkCfg::macPort</a>.</li>
<li>Set the MAC port interface (RMII, RGMII, SGMII, etc) through the layer, sublayer and variant fields of <a class="el" href="structEnetPer__PortLinkCfg.html#a5b44defddd2475eb49d91b63693c86f9">EnetPer_PortLinkCfg::mii</a>.</li>
<li>Initialize the MAC configuration parameters using <a class="el" href="group__CPSW__MACPORT__MOD.html#ga0840800cbfc598300796592a959e0577">CpswMacPort_initCfg()</a> and manually overwrite any parameters that differ from defaults.</li>
<li>Set PHY address to <a class="el" href="group__DRV__ENETPHY.html#gaac99db2dbc6b1607f75384f3aa15fdba" title="Invalid PHY address indicator.">ENETPHY_INVALID_PHYADDR</a> to indicate that this is a PHY-less connection.</li>
<li>Set the link speed and duplexity configuration in <a class="el" href="structEnetPer__PortLinkCfg.html#acb11a2278c001e8f5297f35fba6ea8dc">EnetPer_PortLinkCfg::linkCfg</a> to match those of the partner MAC port. The speed and duplexity must be fixed values, they can't be <a class="el" href="group__ENET__MAIN__API.html#gga0bef5cbad0a87693c51f5b607be13feba2fc673ea1a9100a3396e83e393ae6fae">ENET_SPEED_AUTO</a> or <a class="el" href="group__ENET__MAIN__API.html#gga3431e11a2089b5fd51a2059c8e80dc67a4b78a0c8fcc61de7734a2a2b8ff99671">ENET_DUPLEX_AUTO</a> as they are used for auto-negotiation which is not relevant in MAC-to-MAC mode.</li>
<li>Once all the MAC and PHY configurations are done, the ports can be opened by calling the <a class="el" href="enet__per_8h.html#a5e37e31ddf40acdd06e84bbf2cf413c0ad5684ee47181741d4c11d9de6bd5fbe1">ENET_PER_IOCTL_OPEN_PORT_LINK</a> command.</li>
<li>If all the above steps succeeded without any errors, then the Enet driver, the Ethernet peripheral and a MAC port have been opened successfully.</li>
<li>Once link up is detected, application should do the following steps:<ul>
<li>CPSW:<ul>
<li>Set the ALE port state to <code>Forward</code> state using <a class="el" href="group__CPSW__ALE__MOD.html#ggabed7e8ccaf9e220220ce26e85697cb98a9e89ff165647c66926bf7685d3d84f08">CPSW_ALE_IOCTL_SET_PORT_STATE</a> IOCTL command.</li>
<li>Enable the host port of CPSW by calling the <a class="el" href="group__ENET__MOD__HOSTPORT.html#gga65ee5012f8178049e634eb8b7e42959ca64be6840551cb1b537bc6cfb8a0fba4e">ENET_HOSTPORT_IOCTL_ENABLE</a> command.</li>
</ul>
</li>
<li>ICSSG:<ul>
<li>Set the MAC port state to <code>Forward</code> state using <a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbae4452faf865471e87b9091577fd54d0f">ICSSG_PER_IOCTL_SET_PORT_STATE</a> IOCTL command.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The following code snippet shows how a MAC-to-MAC link is opened (steps 1-6 above). CPSW MAC port 1 connected to partner MAC using RGMII interface at 1 Gbps.</p>
<div class="fragment"><div class="line"><a class="code" href="structEnet__IoctlPrms.html">Enet_IoctlPrms</a> prms;</div><div class="line"><a class="code" href="structEnetPer__PortLinkCfg.html">EnetPer_PortLinkCfg</a> portLinkCfg;</div><div class="line"><a class="code" href="structEnetMacPort__LinkCfg.html">EnetMacPort_LinkCfg</a> *linkCfg = &amp;portLinkCfg.<a class="code" href="structEnetPer__PortLinkCfg.html#acb11a2278c001e8f5297f35fba6ea8dc">linkCfg</a>;</div><div class="line"><a class="code" href="structEnetMacPort__Interface.html">EnetMacPort_Interface</a> *mii = &amp;portLinkCfg.<a class="code" href="structEnetPer__PortLinkCfg.html#a5b44defddd2475eb49d91b63693c86f9">mii</a>;</div><div class="line"><a class="code" href="structCpswMacPort__Cfg.html">CpswMacPort_Cfg</a> cpswMacCfg;</div><div class="line"><a class="code" href="structEnetPhy__Cfg.html">EnetPhy_Cfg</a> *phyCfg = &amp;portLinkCfg.<a class="code" href="structEnetPer__PortLinkCfg.html#ac49dc7eafa9eb2498599e6dc74759f36">phyCfg</a>;</div><div class="line"></div><div class="line"><span class="comment">/* Step 1 - MAC port 1 */</span></div><div class="line">portLinkCfg-&gt;<a class="code" href="structEnetPer__PortLinkCfg.html#a2c02466c17327b6963355acdeb3722a0">macPort</a> = <a class="code" href="group__ENET__MAIN__API.html#gga263f2a3003e793a56d3def727e2b6a4fa374942dc0d9af695a2844d886c069ff6">ENET_MAC_PORT_1</a>;</div><div class="line"></div><div class="line"><span class="comment">/* Step 2 - Set port type to RGMII */</span></div><div class="line">mii-&gt;<a class="code" href="structEnetMacPort__Interface.html#a506724797a467a263c1a1bddcaabf837">layerType</a>    = <a class="code" href="group__ENET__MOD__MACPORT.html#gga046d087375dda93eb619534f98d934d1a80614a8acf9d3f222c1c77813e93cc97">ENET_MAC_LAYER_GMII</a>;</div><div class="line">mii-&gt;<a class="code" href="structEnetMacPort__Interface.html#a3db3e6be82433d2f5d6c86d8abd3e93e">sublayerType</a> = <a class="code" href="group__ENET__MOD__MACPORT.html#ggab152ef6c56c6e2ae46bff9a98b370d12a76327445685a653eb966a703cee8b3e9">ENET_MAC_SUBLAYER_REDUCED</a>;</div><div class="line">mii-&gt;<a class="code" href="structEnetMacPort__Interface.html#a04a2368a6f261fedc2895faa27568e47">variantType</a>  = <a class="code" href="group__ENET__MOD__MACPORT.html#ggae9fcecf4a51faf27590a0576d7ae803fa3d8b72717e469c33a80bda14d5a81921">ENET_MAC_VARIANT_FORCED</a>;</div><div class="line"></div><div class="line"><span class="comment">/* Step 3 - Initialize MAC port configuration parameters */</span></div><div class="line"><a class="code" href="group__CPSW__MACPORT__MOD.html#ga0840800cbfc598300796592a959e0577">CpswMacPort_initCfg</a>(&amp;cpswMacCfg);</div><div class="line">portLinkCfg.<a class="code" href="structEnetPer__PortLinkCfg.html#ad70805ae17f447479f5bc53a850a4402">macCfg</a> = &amp;cpswMacCfg;</div><div class="line"></div><div class="line"><span class="comment">/* Step 4 - Indicate that this is a PHY-less MAC-to-MAC connection */</span></div><div class="line">phyCfg-&gt;<a class="code" href="structEnetPhy__Cfg.html#a8ddec0dca674469bd9ff7c9d4aeb6aba">phyAddr</a> = <a class="code" href="group__DRV__ENETPHY.html#gaac99db2dbc6b1607f75384f3aa15fdba">ENETPHY_INVALID_PHYADDR</a>;</div><div class="line"></div><div class="line"><span class="comment">/* Step 5 - Link speed/duplexity must be explicit set, cannot be set to auto */</span></div><div class="line">linkCfg-&gt;<a class="code" href="structEnetMacPort__LinkCfg.html#a8839c991fe644d6f50f46c6ab23aa684">speed</a>     = <a class="code" href="group__ENET__MAIN__API.html#gga0bef5cbad0a87693c51f5b607be13febaaa37947dda4d02f5194c39aa3a95b7f9">ENET_SPEED_1GBIT</a>;</div><div class="line">linkCfg-&gt;<a class="code" href="structEnetMacPort__LinkCfg.html#a1de48922a0688d1594234c63bfd9baf1">duplexity</a> = <a class="code" href="group__ENET__MAIN__API.html#gga3431e11a2089b5fd51a2059c8e80dc67aa177d6f0218e0439e0d15bb4dd98b0e5">ENET_DUPLEX_FULL</a>;</div><div class="line"></div><div class="line"><span class="comment">/* Step 6 - Open port link */</span></div><div class="line"><a class="code" href="group__ENET__MAIN__API.html#ga4244317c67802020a93c2ed38c9dd797">ENET_IOCTL_SET_IN_ARGS</a>(&amp;prms, &amp;portLinkCfg);</div><div class="line">status = <a class="code" href="group__ENET__MAIN__API.html#gaf48cc1d13141375e4a404d3078785bce">Enet_ioctl</a>(hEnet, coreId, <a class="code" href="enet__per_8h.html#a5e37e31ddf40acdd06e84bbf2cf413c0ad5684ee47181741d4c11d9de6bd5fbe1">ENET_PER_IOCTL_OPEN_PORT_LINK</a>, &amp;prms);</div></div><!-- fragment --><h2><a class="anchor" id="enet_pktrxtx_sequence"></a>
Packet Send/Receive Sequence</h2>
<ol type="1">
<li>The DMA channels to enable data transfer are to be opened. It can be done using the below steps:<ul>
<li>Initialize the Tx Channel and Rx Flow parameters using <a class="el" href="group__ENET__DMA__API.html#ga9689fd512e610f36af17f67a0930da9b">EnetDma_initTxChParams()</a> and <a class="el" href="group__ENET__DMA__API.html#ga152d84a01d1b87306ea4ff7d20ce27b5">EnetDma_initRxChParams()</a>, respectively.</li>
<li>For Tx Channel set the following parameters:<ul>
<li><a class="el" href="structEnetUdma__OpenTxChPrms.html#a9f25dbc74a1f26362447b41a23798af3">EnetUdma_OpenTxChPrms::chNum</a>: Tx Channel number.</li>
<li><a class="el" href="structEnetUdma__OpenTxChPrms.html#af9054e861d937fb8b1a321147b3ed03c">EnetUdma_OpenTxChPrms::hUdmaDrv</a>: UDMA driver handle obtained before.</li>
<li><a class="el" href="structEnetUdma__OpenTxChPrms.html#a6f31c6f2902ba9088e17e81efd59a088">EnetUdma_OpenTxChPrms::ringMemAllocFxn</a>: EnetMem_allocRingMem. or equivalent user preferred function.</li>
<li><a class="el" href="structEnetUdma__OpenTxChPrms.html#a36722258fd2c474b74a731076311c46a">EnetUdma_OpenTxChPrms::ringMemFreeFxn</a>: EnetMem_freeRingMem or equivalent user preferred function.</li>
<li><a class="el" href="structEnetUdma__OpenTxChPrms.html#a6a3aefbeacc464313350a19901b21af0">EnetUdma_OpenTxChPrms::numTxPkts</a>: number of Tx packets used to alloc ring elements, and descriptors.</li>
<li><a class="el" href="structEnetUdma__OpenTxChPrms.html#aa44b9ed5f96f95f7e1366a21b7364aa5">EnetUdma_OpenTxChPrms::disableCacheOpsFlag</a>: true/false.</li>
<li><a class="el" href="structEnetUdma__OpenTxChPrms.html#ab360f8b6584f6fae6c27f81e5ebee50c">EnetUdma_OpenTxChPrms::dmaDescAllocFxn</a>: EnetMem_allocDmaDesc or equivalent user preferred function.</li>
<li><a class="el" href="structEnetUdma__OpenTxChPrms.html#a40c9ce0d77708fafa2cdba11b7a6ce0c">EnetUdma_OpenTxChPrms::dmaDescFreeFxn</a>: EnetMem_freeDmaDesc or equivalent user preferred function.</li>
<li><a class="el" href="structEnetUdma__OpenTxChPrms.html#acf5d0178490829718f43fc8ebd1d50f4">EnetUdma_OpenTxChPrms::cbArg</a>: Argument to be used for the callback routines.</li>
</ul>
</li>
<li>For Rx Flow set the following parameters:<ul>
<li><a class="el" href="structEnetUdma__OpenRxFlowPrms.html#a81a318ac229c125b234fac249e636e32">EnetUdma_OpenRxFlowPrms::startIdx</a>: Rx flow start index.</li>
<li><a class="el" href="structEnetUdma__OpenRxFlowPrms.html#a5a85af00cf2c7601716a5e950e5b2673">EnetUdma_OpenRxFlowPrms::flowIdx</a>: Rx flow number.</li>
<li><a class="el" href="structEnetUdma__OpenRxFlowPrms.html#a5287087d2516ed259ebc37c85041021d">EnetUdma_OpenRxFlowPrms::hUdmaDrv</a>: UDMA driver handle obtained previously.</li>
<li><a class="el" href="structEnetUdma__OpenRxFlowPrms.html#a632d1cf5bd909e65b9e18de9781176ae">EnetUdma_OpenRxFlowPrms::ringMemAllocFxn</a>: EnetMem_allocRingMem or equivalent user preferred function.</li>
<li><a class="el" href="structEnetUdma__OpenRxFlowPrms.html#a9cdf2d38a0e7fce32075961c64f6348b">EnetUdma_OpenRxFlowPrms::ringMemFreeFxn</a>: EnetMem_freeRingMem or equivalent user preferred function.</li>
<li><a class="el" href="structEnetUdma__OpenRxFlowPrms.html#a6aac1098977b0ee3a3e039bc2b638114">EnetUdma_OpenRxFlowPrms::numRxPkts</a>: number of Rx packets used to alloc ring elements, and descriptors.</li>
<li><a class="el" href="structEnetUdma__OpenRxFlowPrms.html#a7438749e178d601e88a3e6b2af65800c">EnetUdma_OpenRxFlowPrms::rxFlowMtu</a>: Maximum receive packet length for this flow.</li>
<li><a class="el" href="structEnetUdma__OpenRxFlowPrms.html#a75545b92016d1c1455e1fbf8a89ae253">EnetUdma_OpenRxFlowPrms::disableCacheOpsFlag</a>: true/false.</li>
<li><a class="el" href="structEnetUdma__OpenRxFlowPrms.html#a5e293ae7d9f9c26dbb4fa76d96f76cca">EnetUdma_OpenRxFlowPrms::dmaDescAllocFxn</a>: EnetMem_allocDmaDesc or equivalent user preferred function.</li>
<li><a class="el" href="structEnetUdma__OpenRxFlowPrms.html#aab87d2cfc0f1c501f6ef65d9514be27a">EnetUdma_OpenRxFlowPrms::dmaDescFreeFxn</a>: EnetMem_freeDmaDesc. or equivalent user preferred function.</li>
<li><a class="el" href="structEnetUdma__OpenRxFlowPrms.html#a7e5077afb525e11eed68f4fce43df076">EnetUdma_OpenRxFlowPrms::cbArg</a>: Argument to be used for the callback routines.</li>
</ul>
</li>
<li>After setting the parameters, open the channel and flow using Enet utils helper functions EnetAppUtils_openTxCh() and EnetAppUtils_openRxFlow(), respectively.</li>
<li>ICSSG Switch requires two UDMA RX flows in two different UDMA RX channels, one for each ICSSG slice. The application should use EnetAppUtils_openRxFlowForChIdx() helper function instead. This helper function takes a channel index, so the application must call EnetAppUtils_openRxFlowForChIdx() twice, one time for index 0 and another for index 1.</li>
</ul>
</li>
<li>Now that the Ethernet peripheral (CPSW or ICSSG) and UDMA are configured, the application can start the data transfer.<ul>
<li>To transmit data from application:<ul>
<li>Call <a class="el" href="group__ENET__DMA__API.html#gac80790c3fbf88c40ce547c41c6164ae6">EnetDma_submitTxPktQ()</a> to submit the packets that are ready to be transmitted to Tx Free Queue.</li>
<li>Call <a class="el" href="group__ENET__DMA__API.html#ga0825a26fc168e6a68fa9948ac37125cc">EnetDma_retrieveTxPktQ()</a> to retrieve back the packets that were successfully transmitted from Tx Completion Queue.</li>
</ul>
</li>
<li>To receive packets that are queued up in the CPSW or ICSSG hardware which are ready to be received by the application:<ul>
<li>Call <a class="el" href="group__ENET__DMA__API.html#ga818e945ac6f5d62b01186c9089673292">EnetDma_retrieveRxPktQ()</a> to retrieve packets from Rx Completion Queue that are sent to the application.</li>
<li>Call <a class="el" href="group__ENET__DMA__API.html#ga6a80baccc431ce40d5d97a1f0d930252">EnetDma_submitRxPktQ()</a> to submit new packets to Rx Free Queue, so that newly received packets can be copied.</li>
</ul>
</li>
<li>ICSSG Switch requires two different UDMA RX flows, hence the application must retrieve and submit packets via two different queues. Conversely, the ICSSG Dual-MAC only uses a single RX flow, hence packet submit/retrieve happens on a single queue.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="enet_pktts_sequence"></a>
Packet Timestamping Sequence</h2>
<ol type="1">
<li>RX packet timestamping doesn't require any enable sequence. The timestamps in nanoseconds will be returned to the application along with the DMA packet info data, that is, in the <a class="el" href="structEnetUdma__PktTsInfo.html#a4425ea140bc5632a4110798667efa526">EnetUdma_PktTsInfo::rxPktTs</a> field of <a class="el" href="structEnetUdma__PktInfo.html#a07e7876a92de4057b9fe3c84e4896821">EnetUdma_PktInfo::tsInfo</a> after retrieving RX packets using <a class="el" href="group__ENET__DMA__API.html#ga818e945ac6f5d62b01186c9089673292">EnetDma_retrieveRxPktQ()</a>.</li>
<li>Application must register a callback function in advance for TX timestamp event (<a class="el" href="group__ENET__MAIN__API.html#gga40859f551befdba0d34a90a869b7a5aaadd7d8e8acbee2c862e76b86eb6785454">ENET_EVT_TIMESTAMP_TX</a>) via <a class="el" href="group__ENET__MAIN__API.html#gaf2845eb8de556d2b9b21f0a4762ad86d">Enet_registerEventCb()</a> function. The callback registration can be done at any time before enabling TX timestamping.</li>
<li>TX packet timestamping requires to be enabled per packet via DMA packet info <a class="el" href="structEnetUdma__PktInfo.html#a07e7876a92de4057b9fe3c84e4896821">EnetUdma_PktInfo::tsInfo</a> structure:<ul>
<li>Enable host TX timestamp by setting <a class="el" href="structEnetUdma__PktTsInfo.html#abe199d73e645361db231f68251c0690a">EnetUdma_PktTsInfo::enableHostTxTs</a> to true.</li>
<li>Pass a sequence id which will be used later to correlate the timestamp with the packet it belongs to. The sequence id is passed in <a class="el" href="structEnetUdma__PktTsInfo.html#a423815c3882e9f507e8f4f6f89e99d26">EnetUdma_PktTsInfo::txPktSeqId</a>.</li>
<li>TX packet domain and message type are relevant only for CPSW peripheral. They should be set in <a class="el" href="structEnetUdma__PktTsInfo.html#af2b5b9f84c4a6f2a350a0745ebef4374">EnetUdma_PktTsInfo::txPktMsgType</a> and <a class="el" href="structEnetUdma__PktTsInfo.html#aef02ff23c2a569bb59982eb301e4c454">EnetUdma_PktTsInfo::txPktDomain</a>.</li>
</ul>
</li>
<li>After the packet is submitted for transmission using <a class="el" href="group__ENET__DMA__API.html#gac80790c3fbf88c40ce547c41c6164ae6">EnetDma_submitTxPktQ()</a>, the timestamp can be retrieved using <a class="el" href="group__ENET__MAIN__API.html#ga6394f7b1160a819195c02c646952b10e">Enet_poll()</a> function.<ul>
<li>Application calls <a class="el" href="group__ENET__MAIN__API.html#ga6394f7b1160a819195c02c646952b10e">Enet_poll()</a> with event type <a class="el" href="group__ENET__MAIN__API.html#gga40859f551befdba0d34a90a869b7a5aaadd7d8e8acbee2c862e76b86eb6785454">ENET_EVT_TIMESTAMP_TX</a> periodically until the register callback is called.</li>
<li>The MAC port where timestamp is being polled is specified via <a class="el" href="group__ENET__MAIN__API.html#ga6394f7b1160a819195c02c646952b10e" title="Poll for Ethernet events.">Enet_poll()</a> <code>arg</code> parameter.<ul>
<li>In ICSSG Dual-MAC peripherals, <code>arg</code> parameter must always be set to <a class="el" href="group__ENET__MAIN__API.html#gga263f2a3003e793a56d3def727e2b6a4fa374942dc0d9af695a2844d886c069ff6">ENET_MAC_PORT_1</a>.</li>
<li>In ICSSG Switch peripherals, <code>arg</code> parameter must be set to <a class="el" href="group__ENET__MAIN__API.html#gga263f2a3003e793a56d3def727e2b6a4fa374942dc0d9af695a2844d886c069ff6">ENET_MAC_PORT_1</a> or <a class="el" href="group__ENET__MAIN__API.html#gga263f2a3003e793a56d3def727e2b6a4fa8c6c22f0c6900eb42d88039c8fea2e72">ENET_MAC_PORT_2</a>.</li>
</ul>
</li>
<li>The returned timestamp is a value in clock cycles for CPSW peripheral and a value in nanoseconds for ICSSG peripheral.</li>
<li>The sequence id set to before sending packet for transmission in field <a class="el" href="structEnetUdma__PktTsInfo.html#a423815c3882e9f507e8f4f6f89e99d26">EnetUdma_PktTsInfo::txPktSeqId</a> will be passed to the registered callback. Application can use this value to correlate the packet it comes from.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="enet_ioctl_sequence"></a>
IOCTL Sequence</h2>
<ol type="1">
<li>Some common IOCTLs have already been mentioned in this document so far. But the application can run any other IOCTL supported by the peripheral. There are two kinds of IOCTLs: synchronous and asynchronous. Asynchronous IOCTLs require an additional completion poll step which is explained in <a class="el" href="enet_ioctl_interface.html#enet_async_ioctl">Synchronous and Asynchronous IOCTLs</a> section of the <a class="el" href="enet_ioctl_interface.html">Enet LLD IOCTL interface</a> document.</li>
</ol>
<h2><a class="anchor" id="enet_closeport_sequence"></a>
Port Close Sequence</h2>
<ol type="1">
<li>MAC ports that were opened earlier can be closed using <a class="el" href="enet__per_8h.html#a5e37e31ddf40acdd06e84bbf2cf413c0a5623c658415329096180ce45405d6bb7">ENET_PER_IOCTL_CLOSE_PORT_LINK</a> IOCTL command. This will close the PHY state machine associated with this MAC port, if the port was not open in MAC-to-MAC mode. Application can choose to reopen the port at any time in the future by following the steps listed in <a class="el" href="enet_integration_guide_top.html#enet_openport_sequence">Port Open Sequence</a> section.</li>
</ol>
<h2><a class="anchor" id="enet_close_sequence"></a>
Peripheral Close Sequence</h2>
<ol type="1">
<li>Disable the host port using the <a class="el" href="group__ENET__MOD__HOSTPORT.html#gga65ee5012f8178049e634eb8b7e42959ca5486889880b7cc712968b080456dfea8">ENET_HOSTPORT_IOCTL_DISABLE</a> command</li>
<li>Close the opened Tx Channel and Rx flow:<ul>
<li>Close the Rx flow using EnetAppUtils_closeRxFlow().</li>
<li>Close the Tx Channel using EnetAppUtils_closeTxCh().</li>
</ul>
</li>
<li>Detach the core from Resource Manager using the <a class="el" href="enet__per_8h.html#a5e37e31ddf40acdd06e84bbf2cf413c0a749823fad2726b94bde3a5adfe3c7e16">ENET_PER_IOCTL_DETACH_CORE</a> command.</li>
<li>Enet driver can now be closed and de-initialized using <a class="el" href="group__ENET__MAIN__API.html#ga4710f1318cbf2089a92a50609a403c39">Enet_close()</a> and <a class="el" href="group__ENET__MAIN__API.html#gac2f30f7b3277c9ffa89018d226fa8985">Enet_deinit()</a>.</li>
</ol>
<h2><a class="anchor" id="enet_deinit_sequence"></a>
Deinit Sequence</h2>
<p>This is one-time deinitialization sequence that must be followed when the application no longer wants to use the Enet LLD.</p>
<ol type="1">
<li><a class="el" href="group__ENET__MAIN__API.html#gac2f30f7b3277c9ffa89018d226fa8985">Enet_deinit()</a> should be called to deinitialize the driver. No further Enet LLD APIs should be called from this point.</li>
<li>Finally, close the UDMA driver using EnetAppUtils_udmaclose()</li>
</ol>
<p><a class="el" href="enet_integration_guide_top.html">Back To Top</a></p>
<h2><a class="anchor" id="enetper_specific_handling"></a>
Peripheral-specific</h2>
<hr/>
<h3><a class="anchor" id="enetper_icssg_dmac_specific_handling"></a>
ICSSG Dual-MAC</h3>
<p>The following sections discuss lower level details on how the ICSSG Dual-MAC and its buffer pool configuration parameters are passed. This is relevant for readers who are looking to replace the default Dual-MAC firmware or have packet buffer requirements not met with the default buffer pool configuration.</p>
<h4><a class="anchor" id="enetper_icssg_dmac_fw_specific_handling"></a>
Firmware</h4>
<p>Enet LLD provides default firmware for ICSSG Dual-MAC, which is available at <code>&lt;enet&gt;/src/per/firmware/icssg/dualmac</code>. This firmware is tightly coupled with a corresponding firmware initialization done internally in Enet LLD.</p>
<p>The firmware information is populated into the ICSSG internal objects (see <a class="el" href="structIcssg__Obj.html#a59af2c083f604bc0256bc00eaab0ed39">Icssg_Obj::fw</a>) by Enet LLD in the corresponding Enet SoC file, i.e. <code>&lt;enet&gt;/soc/j7x/am65xx/enet_soc.c</code> for AM65xx devices.</p>
<p>There are three firmware blobs that must be loaded, one per core in the ICSSG <em>slice</em>: PRU, RTU and TX PRU. It's done as follows:</p>
<table class="doxtable">
<tr>
<th>Peripheral </th><th>PRU </th><th>RTU </th><th>TX PRU </th></tr>
<tr>
<td>ICSSG0 MAC port 1<br />
 (enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a>, instId: 0) </td><td>RX_PRU_SLICE0_b00_DMac </td><td>RTU0_SLICE0_b00_DMac </td><td>TX_PRU_SLICE0_b00_DMac </td></tr>
<tr>
<td>ICSSG0 MAC port 2<br />
 (enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a>, instId: 1) </td><td>RX_PRU_SLICE1_b00_DMac </td><td>RTU0_SLICE1_b00_DMac </td><td>TX_PRU_SLICE1_b00_DMac </td></tr>
<tr>
<td>ICSSG1 MAC port 1<br />
 (enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a>, instId: 2) </td><td>RX_PRU_SLICE0_b00_DMac </td><td>RTU0_SLICE0_b00_DMac </td><td>TX_PRU_SLICE0_b00_DMac </td></tr>
<tr>
<td>ICSSG1 MAC port 2<br />
 (enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a>, instId: 3) </td><td>RX_PRU_SLICE1_b00_DMac </td><td>RTU0_SLICE1_b00_DMac </td><td>TX_PRU_SLICE1_b00_DMac </td></tr>
<tr>
<td>ICSSG2 MAC port 1<br />
 (enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a>, instId: 4) </td><td>RX_PRU_SLICE0_b00_DMac </td><td>RTU0_SLICE0_b00_DMac </td><td>TX_PRU_SLICE0_b00_DMac </td></tr>
<tr>
<td>ICSSG2 MAC port 2<br />
 (enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a>, instId: 5) </td><td>RX_PRU_SLICE1_b00_DMac </td><td>RTU0_SLICE1_b00_DMac </td><td>TX_PRU_SLICE1_b00_DMac </td></tr>
</table>
<p>It's worth noting that from application perspective, the ICSSG firmware blobs to be loaded and the firmware configuration is completely transparent as it doesn't require any application intervention.</p>
<h4><a class="anchor" id="enetper_icssg_dmac_fwmem_specific_handling"></a>
Firmware Memory Pools</h4>
<p>ICSSG firmware requires internal memory for buffer pools and queues to be specified at firmware configuration time. This firmware memory is passed into the ICSSG internal objects (see <a class="el" href="structIcssg__Obj.html#abffe020a63c452b34a0a553638091a76">Icssg_Obj::fwPoolMem</a>) by Enet LLD in the corresponding Enet SoC file, i.e. <code>&lt;enet&gt;/soc/j7x/am65xx/enet_soc.c</code> for AM65xx devices.</p>
<p>There are certain memory requirements for each buffer type for Dual-MAC as shown below:</p>
<table class="doxtable">
<tr>
<th>Buffer Type </th><th>Number of pools per slice </th><th>Size per buffer pool (bytes) </th><th>Config parameters </th></tr>
<tr>
<td>Port buffer pools </td><td>0 </td><td>0 </td><td><a class="el" href="structIcssg__FwPoolMem.html#a087a6eae0f3895357096961767db81b3">Icssg_FwPoolMem::portBufferPoolMem</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#aa11e0a0624d22e1b61560012f3d4f8b7">Icssg_FwPoolMem::portBufferPoolSize</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#aba41ffd1cea434a0143b3a9e77bc3eea">Icssg_FwPoolMem::portBufferPoolNum</a> <br />
</td></tr>
<tr>
<td>Host buffer pools </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#ga7690c841169e97d07e183dd1055f0e15" title="Number of host buffer pools required for Dual-MAC.">ICSSG_DUALMAC_HOST_BUFFER_POOL_NUM</a> </td><td>Configurable </td><td><a class="el" href="structIcssg__FwPoolMem.html#ac6689dc78eb494eb839eceeeca123985">Icssg_FwPoolMem::hostBufferPoolMem</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#a21000f5a7c74f034c9c19124b3e2b958">Icssg_FwPoolMem::hostBufferPoolSize</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#a26f973d95307a417d06cd3aa6d2840f0">Icssg_FwPoolMem::hostBufferPoolNum</a> <br />
</td></tr>
<tr>
<td>Host egress queues </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#ga413c282f2e2c2791e1cc9cfddc35ccbf" title="Number of host egress queues required for Dual-MAC.">ICSSG_DUALMAC_HOST_EGRESS_QUEUE_NUM</a> </td><td>Configurable. It must include fixed padding size<br />
 of <a class="el" href="group__DRV__ENET__ICSSG.html#ga31aedbca8742c31695719cf145a33eff" title="Host egress queue padding size.">ICSSG_HOST_EGRESS_BUFFER_PADDING</a> </td><td><a class="el" href="structIcssg__FwPoolMem.html#a00d7086305930a5ad7f2c83dcbb49c43">Icssg_FwPoolMem::hostEgressQueueMem</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#a1b08462c5e23abcf2d61ff15cb8cd710">Icssg_FwPoolMem::hostEgressQueueSize</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#a541f55cad93736ab8e005ef97bba0709">Icssg_FwPoolMem::hostEgressQueueNum</a> <br />
</td></tr>
<tr>
<td>Scratch buffer </td><td>1 </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#ga40f9343b5d3140b1dd32bdd0e2f593e7" title="Size of the scratch buffer used for error frames and large frames.">ICSSG_SCRATCH_BUFFER_SIZE</a> </td><td><a class="el" href="structIcssg__FwPoolMem.html#afd6f6ceb7b34a83392c2771568178d64">Icssg_FwPoolMem::scratchBufferMem</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#a59d19a2bb32658f5eb0f2ea3f3ad461c">Icssg_FwPoolMem::scratchBufferSize</a> <br />
</td></tr>
</table>
<p>Enet LLD provides a default firmware memory configuration in order to reduce the configuration burden on applications. The selection of firmware buffer sizes is a trade-off between the desired amount of packet buffering, the available memory and ICSSG MAC concurrency.</p>
<p>The buffer sizes provided by default in Enet LLD enable simultaneous use of all ICSSGs MACs in the SoC. The table below shows the default buffer sizes per ICSSG MAC.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Buffer Type  </th><th class="markdownTableHeadCenter">Number of pools  </th><th class="markdownTableHeadCenter">Buffer pool size  </th><th class="markdownTableHeadCenter">Slices  </th><th class="markdownTableHeadCenter">Total size   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Port buffer pools  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">0   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Host buffer pools  </td><td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">8 kB  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">64 kB   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Host egress queues  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">8 kB  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">16 kB   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Scratch buffer  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">2 kB  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">2 kB   </td></tr>
</table>
<p>If these firmware memory sizes don't meet the requirements of the application, they must be changed in the corresponding Enet SoC file, i.e. <code>&lt;enet&gt;/soc/j7x/am65xx/enet_soc.c</code> for AM65xx devices.</p>
<h3><a class="anchor" id="enetper_icssg_swt_specific_handling"></a>
ICSSG Switch</h3>
<p>The following sections discuss lower level details on how the ICSSG Switch and its buffer pool configuration parameters are passed. This is relevant for readers who are looking to replace the default Switch firmware or have packet buffer requirements not met with the default buffer pool configuration.</p>
<h4><a class="anchor" id="enetper_icssg_swt_fw_specific_handling"></a>
Firmware</h4>
<p>Enet LLD provides default firmware for ICSSG Switch which is available at <code>&lt;enet&gt;/src/per/firmware/icssg/switch</code>. This firmware is tightly coupled with a corresponding firmware initialization done internally in Enet LLD.</p>
<p>The firmware information is populated into the ICSSG internal objects (see <a class="el" href="structIcssg__Obj.html#a59af2c083f604bc0256bc00eaab0ed39">Icssg_Obj::fw</a>) by Enet LLD in the corresponding Enet SoC file, i.e. <code>&lt;enet&gt;/soc/j7x/am65xx/enet_soc.c</code> for AM65xx devices.</p>
<p>There are six firmware blobs that must be supplied by the application, one for each core of the two ICSSG <em>slices</em>: PRU, RTU and TX PRU.</p>
<table class="doxtable">
<tr>
<th>Peripheral </th><th>PRU </th><th>RTU </th><th>TX PRU </th></tr>
<tr>
<td>ICSSG0<br />
 (enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1c2fa2e7679fefc3f252649d57b8b750">ENET_ICSSG_SWITCH</a>, instId: 0) </td><td>RX_PRU_SLICE0_b00_Swt<br />
 RX_PRU_SLICE1_b00_Swt </td><td>RTU0_SLICE0_b00_Swt<br />
 RTU0_SLICE1_b00_Swt </td><td>TX_PRU_SLICE0_b00_Swt<br />
 TX_PRU_SLICE1_b00_Swt </td></tr>
<tr>
<td>ICSSG1<br />
 (enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1c2fa2e7679fefc3f252649d57b8b750">ENET_ICSSG_SWITCH</a>, instId: 1) </td><td>RX_PRU_SLICE0_b00_Swt<br />
 RX_PRU_SLICE1_b00_Swt </td><td>RTU0_SLICE0_b00_Swt<br />
 RTU0_SLICE1_b00_Swt </td><td>TX_PRU_SLICE0_b00_Swt<br />
 TX_PRU_SLICE1_b00_Swt </td></tr>
<tr>
<td>ICSSG2<br />
 (enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1c2fa2e7679fefc3f252649d57b8b750">ENET_ICSSG_SWITCH</a>, instId: 2) </td><td>RX_PRU_SLICE0_b00_Swt<br />
 RX_PRU_SLICE1_b00_Swt </td><td>RTU0_SLICE0_b00_Swt<br />
 RTU0_SLICE1_b00_Swt </td><td>TX_PRU_SLICE0_b00_Swt<br />
 TX_PRU_SLICE1_b00_Swt </td></tr>
</table>
<h4><a class="anchor" id="enetper_icssg_swt_fwmem_specific_handling"></a>
Firmware Memory Pools</h4>
<p>ICSSG firmware requires internal memory for buffer pools and queues to be specified at firmware configuration time. This firmware memory is passed into the ICSSG internal objects (see <a class="el" href="structIcssg__Obj.html#abffe020a63c452b34a0a553638091a76">Icssg_Obj::fwPoolMem</a>) by Enet LLD in the corresponding Enet SoC file, i.e. <code>&lt;enet&gt;/soc/j7x/am65xx/enet_soc.c</code> for AM65xx devices.</p>
<p>There are certain memory requirements for each buffer type for Switch as shown below:</p>
<table class="doxtable">
<tr>
<th>Buffer Type </th><th>Number of pools per slice </th><th>Size per buffer pool (bytes) </th><th>Config parameters </th></tr>
<tr>
<td>Port buffer pools </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gad99b2290cf29654a9f087396f768490c" title="Number of port buffer pools required for Dual-MAC.">ICSSG_SWITCH_PORT_BUFFER_POOL_NUM</a> </td><td>Configurable </td><td><a class="el" href="structIcssg__FwPoolMem.html#a087a6eae0f3895357096961767db81b3">Icssg_FwPoolMem::portBufferPoolMem</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#aa11e0a0624d22e1b61560012f3d4f8b7">Icssg_FwPoolMem::portBufferPoolSize</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#aba41ffd1cea434a0143b3a9e77bc3eea">Icssg_FwPoolMem::portBufferPoolNum</a> <br />
</td></tr>
<tr>
<td>Host buffer pools </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#ga931d9f0759c76e724749b650709dd551" title="Number of host buffer pools required for Dual-MAC.">ICSSG_SWITCH_HOST_BUFFER_POOL_NUM</a> </td><td>Configurable </td><td><a class="el" href="structIcssg__FwPoolMem.html#ac6689dc78eb494eb839eceeeca123985">Icssg_FwPoolMem::hostBufferPoolMem</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#a21000f5a7c74f034c9c19124b3e2b958">Icssg_FwPoolMem::hostBufferPoolSize</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#a26f973d95307a417d06cd3aa6d2840f0">Icssg_FwPoolMem::hostBufferPoolNum</a> <br />
</td></tr>
<tr>
<td>Host egress queues </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#ga90453530c4b09a8eeb91aa205cd6207f" title="Number of host egress queues required for Dual-MAC.">ICSSG_SWITCH_HOST_EGRESS_QUEUE_NUM</a> </td><td>Configurable. It must include fixed padding size<br />
 of <a class="el" href="group__DRV__ENET__ICSSG.html#ga31aedbca8742c31695719cf145a33eff" title="Host egress queue padding size.">ICSSG_HOST_EGRESS_BUFFER_PADDING</a> </td><td><a class="el" href="structIcssg__FwPoolMem.html#a00d7086305930a5ad7f2c83dcbb49c43">Icssg_FwPoolMem::hostEgressQueueMem</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#a1b08462c5e23abcf2d61ff15cb8cd710">Icssg_FwPoolMem::hostEgressQueueSize</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#a541f55cad93736ab8e005ef97bba0709">Icssg_FwPoolMem::hostEgressQueueNum</a> <br />
</td></tr>
<tr>
<td>Scratch buffer </td><td>1 </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#ga40f9343b5d3140b1dd32bdd0e2f593e7" title="Size of the scratch buffer used for error frames and large frames.">ICSSG_SCRATCH_BUFFER_SIZE</a> </td><td><a class="el" href="structIcssg__FwPoolMem.html#afd6f6ceb7b34a83392c2771568178d64">Icssg_FwPoolMem::scratchBufferMem</a> <br />
 <a class="el" href="structIcssg__FwPoolMem.html#a59d19a2bb32658f5eb0f2ea3f3ad461c">Icssg_FwPoolMem::scratchBufferSize</a> <br />
</td></tr>
</table>
<p>Enet LLD provides a default firmware memory configuration in order to reduce the configuration burden on applications. The selection of firmware buffer sizes is a trade-off between the desired amount of packet buffering, the available memory and ICSSG Switch concurrency.</p>
<p>The buffer sizes provided by default in Enet LLD enable simultaneous use of all ICSSGs Switches in the SoC. The table below shows the default buffer sizes per ICSSG MAC.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Buffer Type  </th><th class="markdownTableHeadCenter">Number of pools  </th><th class="markdownTableHeadCenter">Buffer pool size  </th><th class="markdownTableHeadCenter">Slices  </th><th class="markdownTableHeadCenter">Total size   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Port buffer pools  </td><td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">6 kB  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">96 kB   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Host buffer pools  </td><td class="markdownTableBodyCenter">16  </td><td class="markdownTableBodyCenter">6 kB  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">192 kB   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Host egress queues  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">8 kB  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">32 kB   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Scratch buffer  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">2 kB  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">4 kB   </td></tr>
</table>
<p>If these firmware memory sizes don't meet the requirements of the application, they must be changed in the corresponding Enet SoC file, i.e. <code>&lt;enet&gt;/soc/j7x/am65xx/enet_soc.c</code> for AM65xx devices.</p>
<h1><a class="anchor" id="emac_lld_migration"></a>
Migrating from EMAC LLD</h1>
<hr/>
<h2><a class="anchor" id="emac_lld_migration_icssg"></a>
ICSSG Migration</h2>
<h3><a class="anchor" id="emac_lld_migration_icssg_per_open"></a>
Peripheral open</h3>
<p>EMAC LLD and Enet LLD differ in the kind of parameters passed at open time. EMAC LLD's <code>emac_open()</code> takes a port number, and Enet LLD's <a class="el" href="group__ENET__MAIN__API.html#ga40325ec5d06d5d7788ec71609edd7ac0">Enet_open()</a> takes a peripheral type and instance id.</p>
<p>Dual-MAC is implemented as separate Enet peripherals of the same type (<a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a>). Instance number goes from 0 to 5 for AM65xx device as there are a total of 3 ICSSG instances, each having 2 MAC ports.</p>
<p>The following tables show the equivalent parameters to use in <a class="el" href="group__ENET__MAIN__API.html#ga40325ec5d06d5d7788ec71609edd7ac0">Enet_open()</a> for ICSSG Dual-MAC.</p>
<table class="doxtable">
<tr>
<th>EMAC LLD<br />
 Port Number </th><th>Enet LLD<br />
 Peripheral </th></tr>
<tr>
<td>EMAC_ICSSG0_PORT0 </td><td>enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a> instId: 0 </td></tr>
<tr>
<td>EMAC_ICSSG0_PORT1 </td><td>enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a> instId: 1 </td></tr>
<tr>
<td>EMAC_ICSSG1_PORT0 </td><td>enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a> instId: 2 </td></tr>
<tr>
<td>EMAC_ICSSG1_PORT1 </td><td>enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a> instId: 3 </td></tr>
<tr>
<td>EMAC_ICSSG2_PORT0 </td><td>enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a> instId: 4 </td></tr>
<tr>
<td>EMAC_ICSSG2_PORT1 </td><td>enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1f88b6d4ca6bfff49e0816ba462527ae">ENET_ICSSG_DUALMAC</a> instId: 5 </td></tr>
</table>
<p>ICSSG Switch is implemented as separate Enet peripherals of the same type (<a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1c2fa2e7679fefc3f252649d57b8b750">ENET_ICSSG_SWITCH</a>). Instance number goes from 0 to 3 for AM65xx device as there are a total of 3 ICSSG instances.</p>
<p>The following tables show the equivalent parameters to use in <a class="el" href="group__ENET__MAIN__API.html#ga40325ec5d06d5d7788ec71609edd7ac0">Enet_open()</a> for ICSSG Switch.</p>
<table class="doxtable">
<tr>
<th>EMAC LLD<br />
 Port Number </th><th>Enet LLD<br />
 Peripheral </th></tr>
<tr>
<td>EMAC_SWITCH_PORT </td><td>enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1c2fa2e7679fefc3f252649d57b8b750">ENET_ICSSG_SWITCH</a> instId: 0 </td></tr>
<tr>
<td>EMAC_ICSSG0_SWITCH_PORT </td><td>enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1c2fa2e7679fefc3f252649d57b8b750">ENET_ICSSG_SWITCH</a> instId: 0 </td></tr>
<tr>
<td>EMAC_ICSSG1_SWITCH_PORT </td><td>enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1c2fa2e7679fefc3f252649d57b8b750">ENET_ICSSG_SWITCH</a> instId: 1 </td></tr>
<tr>
<td>EMAC_ICSSG2_SWITCH_PORT </td><td>enetType: <a class="el" href="group__ENET__MAIN__API.html#ggaaccaa1593a07b1228ca35c6e6aefbf0fa1c2fa2e7679fefc3f252649d57b8b750">ENET_ICSSG_SWITCH</a> instId: 2 </td></tr>
</table>
<p>Enet LLD <a class="el" href="group__ENET__MAIN__API.html#ga40325ec5d06d5d7788ec71609edd7ac0">Enet_open()</a> returns a handle of <a class="el" href="enet__base_8h.html#aaf6a26638306b81ac1148da6da42f513">Enet_Handle</a> type, this handle is used in all other Enet LLD APIs. This is an important difference with respect to EMAC LLD, as port number is still required in other EMAC LLD APIs, i.e. <code>emac_ioctl</code>.</p>
<h3><a class="anchor" id="emac_lld_migration_icssg_ioctl"></a>
IOCTLs</h3>
<p>EMAC LLD's <code>emac_ioctl()</code> uses a port number as a means to indicate whether the command is to be run on a Dual-MAC or a Switch, and also to convey information about whether the command is MAC port or host port related:</p>
<ul>
<li>Dual-MAC - It's the same port number used at open time in <code>emac_open()</code>. There is no additional port number for host port IOCTL commands.</li>
<li>Switch - There are 4 port numbers per instance:<ul>
<li><code>EMAC_ICSSGn_SWITCH_PORT</code> used for global settings.</li>
<li><code>EMAC_ICSSGn_SWITCH_PORT0</code> used for host port related IOCTLs.</li>
<li><code>EMAC_ICSSGn_SWITCH_PORT1</code> used for MAC port 1 related IOCTLs.</li>
<li><code>EMAC_ICSSGn_SWITCH_PORT2</code> used for MAC port 2 related IOCTLs.</li>
</ul>
</li>
</ul>
<p>Note that in the Switch case, the last three port numbers are not used at open time.</p>
<p>In Enet LLD, <a class="el" href="group__ENET__MAIN__API.html#gaf48cc1d13141375e4a404d3078785bce">Enet_ioctl()</a> doesn't take the port number in all cases, but only for MAC port related IOCTL commands.</p>
<p>IOCTLs that are MAC port related will take the MAC port number (<a class="el" href="group__ENET__MAIN__API.html#ga263f2a3003e793a56d3def727e2b6a4f">Enet_MacPort</a>) as IOCTL input args. For example, <a class="el" href="group__ENET__MOD__MACPORT.html#ggaae019ccdc5a774caa8ffdb35123ca59da07a66f83086b012ff7e4dffaaf2c252e">ENET_MACPORT_IOCTL_SET_PRI_REGEN_MAP</a> command is MAC port related and it takes the MAC port number in its input arguments <a class="el" href="structEnetMacPort__SetPriorityRegenMapInArgs.html#ad0199e6e73b37d0279b9fdc3276fbe66">EnetMacPort_SetPriorityRegenMapInArgs::macPort</a>.</p>
<p>IOCTLs that are host port related will not take a port number. For example, <a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba284a628b2cc410d41eeb5dd13f62d7a8">ICSSG_PER_IOCTL_VLAN_SET_HOSTPORT_DFLT_VID</a>.</p>
<h4><a class="anchor" id="emac_lld_migration_icssg_async_ioctl"></a>
Asynchronous IOCTLs</h4>
<p>In EMAC LLD, asynchronous IOCTLs return <code>EMAC_DRV_RESULT_IOCTL_IN_PROGRESS</code> in <code>emac_ioctl()</code> call which is used to indicate that the application must poll for the operation completion. Polling is done via <code>emac_poll_ctrl()</code> function.</p>
<p>Enet LLD implements asynchronous IOCTLs using a similar mechanism. First, the application must register an IOCTL completion callback funcion via <a class="el" href="group__ENET__MAIN__API.html#gaf2845eb8de556d2b9b21f0a4762ad86d">Enet_registerEventCb()</a>. When application has called an asynchronous IOCTL, Enet LLD will return <a class="el" href="group__ENET__MAIN__API.html#ga170e83bb7ae665de757906354caff5f0">ENET_SINPROGRESS</a> and the application must call <a class="el" href="group__ENET__MAIN__API.html#ga6394f7b1160a819195c02c646952b10e">Enet_poll()</a> with event type <a class="el" href="group__ENET__MAIN__API.html#gga40859f551befdba0d34a90a869b7a5aaa2f797964ef75e495c7fb39c956011ef2">ENET_EVT_ASYNC_CMD_RESP</a> until the registered callback is called.</p>
<p>Refer to section <a class="el" href="enet_ioctl_interface.html#enet_async_ioctl">Synchronous and Asynchronous IOCTLs</a> of the <a class="el" href="enet_ioctl_interface.html">Enet LLD IOCTL interface</a> document for further details.</p>
<h4><a class="anchor" id="emac_lld_migration_icssg_ioctl_mappings"></a>
IOCTL Command Mappings</h4>
<p>The following table shows the mapping between EMAC LLD IOCTL commands/subcommands and Enet LLD IOCTLs.</p>
<table class="doxtable">
<tr>
<th>EMAC LLD<br />
 IOCTL cmd </th><th>EMAC LLD<br />
 IOCTL subcmd </th><th>Enet LLD<br />
 IOCTL cmd </th></tr>
<tr>
<td><code>EMAC_IOCTL_PROMISCOUS_MODE_CTRL</code> </td><td></td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba288c3bea795996bb52af47f54880f6de">ICSSG_MACPORT_IOCTL_ENABLE_PROMISC_MODE</a> <br />
 <a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba50729b31876bcbfbcf1c3426797e97ad">ICSSG_MACPORT_IOCTL_DISABLE_PROMISC_MODE</a> </td></tr>
<tr>
<td rowspan="2"><code>EMAC_IOCTL_UC_FLOODING_CTRL</code> </td><td><code>EMAC_IOCTL_PORT_UC_FLOODING_ENABLE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba4146aef65afd5be524e53b5e43e40e8a">ICSSG_MACPORT_IOCTL_ENABLE_UCAST_FLOOD</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PORT_UC_FLOODING_DISABLE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbae00da6d76a91f2f3198b844e107536e4">ICSSG_MACPORT_IOCTL_DISABLE_UCAST_FLOOD</a> </td></tr>
<tr>
<td rowspan="2"><code>EMAC_IOCTL_MC_FLOODING_CTRL</code> </td><td><code>EMAC_IOCTL_PORT_MC_FLOODING_ENABLE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba1d4a2c7995ae5f2f410f28289722a7d6">ICSSG_MACPORT_IOCTL_ENABLE_MCAST_FLOOD</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PORT_MC_FLOODING_DISABLE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba83c82f831dc565d907bf9a4c7bf19d06">ICSSG_MACPORT_IOCTL_DISABLE_MCAST_FLOOD</a> </td></tr>
<tr>
<td rowspan="4"><code>EMAC_IOCTL_PORT_STATE_CTRL</code> </td><td><code>EMAC_IOCTL_PORT_STATE_DISABLE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbae4452faf865471e87b9091577fd54d0f">ICSSG_PER_IOCTL_SET_PORT_STATE</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PORT_STATE_BLOCKING</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbae4452faf865471e87b9091577fd54d0f">ICSSG_PER_IOCTL_SET_PORT_STATE</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PORT_STATE_FORWARD</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbae4452faf865471e87b9091577fd54d0f">ICSSG_PER_IOCTL_SET_PORT_STATE</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PORT_STATE_FORWARD_WO_LEARNING</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbae4452faf865471e87b9091577fd54d0f">ICSSG_PER_IOCTL_SET_PORT_STATE</a> </td></tr>
<tr>
<td rowspan="3"><code>EMAC_IOCTL_ACCEPTABLE_FRAME_CHECK_CTRL</code> </td><td><code>EMAC_IOCTL_ACCEPTABLE_FRAME_CHECK_ONLY_VLAN_TAGGED</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbad470f00e6f2c33184e34403ab71be811">ICSSG_MACPORT_IOCTL_SET_ACCEPT_FRAME_CHECK</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_ACCEPTABLE_FRAME_CHECK_ONLY_UN_TAGGED_PRIO_TAGGED</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbad470f00e6f2c33184e34403ab71be811">ICSSG_MACPORT_IOCTL_SET_ACCEPT_FRAME_CHECK</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_ACCEPTABLE_FRAME_CHECK_ALL_FRAMES</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbad470f00e6f2c33184e34403ab71be811">ICSSG_MACPORT_IOCTL_SET_ACCEPT_FRAME_CHECK</a> </td></tr>
<tr>
<td rowspan="4"><code>EMAC_IOCTL_VLAN_CTRL</code> </td><td><code>EMAC_IOCTL_VLAN_SET_DEFAULT_TBL</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbac04ef404da9f52a316e28504b1bb6767">ICSSG_PER_IOCTL_VLAN_RESET_TABLE</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_VLAN_SET_ENTRY</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbaea749baea1b03268eae19af4fdd10421">ICSSG_PER_IOCTL_VLAN_SET_ENTRY</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_VLAN_SET_DEFAULT_VLAN_ID</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba284a628b2cc410d41eeb5dd13f62d7a8">ICSSG_PER_IOCTL_VLAN_SET_HOSTPORT_DFLT_VID</a> <br />
 <a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba17b4d0f1b7fe8cee6f6647da68a65c45">ICSSG_PER_IOCTL_VLAN_SET_MACPORT_DFLT_VID</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_VLAN_GET_ENTRY</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba754276a296087a711e69785de957fc52">ICSSG_PER_IOCTL_VLAN_GET_ENTRY</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PORT_PRIO_MAPPING_CTRL</code> </td><td></td><td><a class="el" href="group__ENET__MOD__MACPORT.html#ggaae019ccdc5a774caa8ffdb35123ca59da65396bbc765bff613f976209be4d1bc7">ENET_MACPORT_IOCTL_SET_EGRESS_QOS_PRI_MAP</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PRIO_REGEN_CTRL</code> </td><td></td><td><a class="el" href="group__ENET__MOD__MACPORT.html#ggaae019ccdc5a774caa8ffdb35123ca59da07a66f83086b012ff7e4dffaaf2c252e">ENET_MACPORT_IOCTL_SET_PRI_REGEN_MAP</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_SPECIAL_FRAME_PRIO_CONFIG</code> </td><td></td><td><a class="el" href="structIcssgMacPort__Cfg.html#a4a90feb1e2f2678c36e43b4ebb9d13d5">IcssgMacPort_Cfg::specialFramePrio</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_FDB_AGEING_TIMEOUT_CTRL</code> </td><td></td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbaccd484618429dd54712b8a25248bdc1b">ICSSG_FDB_IOCTL_SET_AGING_PERIOD</a> </td></tr>
<tr>
<td rowspan="4"><code>EMAC_IOCTL_FDB_ENTRY_CTRL</code> </td><td><code>EMAC_IOCTL_FDB_ENTRY_ADD</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbaf872f28fc60ce1535a4bec36ae46b449">ICSSG_FDB_IOCTL_ADD_ENTRY</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_FDB_ENTRY_DELETE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba0985df4bc41c5984323dab6b5141caf8">ICSSG_FDB_IOCTL_REMOVE_ENTRY</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_FDB_ENTRY_DELETE_ALL</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbae49dc6cb2e61eb18cd81364e78785697">ICSSG_FDB_IOCTL_REMOVE_ALL_ENTRIES</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_FDB_ENTRY_DELETE_ALL_AGEABLE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba4f184ecbed574f8433f4c825b51e48e5">ICSSG_FDB_IOCTL_REMOVE_AGEABLE_ENTRIES</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_INTERFACE_MAC_CONFIG</code> </td><td><code>EMAC_IOCTL_INTERFACE_MAC_ADD</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbada50daff2a76b2cad0254563e2269a31">ICSSG_HOSTPORT_IOCTL_SET_MACADDR</a> <br />
 <a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba14de9c5947c8ae30ca79de275b391046">ICSSG_MACPORT_IOCTL_SET_MACADDR</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_INGRESS_RATE_LIMIT_CTRL</code> </td><td></td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba2f2c5c7c0c3c75c79a86eb73c652d774">ICSSG_MACPORT_IOCTL_SET_INGRESS_RATE_LIM</a> </td></tr>
<tr>
<td rowspan="9"><code>EMAC_IOCTL_FRAME_PREEMPTION_CTRL</code> </td><td><code>EMAC_IOCTL_PREEMPT_TX_ENABLE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbafc90abe8dd0c75c051d526247c825ee2">ICSSG_MACPORT_IOCTL_PREEMPT_TX_ENABLE</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PREEMPT_TX_DISABLE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbaa81d5b003df5a7484ebcd6955f1e8dc7">ICSSG_MACPORT_IOCTL_PREEMPT_TX_DISABLE</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PREEMPT_GET_TX_ENABLE_STATUS</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba2953838a28476d77e12b7b62c75e85ab">ICSSG_MACPORT_IOCTL_PREEMPT_GET_TX_ENABLE_STATUS</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PREEMPT_GET_TX_ACTIVE_STATUS</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbaf1a89cadb1640b22f913098330b02416">ICSSG_MACPORT_IOCTL_PREEMPT_GET_TX_ACTIVE_STATUS</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PREEMPT_VERIFY_ENABLE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba1d0a3c7e605486987843196a7e1753dd">ICSSG_MACPORT_IOCTL_PREEMPT_VERIFY_ENABLE</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PREEMPT_VERIFY_DISABLE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba42d7c2140fbd0a19d7de09624d22a0fe">ICSSG_MACPORT_IOCTL_PREEMPT_VERIFY_DISABLE</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PREEMPT_GET_VERIFY_STATE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba3206bfd30d93c710bbc8cf89728633a8">ICSSG_MACPORT_IOCTL_PREEMPT_GET_VERIFY_STATE</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PREEMPT_GET_MIN_FRAG_SIZE_LOCAL</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bba92c287d7bd4a141a24e515245abec1ec">ICSSG_MACPORT_IOCTL_PREEMPT_GET_MIN_FRAG_SIZE_LOCAL</a> </td></tr>
<tr>
<td><code>EMAC_IOCTL_PREEMPT_SET_MIN_FRAG_SIZE_REMOTE</code> </td><td><a class="el" href="group__DRV__ENET__ICSSG.html#gga2e2b170ba4c7c2f45b86da4bc27898bbacb34c5ff1655034e4bd4a7fd989b66b7">ICSSG_MACPORT_IOCTL_PREEMPT_SET_MIN_FRAG_SIZE_REMOTE</a> </td><td></td></tr>
<tr>
<td><code>EMAC_IOCTL_CUT_THROUGH_PREEMPT_SELECT</code> </td><td></td><td><a class="el" href="structIcssgMacPort__Cfg.html#afed155097f2c55785f5493d094563871">IcssgMacPort_Cfg::queuePreemptMode</a> <br />
 <a class="el" href="structIcssgMacPort__Cfg.html#a7b4e2ac5d82af67b65296d22b8e00154">IcssgMacPort_Cfg::queueForwardMode</a> </td></tr>
<tr>
<td rowspan="6"><code>EMAC_IOCTL_SPEED_DUPLEXITY_CTRL</code> </td><td><code>EMAC_IOCTL_SPEED_DUPLEXITY_10HD</code> </td><td rowspan="6">No longer available as explicit IOCTLs.<br />
 Speed and duplexity are passed as arguments to <a class="el" href="enet__per_8h.html#a5e37e31ddf40acdd06e84bbf2cf413c0ad5684ee47181741d4c11d9de6bd5fbe1">ENET_PER_IOCTL_OPEN_PORT_LINK</a> in either auto-negotiation or manual modes. </td></tr>
<tr>
<td><code>EMAC_IOCTL_SPEED_DUPLEXITY_10FD</code> </td></tr>
<tr>
<td><code>EMAC_IOCTL_SPEED_DUPLEXITY_100HD</code> </td></tr>
<tr>
<td><code>EMAC_IOCTL_SPEED_DUPLEXITY_100FD</code> </td></tr>
<tr>
<td><code>EMAC_IOCTL_SPEED_DUPLEXITY_GIGABIT</code> </td></tr>
<tr>
<td><code>EMAC_IOCTL_SPEED_DUPLEXITY_DISABLE</code> </td></tr>
</table>
<h3><a class="anchor" id="emac_lld_migration_icssg_dma"></a>
Packet send and receive</h3>
<p>EMAC LLD relies on <code>emac_send()</code> and <code>emac_poll_pkt()</code> for packet transmission and reception, respectively.</p>
<ul>
<li>For transmission, application populates a descriptor with packet information and passes it to <code>emac_send()</code>. The descriptor provides fields for packet buffer, packet length, traffic class, etc.</li>
<li>For reception, application registers a callback (<code>rx_pkt_cb</code>) at open time, which will be called by the driver when application calls <code>emac_poll_pkt()</code> and packets have been received.</li>
</ul>
<p>Internally, EMAC LLD would open all required TX channels and RX flows.</p>
<p>Enet LLD takes a different approach, provides a queue oriented mechanism for packet submission and retrieval.</p>
<table class="doxtable">
<tr>
<th>Enet LLD API </th><th>Description </th></tr>
<tr>
<td><a class="el" href="group__ENET__DMA__API.html#ga818e945ac6f5d62b01186c9089673292">EnetDma_retrieveRxPktQ()</a> </td><td>Called by application to retrieve <em>ready</em> packets from the driver, that is, new full packets. </td></tr>
<tr>
<td><a class="el" href="group__ENET__DMA__API.html#ga6a80baccc431ce40d5d97a1f0d930252">EnetDma_submitRxPktQ()</a> </td><td>Callen by application to return <em>free</em> packets that the application has consumed and is ready to recycle. </td></tr>
<tr>
<td><a class="el" href="group__ENET__DMA__API.html#gac80790c3fbf88c40ce547c41c6164ae6">EnetDma_submitTxPktQ()</a> </td><td>Called by application to submit <em>ready</em> packets to the driver for transmission. </td></tr>
<tr>
<td><a class="el" href="group__ENET__DMA__API.html#ga0825a26fc168e6a68fa9948ac37125cc">EnetDma_retrieveTxPktQ()</a> </td><td>Called by application to retrieve <em>done</em> packets which the driver has already used for transmission and are ready to be reused for future transmission. </td></tr>
</table>
<p>The queues passed to above APIs are created by the application using EnetQueue APIs, such as <a class="el" href="group__ENET__QUEUE__API.html#gaa9f0bb4a386f1034211b565800f3efb9">EnetQueue_initQ()</a>, <a class="el" href="group__ENET__QUEUE__API.html#ga853be8d2d06ab2b6556b83a5bbdaf518">EnetQueue_enq()</a> and <a class="el" href="group__ENET__QUEUE__API.html#ga2defbccd8b3fb4946d7efa27aa388093">EnetQueue_deq()</a>.</p>
<p>The queues are composed of <a class="el" href="group__ENET__DMA__API.html#gaf81f0110fb07be7712a4a9e34c0fe438">EnetDma_Pkt</a> objects, which is the abstraction provided by Enet LLD for a packet. The native type of the packet object in AM65xx/J721E devices is <a class="el" href="structEnetUdma__PktInfo.html">EnetUdma_PktInfo</a>. Note that this same packet object type is used for transmission and reception.</p>
<p><a class="el" href="enet_integration_guide_top.html">Back To Top</a> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
