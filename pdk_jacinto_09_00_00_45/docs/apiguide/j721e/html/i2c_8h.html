<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>PDK API Guide for J721E: i2c.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PDK API Guide for J721E
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('i2c_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">i2c.h File Reference<div class="ingroups"><a class="el" href="group__CSL__IP__MODULE.html">CSL-FL</a> &raquo; <a class="el" href="group__CSL__I2C.html">I2C</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<div class="textblock"><p>This file contains the function prototypes for the device abstraction layer for high speed I2C. It also contains some related macro definitions and some files to be included. </p>
<p>Please find the below detailed description of i2c DAL.</p><ol type="1">
<li>I2C controller will basically operates in the following modes<ol type="a">
<li>Master Transmitter or Master Receiver.</li>
<li>Slave.</li>
</ol>
</li>
<li>Programming sequence for initializing the i2c controller in master mode.<ol type="a">
<li>Perform Clock and pinmux configuration.</li>
<li>Disable the module through API <a class="el" href="i2c_8h.html#a35404b9b05de91c3b12a84ac8189e82e" title="Disables the I2C Module.This will put the I2C module in reset. Only Tx and Rx are cleared,...">I2CMasterDisable</a>.</li>
<li>Disable the auto idle mode through API <a class="el" href="i2c_8h.html#a6a7d5497b01c296b454253f09947052e" title="This API disables auto idle mechanism.">I2CAutoIdleDisable</a></li>
<li>Configure the internal clock dividers of i2c controller through API <a class="el" href="i2c_8h.html#af7e47cad210fef11af7c6e3d99476345" title="This API will divide the system clock fed to I2C module between 12 and 100Mhz.It will also configure ...">I2CMasterInitExpClk</a></li>
<li>Configure the slave address through the API <a class="el" href="i2c_8h.html#a80081679b5fd41ed52a1d6bcd2963cb7" title="This API sets the address of the slave device with which I2C wants to communicate.">I2CMasterSlaveAddrSet</a></li>
<li>Enable the i2c module through API <a class="el" href="i2c_8h.html#ab7e4326f551e317e503aed2f2e685741" title="This API Enables the I2C module.This will bring the I2C module out of reset.">I2CMasterEnable</a></li>
</ol>
</li>
<li>Programming sequence for setting up i2c write<ol type="a">
<li>Set the transfer length (number of bytes) through the API <a class="el" href="i2c_8h.html#a297979a6c020ccdee3ab0364651b1603" title="This API configure I2C data count register with a value. The value in the I2C data count register ind...">I2CSetDataCount</a></li>
<li>Configure the i2c controller in master transmitter mode using the API <a class="el" href="i2c_8h.html#a18cc90f3e5b094a135b58000fb902e95" title="This API configure I2C in different modes of operation.">I2CMasterControl</a></li>
<li>Enable necessary interrupts using the API in master mode <a class="el" href="i2c_8h.html#aa642dd67fecef1ad3e5ef7f55000845a" title="This API enables only specified I2C interrupts in master mode.">I2CMasterIntEnableEx</a></li>
<li>Generate start condition using the API <a class="el" href="i2c_8h.html#ae0089d19230c4fe081210973d8836818" title="This API starts a I2C transaction on the bus. This API must be called after all the configuration for...">I2CMasterStart</a></li>
<li>Check for data completion either through interrupts or through status checking.</li>
</ol>
</li>
<li>Programming sequence for setting up i2c read is same as write except configuring the i2c controller in master receiver mode </li>
</ol>
</div>
<p><a href="i2c_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaef8d0cc99f0d977ec52b57c9b7b78ebb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#gaef8d0cc99f0d977ec52b57c9b7b78ebb">I2C_CFG_MST_TX</a></td></tr>
<tr class="memdesc:gaef8d0cc99f0d977ec52b57c9b7b78ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_MST_TX - Master transmit mode.  <a href="group__CSL__I2C.html#gaef8d0cc99f0d977ec52b57c9b7b78ebb">More...</a><br /></td></tr>
<tr class="separator:gaef8d0cc99f0d977ec52b57c9b7b78ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4daef3adcd291d6fc334afdeed860152"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga4daef3adcd291d6fc334afdeed860152">I2C_CFG_MST_RX</a>&#160;&#160;&#160;((uint32_t) I2C_CON_MST_MASK)</td></tr>
<tr class="memdesc:ga4daef3adcd291d6fc334afdeed860152"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_MST_RX - Matter receive mode.  <a href="group__CSL__I2C.html#ga4daef3adcd291d6fc334afdeed860152">More...</a><br /></td></tr>
<tr class="separator:ga4daef3adcd291d6fc334afdeed860152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad6b7027b20e8447a68b3e9227aadded"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#gaad6b7027b20e8447a68b3e9227aadded">I2C_CFG_STOP</a>&#160;&#160;&#160;((uint32_t) I2C_CON_STP_MASK)</td></tr>
<tr class="memdesc:gaad6b7027b20e8447a68b3e9227aadded"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_STOP - Stop condition.  <a href="group__CSL__I2C.html#gaad6b7027b20e8447a68b3e9227aadded">More...</a><br /></td></tr>
<tr class="separator:gaad6b7027b20e8447a68b3e9227aadded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08dac692139c730db18b9e5b142763c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga08dac692139c730db18b9e5b142763c2">I2C_CFG_N0RMAL_MODE</a>&#160;&#160;&#160;((uint32_t) 0 &lt;&lt; I2C_CON_STB_SHIFT)</td></tr>
<tr class="memdesc:ga08dac692139c730db18b9e5b142763c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_N0RMAL_MODE - Normal mode.  <a href="group__CSL__I2C.html#ga08dac692139c730db18b9e5b142763c2">More...</a><br /></td></tr>
<tr class="separator:ga08dac692139c730db18b9e5b142763c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6008ba50735a691b2bb861335eac02a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga6008ba50735a691b2bb861335eac02a2">I2C_CFG_SRT_BYTE_MODE</a>&#160;&#160;&#160;((uint32_t) I2C_CON_STB_MASK)</td></tr>
<tr class="memdesc:ga6008ba50735a691b2bb861335eac02a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_SRT_BYTE_MODE - Start byte mode.  <a href="group__CSL__I2C.html#ga6008ba50735a691b2bb861335eac02a2">More...</a><br /></td></tr>
<tr class="separator:ga6008ba50735a691b2bb861335eac02a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae2f4c1be0c782920b45357adde80d88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#gaae2f4c1be0c782920b45357adde80d88">I2C_CFG_7BIT_SLAVE_ADDR</a>&#160;&#160;&#160;((uint32_t) 0 &lt;&lt; I2C_CON_XSA_SHIFT)</td></tr>
<tr class="memdesc:gaae2f4c1be0c782920b45357adde80d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_7BIT_SLAVE_ADDR - 7 bit slave address.  <a href="group__CSL__I2C.html#gaae2f4c1be0c782920b45357adde80d88">More...</a><br /></td></tr>
<tr class="separator:gaae2f4c1be0c782920b45357adde80d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c551f75e9dfcb336469c670407c8c8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga2c551f75e9dfcb336469c670407c8c8d">I2C_CFG_10BIT_SLAVE_ADDR</a>&#160;&#160;&#160;((uint32_t) I2C_CON_XSA_MASK)</td></tr>
<tr class="memdesc:ga2c551f75e9dfcb336469c670407c8c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_10BIT_SLAVE_ADDR - 10 bit slave address.  <a href="group__CSL__I2C.html#ga2c551f75e9dfcb336469c670407c8c8d">More...</a><br /></td></tr>
<tr class="separator:ga2c551f75e9dfcb336469c670407c8c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a5bfcef6b73c5d032e14cc771b7a1b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#gaf6a5bfcef6b73c5d032e14cc771b7a1b">I2C_CFG_10BIT_OWN_ADDR_0</a>&#160;&#160;&#160;((uint32_t) I2C_CON_XOA0_MASK)</td></tr>
<tr class="memdesc:gaf6a5bfcef6b73c5d032e14cc771b7a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_10BIT_OWN_ADDR_0 - Master mode 10 bit own address 0.  <a href="group__CSL__I2C.html#gaf6a5bfcef6b73c5d032e14cc771b7a1b">More...</a><br /></td></tr>
<tr class="separator:gaf6a5bfcef6b73c5d032e14cc771b7a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8efd8873d474321ea615bd0812e2e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga4d8efd8873d474321ea615bd0812e2e7">I2C_CFG_10BIT_OWN_ADDR_1</a>&#160;&#160;&#160;((uint32_t) I2C_CON_XOA1_MASK)</td></tr>
<tr class="memdesc:ga4d8efd8873d474321ea615bd0812e2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_10BIT_OWN_ADDR_1 - Master mode 10 bit own address 1.  <a href="group__CSL__I2C.html#ga4d8efd8873d474321ea615bd0812e2e7">More...</a><br /></td></tr>
<tr class="separator:ga4d8efd8873d474321ea615bd0812e2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7671b439f522d57ec3cab8e6492a60e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga7671b439f522d57ec3cab8e6492a60e6">I2C_CFG_10BIT_OWN_ADDR_2</a>&#160;&#160;&#160;((uint32_t) I2C_CON_XOA2_MASK)</td></tr>
<tr class="memdesc:ga7671b439f522d57ec3cab8e6492a60e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_10BIT_OWN_ADDR_2 - Master mode 10 bit own address 2.  <a href="group__CSL__I2C.html#ga7671b439f522d57ec3cab8e6492a60e6">More...</a><br /></td></tr>
<tr class="separator:ga7671b439f522d57ec3cab8e6492a60e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab284bcb3524d2baecd2a9886095f4ad5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#gab284bcb3524d2baecd2a9886095f4ad5">I2C_CFG_10BIT_OWN_ADDR_3</a>&#160;&#160;&#160;((uint32_t) I2C_CON_XOA3_MASK)</td></tr>
<tr class="memdesc:gab284bcb3524d2baecd2a9886095f4ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_10BIT_OWN_ADDR_3 - Master mode 10 bit own address 3.  <a href="group__CSL__I2C.html#gab284bcb3524d2baecd2a9886095f4ad5">More...</a><br /></td></tr>
<tr class="separator:gab284bcb3524d2baecd2a9886095f4ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb3ebdd4f7c8175ba9a6c4baad243e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga5fb3ebdd4f7c8175ba9a6c4baad243e5">I2C_CFG_7BIT_OWN_ADDR_0</a>&#160;&#160;&#160;((uint32_t) 0 &lt;&lt; I2C_CON_XOA0_SHIFT)</td></tr>
<tr class="memdesc:ga5fb3ebdd4f7c8175ba9a6c4baad243e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_7BIT_OWN_ADDR_0 - Master mode 7 bit own address 0.  <a href="group__CSL__I2C.html#ga5fb3ebdd4f7c8175ba9a6c4baad243e5">More...</a><br /></td></tr>
<tr class="separator:ga5fb3ebdd4f7c8175ba9a6c4baad243e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6130524ff8cb66370e558fcda91ac3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga9d6130524ff8cb66370e558fcda91ac3">I2C_CFG_7BIT_OWN_ADDR_1</a>&#160;&#160;&#160;((uint32_t) 0 &lt;&lt; I2C_CON_XOA1_SHIFT)</td></tr>
<tr class="memdesc:ga9d6130524ff8cb66370e558fcda91ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_7BIT_OWN_ADDR_1 - Master mode 7 bit own address 1.  <a href="group__CSL__I2C.html#ga9d6130524ff8cb66370e558fcda91ac3">More...</a><br /></td></tr>
<tr class="separator:ga9d6130524ff8cb66370e558fcda91ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a3be4168a2a095a3e1c5c8238a40cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga70a3be4168a2a095a3e1c5c8238a40cf">I2C_CFG_7BIT_OWN_ADDR_2</a>&#160;&#160;&#160;((uint32_t) 0 &lt;&lt; I2C_CON_XOA2_SHIFT)</td></tr>
<tr class="memdesc:ga70a3be4168a2a095a3e1c5c8238a40cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_7BIT_OWN_ADDR_2 - Master mode 7 bit own address 2.  <a href="group__CSL__I2C.html#ga70a3be4168a2a095a3e1c5c8238a40cf">More...</a><br /></td></tr>
<tr class="separator:ga70a3be4168a2a095a3e1c5c8238a40cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315a0521e4f5d3d7a7316152be3d5afc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga315a0521e4f5d3d7a7316152be3d5afc">I2C_CFG_7BIT_OWN_ADDR_3</a>&#160;&#160;&#160;((uint32_t) 0 &lt;&lt; I2C_CON_XOA3_SHIFT)</td></tr>
<tr class="memdesc:ga315a0521e4f5d3d7a7316152be3d5afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_7BIT_OWN_ADDR_3 - Master mode 7 bit own address 3.  <a href="group__CSL__I2C.html#ga315a0521e4f5d3d7a7316152be3d5afc">More...</a><br /></td></tr>
<tr class="separator:ga315a0521e4f5d3d7a7316152be3d5afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7f4be1aea20ddacee4465b660469ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga7f7f4be1aea20ddacee4465b660469ee">I2C_CFG_MST_ENABLE</a>&#160;&#160;&#160;((uint32_t) I2C_CON_I2C_EN_MASK)</td></tr>
<tr class="memdesc:ga7f7f4be1aea20ddacee4465b660469ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_MST_ENABLE - I2C module enable.  <a href="group__CSL__I2C.html#ga7f7f4be1aea20ddacee4465b660469ee">More...</a><br /></td></tr>
<tr class="separator:ga7f7f4be1aea20ddacee4465b660469ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga284bfcd9930ebc5753b5b4939f310950"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga284bfcd9930ebc5753b5b4939f310950">I2C_CFG_START</a>&#160;&#160;&#160;((uint32_t) I2C_CON_STT_MASK)</td></tr>
<tr class="memdesc:ga284bfcd9930ebc5753b5b4939f310950"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_START - Start condition, initiate I2C transfer.  <a href="group__CSL__I2C.html#ga284bfcd9930ebc5753b5b4939f310950">More...</a><br /></td></tr>
<tr class="separator:ga284bfcd9930ebc5753b5b4939f310950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga883c1398645ffe8b237265d3c4712b3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga883c1398645ffe8b237265d3c4712b3f">I2C_CFG_MST</a>&#160;&#160;&#160;((uint32_t) I2C_CON_MST_MASK)</td></tr>
<tr class="memdesc:ga883c1398645ffe8b237265d3c4712b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_MST - I2C configure master mode.  <a href="group__CSL__I2C.html#ga883c1398645ffe8b237265d3c4712b3f">More...</a><br /></td></tr>
<tr class="separator:ga883c1398645ffe8b237265d3c4712b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71f78878ce63c5a8572c40cfc5a4e651"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__I2C.html#ga71f78878ce63c5a8572c40cfc5a4e651">I2C_CFG_HS_MOD</a>&#160;&#160;&#160;((uint32_t) CSL_I2C_CON_OPMODE_HSI2C &lt;&lt; CSL_I2C_CON_OPMODE_SHIFT)</td></tr>
<tr class="memdesc:ga71f78878ce63c5a8572c40cfc5a4e651"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CFG_HS_MODE - High speed operation mode.  <a href="group__CSL__I2C.html#ga71f78878ce63c5a8572c40cfc5a4e651">More...</a><br /></td></tr>
<tr class="separator:ga71f78878ce63c5a8572c40cfc5a4e651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac010109692dc03addb6c00209c915b2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ac010109692dc03addb6c00209c915b2c">I2C_INT_ARBITRATION_LOST</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_AL_MASK)</td></tr>
<tr class="memdesc:ac010109692dc03addb6c00209c915b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_ARBITRATION_LOST - Arbitration lost interrupt.  <a href="#ac010109692dc03addb6c00209c915b2c">More...</a><br /></td></tr>
<tr class="separator:ac010109692dc03addb6c00209c915b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d380029b61a2bd7a3c5688f18b9145e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a3d380029b61a2bd7a3c5688f18b9145e">I2C_INT_NO_ACK</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_NACK_MASK)</td></tr>
<tr class="memdesc:a3d380029b61a2bd7a3c5688f18b9145e"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_NO_ACK - No acknowledgement interrupt.  <a href="#a3d380029b61a2bd7a3c5688f18b9145e">More...</a><br /></td></tr>
<tr class="separator:a3d380029b61a2bd7a3c5688f18b9145e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084b97e99a4c2a54811f695b6699f1e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a084b97e99a4c2a54811f695b6699f1e9">I2C_INT_ADRR_READY_ACESS</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_ARDY_MASK)</td></tr>
<tr class="memdesc:a084b97e99a4c2a54811f695b6699f1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_ADRR_READY_ACESS - Register access ready interrupt.  <a href="#a084b97e99a4c2a54811f695b6699f1e9">More...</a><br /></td></tr>
<tr class="separator:a084b97e99a4c2a54811f695b6699f1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc05bc3084d9dfc0064885b59e900c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#adfc05bc3084d9dfc0064885b59e900c0">I2C_INT_RECV_READY</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_RRDY_MASK)</td></tr>
<tr class="memdesc:adfc05bc3084d9dfc0064885b59e900c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_RECV_READY - Receive data ready interrupt.  <a href="#adfc05bc3084d9dfc0064885b59e900c0">More...</a><br /></td></tr>
<tr class="separator:adfc05bc3084d9dfc0064885b59e900c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28fb48a2ee9f9f68e71d27f76a9573c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#af28fb48a2ee9f9f68e71d27f76a9573c">I2C_INT_TRANSMIT_READY</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_XRDY_MASK)</td></tr>
<tr class="memdesc:af28fb48a2ee9f9f68e71d27f76a9573c"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_TRANSMIT_READY - Transmit data ready interrupt.  <a href="#af28fb48a2ee9f9f68e71d27f76a9573c">More...</a><br /></td></tr>
<tr class="separator:af28fb48a2ee9f9f68e71d27f76a9573c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136608cb852a2c8169b276b7c9edbfb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a136608cb852a2c8169b276b7c9edbfb5">I2C_INT_GENERAL_CALL</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_GC_MASK)</td></tr>
<tr class="memdesc:a136608cb852a2c8169b276b7c9edbfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_GENERAL_CALL - General call Interrupt.  <a href="#a136608cb852a2c8169b276b7c9edbfb5">More...</a><br /></td></tr>
<tr class="separator:a136608cb852a2c8169b276b7c9edbfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9def92e28c6611d76f6d937cddd72460"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a9def92e28c6611d76f6d937cddd72460">I2C_INT_START</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_STC_MASK)</td></tr>
<tr class="memdesc:a9def92e28c6611d76f6d937cddd72460"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_START - Start Condition interrupt.  <a href="#a9def92e28c6611d76f6d937cddd72460">More...</a><br /></td></tr>
<tr class="separator:a9def92e28c6611d76f6d937cddd72460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54645dd39e076bb60ca7ec2d57f7ca7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a54645dd39e076bb60ca7ec2d57f7ca7c">I2C_INT_ACCESS_ERROR</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_AERR_MASK)</td></tr>
<tr class="memdesc:a54645dd39e076bb60ca7ec2d57f7ca7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_ACCESS_ERROR - Access Error interrupt.  <a href="#a54645dd39e076bb60ca7ec2d57f7ca7c">More...</a><br /></td></tr>
<tr class="separator:a54645dd39e076bb60ca7ec2d57f7ca7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c1d12497392f4dd5ec4ce6400c5200"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a72c1d12497392f4dd5ec4ce6400c5200">I2C_INT_STOP_CONDITION</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_BF_MASK)</td></tr>
<tr class="memdesc:a72c1d12497392f4dd5ec4ce6400c5200"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_STOP_CONDITION - Bus Free interrupt.  <a href="#a72c1d12497392f4dd5ec4ce6400c5200">More...</a><br /></td></tr>
<tr class="separator:a72c1d12497392f4dd5ec4ce6400c5200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4d6beae050207191e4fa152a9c66e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a4f4d6beae050207191e4fa152a9c66e8">I2C_INT_ADRR_SLAVE</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_AAS_MASK)</td></tr>
<tr class="memdesc:a4f4d6beae050207191e4fa152a9c66e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_ADRR_SLAVE - Addressed as Slave interrupt.  <a href="#a4f4d6beae050207191e4fa152a9c66e8">More...</a><br /></td></tr>
<tr class="separator:a4f4d6beae050207191e4fa152a9c66e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e253549399ea7eec4087006b0381617"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a4e253549399ea7eec4087006b0381617">I2C_INT_TRANSMIT_UNDER_FLOW</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_XUDF_MASK)</td></tr>
<tr class="memdesc:a4e253549399ea7eec4087006b0381617"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_TRANSMIT_UNDER_FLOW - Transmit underflow interrupt.  <a href="#a4e253549399ea7eec4087006b0381617">More...</a><br /></td></tr>
<tr class="separator:a4e253549399ea7eec4087006b0381617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592ee43a851ac305d1ee8f832026099"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a6592ee43a851ac305d1ee8f832026099">I2C_INT_RECV_OVER_RUN</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_ROVR_MASK)</td></tr>
<tr class="memdesc:a6592ee43a851ac305d1ee8f832026099"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_RECV_OVER_RUN - Receive overrun interrupt.  <a href="#a6592ee43a851ac305d1ee8f832026099">More...</a><br /></td></tr>
<tr class="separator:a6592ee43a851ac305d1ee8f832026099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39b3a5cd5f603ec0e9cd16b0b665284"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ae39b3a5cd5f603ec0e9cd16b0b665284">I2C_INT_RECV_DRAIN</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_RDR_MASK)</td></tr>
<tr class="memdesc:ae39b3a5cd5f603ec0e9cd16b0b665284"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_RECV_DRAIN - Receive Draining interrupt.  <a href="#ae39b3a5cd5f603ec0e9cd16b0b665284">More...</a><br /></td></tr>
<tr class="separator:ae39b3a5cd5f603ec0e9cd16b0b665284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e5617a0008db9ae4c83758e129a920"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#af7e5617a0008db9ae4c83758e129a920">I2C_INT_TRANSMIT_DRAIN</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_XDR_MASK)</td></tr>
<tr class="memdesc:af7e5617a0008db9ae4c83758e129a920"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_TRANSMIT_DRAIN - Transmit Draining interrupt.  <a href="#af7e5617a0008db9ae4c83758e129a920">More...</a><br /></td></tr>
<tr class="separator:af7e5617a0008db9ae4c83758e129a920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4471c913d3fda09badbad20afc12124d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a4471c913d3fda09badbad20afc12124d">I2C_INT_BUS_BUSY</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_RAW_BB_MASK)</td></tr>
<tr class="memdesc:a4471c913d3fda09badbad20afc12124d"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_BUS_BUSY - Bus busy interrupt raw status.  <a href="#a4471c913d3fda09badbad20afc12124d">More...</a><br /></td></tr>
<tr class="separator:a4471c913d3fda09badbad20afc12124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf64ba80311c6866f0e30244278b9099"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#adf64ba80311c6866f0e30244278b9099">I2C_INT_BUS_FREE</a>&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_RAW_BF_MASK)</td></tr>
<tr class="memdesc:adf64ba80311c6866f0e30244278b9099"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_BUS_FREE - Bus free interrupt raw status.  <a href="#adf64ba80311c6866f0e30244278b9099">More...</a><br /></td></tr>
<tr class="separator:adf64ba80311c6866f0e30244278b9099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b4bd4632e2cb83cfbbeb901ebbea7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ad8b4bd4632e2cb83cfbbeb901ebbea7a">I2C_INT_ALL</a>&#160;&#160;&#160;((uint32_t) 0x7FFFU)</td></tr>
<tr class="memdesc:ad8b4bd4632e2cb83cfbbeb901ebbea7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_INT_ALL - Enable all interrupt.  <a href="#ad8b4bd4632e2cb83cfbbeb901ebbea7a">More...</a><br /></td></tr>
<tr class="separator:ad8b4bd4632e2cb83cfbbeb901ebbea7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d1b528da6253fa0360552b101c01d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ae2d1b528da6253fa0360552b101c01d9">I2C_TX_MODE</a>&#160;&#160;&#160;((uint32_t) 1U)</td></tr>
<tr class="memdesc:ae2d1b528da6253fa0360552b101c01d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_TX_MODE - Transmit mode.  <a href="#ae2d1b528da6253fa0360552b101c01d9">More...</a><br /></td></tr>
<tr class="separator:ae2d1b528da6253fa0360552b101c01d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72b16cdd19cf9125def8a811036c682"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ac72b16cdd19cf9125def8a811036c682">I2C_RX_MODE</a>&#160;&#160;&#160;((uint32_t) 0U)</td></tr>
<tr class="memdesc:ac72b16cdd19cf9125def8a811036c682"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_RX_MODE - Receive mode.  <a href="#ac72b16cdd19cf9125def8a811036c682">More...</a><br /></td></tr>
<tr class="separator:ac72b16cdd19cf9125def8a811036c682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2f7e51db56b8700bfe6e2447377354"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a0b2f7e51db56b8700bfe6e2447377354">I2C_TX_BUFFER_STATUS</a>&#160;&#160;&#160;((uint32_t) 0U)</td></tr>
<tr class="memdesc:a0b2f7e51db56b8700bfe6e2447377354"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_TX_BUFFER_STATUS - TX buffer status flag.  <a href="#a0b2f7e51db56b8700bfe6e2447377354">More...</a><br /></td></tr>
<tr class="separator:a0b2f7e51db56b8700bfe6e2447377354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30874d9ff7ace1614572008b16622be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#af30874d9ff7ace1614572008b16622be">I2C_RX_BUFFER_STATUS</a>&#160;&#160;&#160;((uint32_t) 1U)</td></tr>
<tr class="memdesc:af30874d9ff7ace1614572008b16622be"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_RX_BUFFER_STATUS - RX buffer status flag.  <a href="#af30874d9ff7ace1614572008b16622be">More...</a><br /></td></tr>
<tr class="separator:af30874d9ff7ace1614572008b16622be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c8ab2a4f1438202f08aa4e60ef0914"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ab2c8ab2a4f1438202f08aa4e60ef0914">I2C_FIFO_DEPTH</a>&#160;&#160;&#160;((uint32_t) 2U)</td></tr>
<tr class="memdesc:ab2c8ab2a4f1438202f08aa4e60ef0914"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_FIFO_DEPTH - Internal FIFO depth flag.  <a href="#ab2c8ab2a4f1438202f08aa4e60ef0914">More...</a><br /></td></tr>
<tr class="separator:ab2c8ab2a4f1438202f08aa4e60ef0914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c751c0bbf436d25fd671a0f382718ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a7c751c0bbf436d25fd671a0f382718ca">I2C_WAKE_UP_ARBITRATION_LOST</a>&#160;&#160;&#160;(I2C_WE_AL_MASK)</td></tr>
<tr class="memdesc:a7c751c0bbf436d25fd671a0f382718ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_ARBITRATION_LOST - Arbitration lost IRQ wakeup set.  <a href="#a7c751c0bbf436d25fd671a0f382718ca">More...</a><br /></td></tr>
<tr class="separator:a7c751c0bbf436d25fd671a0f382718ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257f497be7bc2091d89c908aa2e13aee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a257f497be7bc2091d89c908aa2e13aee">I2C_WAKE_UP_NO_ACK</a>&#160;&#160;&#160;(I2C_WE_NACK_MASK)</td></tr>
<tr class="memdesc:a257f497be7bc2091d89c908aa2e13aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_NO_ACK - No acknowledgment IRQ wakeup set.  <a href="#a257f497be7bc2091d89c908aa2e13aee">More...</a><br /></td></tr>
<tr class="separator:a257f497be7bc2091d89c908aa2e13aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a61d38b5732c0c1709ff3caadb6f1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a85a61d38b5732c0c1709ff3caadb6f1e">I2C_WAKE_UP_ADRR_RDY_ACCESS</a>&#160;&#160;&#160;(I2C_WE_ARDY_MASK)</td></tr>
<tr class="memdesc:a85a61d38b5732c0c1709ff3caadb6f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_ADRR_RDY_ACCESS - Register access ready IRQ wakeup set.  <a href="#a85a61d38b5732c0c1709ff3caadb6f1e">More...</a><br /></td></tr>
<tr class="separator:a85a61d38b5732c0c1709ff3caadb6f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf92d884d412f2d1adb50a4caabd3e21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#adf92d884d412f2d1adb50a4caabd3e21">I2C_WAKE_UP_GENERAL_CALL</a>&#160;&#160;&#160;(I2C_WE_GC_MASK)</td></tr>
<tr class="memdesc:adf92d884d412f2d1adb50a4caabd3e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_GENERAL_CALL - General call IRQ wakeup set.  <a href="#adf92d884d412f2d1adb50a4caabd3e21">More...</a><br /></td></tr>
<tr class="separator:adf92d884d412f2d1adb50a4caabd3e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ada87dc419cba2266aa733364157e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a85ada87dc419cba2266aa733364157e7">I2C_WAKE_UP_START</a>&#160;&#160;&#160;(I2C_WE_STC_MASK)</td></tr>
<tr class="memdesc:a85ada87dc419cba2266aa733364157e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_START - Start Condition IRQ wakeup set.  <a href="#a85ada87dc419cba2266aa733364157e7">More...</a><br /></td></tr>
<tr class="separator:a85ada87dc419cba2266aa733364157e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92294c85b548aafae84068e1ab7cd929"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a92294c85b548aafae84068e1ab7cd929">I2C_WAKE_UP_STOP_CONDITION</a>&#160;&#160;&#160;(I2C_WE_BF_MASK)</td></tr>
<tr class="memdesc:a92294c85b548aafae84068e1ab7cd929"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_STOP_CONDITION - Bus Free IRQ wakeup set.  <a href="#a92294c85b548aafae84068e1ab7cd929">More...</a><br /></td></tr>
<tr class="separator:a92294c85b548aafae84068e1ab7cd929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eb31aa204220038902a41e23fc1398"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a54eb31aa204220038902a41e23fc1398">I2C_WAKE_UP_ADRR_SLAVE</a>&#160;&#160;&#160;(I2C_WE_AAS_MASK)</td></tr>
<tr class="memdesc:a54eb31aa204220038902a41e23fc1398"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_ADRR_SLAVE - Address as slave IRQ wakeup set.  <a href="#a54eb31aa204220038902a41e23fc1398">More...</a><br /></td></tr>
<tr class="separator:a54eb31aa204220038902a41e23fc1398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0627afb1a05d62c1576ecfea005af1d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#aa0627afb1a05d62c1576ecfea005af1d">I2C_WAKE_UP_TX_UNDER_FLOW</a>&#160;&#160;&#160;(I2C_WE_XUDF_MASK)</td></tr>
<tr class="memdesc:aa0627afb1a05d62c1576ecfea005af1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_TX_UNDER_FLOW - Transmit underflow wakeup set.  <a href="#aa0627afb1a05d62c1576ecfea005af1d">More...</a><br /></td></tr>
<tr class="separator:aa0627afb1a05d62c1576ecfea005af1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad9412e2ef6ea5a1a260a44e6a14802"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a7ad9412e2ef6ea5a1a260a44e6a14802">I2C_WAKE_UP_RECV_OVER_RUN</a>&#160;&#160;&#160;(I2C_WE_ROVR_MASK)</td></tr>
<tr class="memdesc:a7ad9412e2ef6ea5a1a260a44e6a14802"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_RECV_OVER_RUN - Receive overrun wakeup set.  <a href="#a7ad9412e2ef6ea5a1a260a44e6a14802">More...</a><br /></td></tr>
<tr class="separator:a7ad9412e2ef6ea5a1a260a44e6a14802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a41e30f92cc7a6e99cf9580f800b62"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a50a41e30f92cc7a6e99cf9580f800b62">I2C_WAKE_UP_RECV_DRAIN</a>&#160;&#160;&#160;(I2C_WE_RDR_MASK)</td></tr>
<tr class="memdesc:a50a41e30f92cc7a6e99cf9580f800b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_RECV_DRAIN - Receive Draining wakeup set.  <a href="#a50a41e30f92cc7a6e99cf9580f800b62">More...</a><br /></td></tr>
<tr class="separator:a50a41e30f92cc7a6e99cf9580f800b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881f0ec02d5c5ae7b13112f2fe8bee04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a881f0ec02d5c5ae7b13112f2fe8bee04">I2C_WAKE_UP_TRANSMIT_DRAIN</a>&#160;&#160;&#160;(I2C_WE_XDR_MASK)</td></tr>
<tr class="memdesc:a881f0ec02d5c5ae7b13112f2fe8bee04"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_TRANSMIT_DRAIN - Transmit Draining wakeup set.  <a href="#a881f0ec02d5c5ae7b13112f2fe8bee04">More...</a><br /></td></tr>
<tr class="separator:a881f0ec02d5c5ae7b13112f2fe8bee04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57485894314e7e3ba9164efe8f4f1273"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a57485894314e7e3ba9164efe8f4f1273">I2C_WAKE_UP_DATA_RECV_TX_RDY</a>&#160;&#160;&#160;(I2C_WE_DRDY_MASK)</td></tr>
<tr class="memdesc:a57485894314e7e3ba9164efe8f4f1273"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_DATA_RECV_TX_RDY - Receive/Transmit data ready IRQ wakeup set.  <a href="#a57485894314e7e3ba9164efe8f4f1273">More...</a><br /></td></tr>
<tr class="separator:a57485894314e7e3ba9164efe8f4f1273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02778ddf4fd640b00ccaf6cf25d96774"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a02778ddf4fd640b00ccaf6cf25d96774">I2C_WAKE_UP_IRQ</a>&#160;&#160;&#160;((uint32_t) 1U)</td></tr>
<tr class="memdesc:a02778ddf4fd640b00ccaf6cf25d96774"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_IRQ - IRQ request source.  <a href="#a02778ddf4fd640b00ccaf6cf25d96774">More...</a><br /></td></tr>
<tr class="separator:a02778ddf4fd640b00ccaf6cf25d96774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64978ac277e98e958b20412bdeb2708f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a64978ac277e98e958b20412bdeb2708f">I2C_WAKE_UP_DMA_RECV</a>&#160;&#160;&#160;((uint32_t) 2U)</td></tr>
<tr class="memdesc:a64978ac277e98e958b20412bdeb2708f"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_DMA_RECV - DMA receive request source.  <a href="#a64978ac277e98e958b20412bdeb2708f">More...</a><br /></td></tr>
<tr class="separator:a64978ac277e98e958b20412bdeb2708f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf1457b73520fe87795ab51ad2d053e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#addf1457b73520fe87795ab51ad2d053e">I2C_WAKE_UP_DMA_TRANSMIT</a>&#160;&#160;&#160;((uint32_t) 3U)</td></tr>
<tr class="memdesc:addf1457b73520fe87795ab51ad2d053e"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_WAKE_UP_DMA_TRANSMIT - DMA transmit request source.  <a href="#addf1457b73520fe87795ab51ad2d053e">More...</a><br /></td></tr>
<tr class="separator:addf1457b73520fe87795ab51ad2d053e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2f924cd6a70be33ebe6a320489a7f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a5d2f924cd6a70be33ebe6a320489a7f8">I2C_STATUS_RAW</a>&#160;&#160;&#160;((uint32_t) 0U)</td></tr>
<tr class="memdesc:a5d2f924cd6a70be33ebe6a320489a7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_STATUS_RAW - RAW IRQ status.  <a href="#a5d2f924cd6a70be33ebe6a320489a7f8">More...</a><br /></td></tr>
<tr class="separator:a5d2f924cd6a70be33ebe6a320489a7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e55953a8d401c11b99d8ca9508e7de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a46e55953a8d401c11b99d8ca9508e7de">I2C_STATUS</a>&#160;&#160;&#160;((uint32_t) 1U)</td></tr>
<tr class="memdesc:a46e55953a8d401c11b99d8ca9508e7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_STATUS - IRQ status.  <a href="#a46e55953a8d401c11b99d8ca9508e7de">More...</a><br /></td></tr>
<tr class="separator:a46e55953a8d401c11b99d8ca9508e7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df53a3f3b6cf8121350e400ad36bddb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a9df53a3f3b6cf8121350e400ad36bddb">HAL_HSI2C_SUCCESS</a>&#160;&#160;&#160;((uint32_t) 0U)</td></tr>
<tr class="memdesc:a9df53a3f3b6cf8121350e400ad36bddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">HAL_HSI2C_SUCCESS - I2C success.  <a href="#a9df53a3f3b6cf8121350e400ad36bddb">More...</a><br /></td></tr>
<tr class="separator:a9df53a3f3b6cf8121350e400ad36bddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcde35e8d012da56044653bb2e6c8942"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#abcde35e8d012da56044653bb2e6c8942">HAL_HSI2C_FAIL</a>&#160;&#160;&#160;((uint32_t) 1U)</td></tr>
<tr class="memdesc:abcde35e8d012da56044653bb2e6c8942"><td class="mdescLeft">&#160;</td><td class="mdescRight">HAL_HSI2C_FAIL - I2C fail.  <a href="#abcde35e8d012da56044653bb2e6c8942">More...</a><br /></td></tr>
<tr class="separator:abcde35e8d012da56044653bb2e6c8942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5607d186fb5e2336d6e33e8934287c9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a5607d186fb5e2336d6e33e8934287c9c">I2C_OWN_ADDR_0</a>&#160;&#160;&#160;((uint32_t) 0U)</td></tr>
<tr class="memdesc:a5607d186fb5e2336d6e33e8934287c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_OWN_ADDR_0 - set own address 0.  <a href="#a5607d186fb5e2336d6e33e8934287c9c">More...</a><br /></td></tr>
<tr class="separator:a5607d186fb5e2336d6e33e8934287c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7f38299a6d385d9a37b780d230af3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#adf7f38299a6d385d9a37b780d230af3b">I2C_OWN_ADDR_1</a>&#160;&#160;&#160;((uint32_t) 1U)</td></tr>
<tr class="memdesc:adf7f38299a6d385d9a37b780d230af3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_OWN_ADDR_1 - set own address 1.  <a href="#adf7f38299a6d385d9a37b780d230af3b">More...</a><br /></td></tr>
<tr class="separator:adf7f38299a6d385d9a37b780d230af3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143a4e198cb74e71552a9bdd00fdf107"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a143a4e198cb74e71552a9bdd00fdf107">I2C_OWN_ADDR_2</a>&#160;&#160;&#160;((uint32_t) 2U)</td></tr>
<tr class="memdesc:a143a4e198cb74e71552a9bdd00fdf107"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_OWN_ADDR_2 - set own address 2.  <a href="#a143a4e198cb74e71552a9bdd00fdf107">More...</a><br /></td></tr>
<tr class="separator:a143a4e198cb74e71552a9bdd00fdf107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29723c3ffdb0ba69b389b06ecd30c7a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a29723c3ffdb0ba69b389b06ecd30c7a1">I2C_OWN_ADDR_3</a>&#160;&#160;&#160;((uint32_t) 3U)</td></tr>
<tr class="memdesc:a29723c3ffdb0ba69b389b06ecd30c7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_OWN_ADDR_3 - set own address 3.  <a href="#a29723c3ffdb0ba69b389b06ecd30c7a1">More...</a><br /></td></tr>
<tr class="separator:a29723c3ffdb0ba69b389b06ecd30c7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac0effda3bee4a5df40e5434af25de1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a6ac0effda3bee4a5df40e5434af25de1">I2C_AUTOIDLE_DISABLE</a>&#160;&#160;&#160;(I2C_SYSC_AUTOIDLE_DISABLE)</td></tr>
<tr class="memdesc:a6ac0effda3bee4a5df40e5434af25de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_AUTOIDLE_DISABLE Disable auto idle mechanism.  <a href="#a6ac0effda3bee4a5df40e5434af25de1">More...</a><br /></td></tr>
<tr class="separator:a6ac0effda3bee4a5df40e5434af25de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f040d4dc1a864fafbc4d072a4d3307"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ac9f040d4dc1a864fafbc4d072a4d3307">I2C_AUTOIDLE_ENABLE</a></td></tr>
<tr class="memdesc:ac9f040d4dc1a864fafbc4d072a4d3307"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_AUTOIDLE_ENABLE Enable autoidle mechanism.  <a href="#ac9f040d4dc1a864fafbc4d072a4d3307">More...</a><br /></td></tr>
<tr class="separator:ac9f040d4dc1a864fafbc4d072a4d3307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3750144770d6c938b11ac15c089f8ff8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a3750144770d6c938b11ac15c089f8ff8">I2C_CUT_OFF_BOTH_CLK</a>&#160;&#160;&#160;(I2C_SYSC_CLKACTIVITY_BOOTHOFF)</td></tr>
<tr class="memdesc:a3750144770d6c938b11ac15c089f8ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CUT_OFF_BOTH_CLK Both OCP and SYS Clk are cut off.  <a href="#a3750144770d6c938b11ac15c089f8ff8">More...</a><br /></td></tr>
<tr class="separator:a3750144770d6c938b11ac15c089f8ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2695814468c7f6e0acd258cfbe563650"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a2695814468c7f6e0acd258cfbe563650">I2C_CUT_OFF_SYS_CLK</a></td></tr>
<tr class="memdesc:a2695814468c7f6e0acd258cfbe563650"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CUT_OFF_SYS_CLK system clock is cut off;OCP clock is kept alive.  <a href="#a2695814468c7f6e0acd258cfbe563650">More...</a><br /></td></tr>
<tr class="separator:a2695814468c7f6e0acd258cfbe563650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4543b403f86cd6aa95720e48a2ef46"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a5f4543b403f86cd6aa95720e48a2ef46">I2C_CUT_OFF_OCP_CLK</a></td></tr>
<tr class="memdesc:a5f4543b403f86cd6aa95720e48a2ef46"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_CUT_OFF_OCP_CLK OCP clock is cut off;system clock is is kept alive.  <a href="#a5f4543b403f86cd6aa95720e48a2ef46">More...</a><br /></td></tr>
<tr class="separator:a5f4543b403f86cd6aa95720e48a2ef46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c414a4f827da665641f67335b0069b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a50c414a4f827da665641f67335b0069b">I2C_KEEP_ALIVE_BOTH_CLK</a></td></tr>
<tr class="memdesc:a50c414a4f827da665641f67335b0069b"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_KEEP_ALIVE_BOTH_CLK BOTH OCP and SYS Clk are kept alive.  <a href="#a50c414a4f827da665641f67335b0069b">More...</a><br /></td></tr>
<tr class="separator:a50c414a4f827da665641f67335b0069b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf48b38fc48ce930d867ce2c08146ee4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#adf48b38fc48ce930d867ce2c08146ee4">I2C_ENAWAKEUP_DISABLE</a>&#160;&#160;&#160;(I2C_SYSC_ENAWAKEUP_DISABLE)</td></tr>
<tr class="memdesc:adf48b38fc48ce930d867ce2c08146ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_ENAWAKEUP__DISABLE Disable wakeup mechanism.  <a href="#adf48b38fc48ce930d867ce2c08146ee4">More...</a><br /></td></tr>
<tr class="separator:adf48b38fc48ce930d867ce2c08146ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa210eb67c8d05158898425f17ce4f9fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#aa210eb67c8d05158898425f17ce4f9fd">I2C_ENAWAKEUP_ENABLE</a></td></tr>
<tr class="memdesc:aa210eb67c8d05158898425f17ce4f9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_ENAWAKEUP__ENABLE Enable wakeup mechanism.  <a href="#aa210eb67c8d05158898425f17ce4f9fd">More...</a><br /></td></tr>
<tr class="separator:aa210eb67c8d05158898425f17ce4f9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9730764d2965668c2b3c36ea20fef0a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ac9730764d2965668c2b3c36ea20fef0a">I2C_FORCE_IDLE_MODE</a>&#160;&#160;&#160;(I2C_SYSC_IDLEMODE_FORCEIDLE)</td></tr>
<tr class="memdesc:ac9730764d2965668c2b3c36ea20fef0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_FORCE_IDLE_MODE selects forced idle mode operation.  <a href="#ac9730764d2965668c2b3c36ea20fef0a">More...</a><br /></td></tr>
<tr class="separator:ac9730764d2965668c2b3c36ea20fef0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9012367ff47082655e4900b5c6f07e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#af9012367ff47082655e4900b5c6f07e4">I2C_NO_IDLE_MODE</a></td></tr>
<tr class="memdesc:af9012367ff47082655e4900b5c6f07e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_NO_IDLE_MODE selects no idle mode operation.  <a href="#af9012367ff47082655e4900b5c6f07e4">More...</a><br /></td></tr>
<tr class="separator:af9012367ff47082655e4900b5c6f07e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a53a6f2246172270a67d2923cd42fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a41a53a6f2246172270a67d2923cd42fa">I2C_SMART_IDLE_MODE</a></td></tr>
<tr class="memdesc:a41a53a6f2246172270a67d2923cd42fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_SMART_IDLE_MODE selects smart idle mode operation.  <a href="#a41a53a6f2246172270a67d2923cd42fa">More...</a><br /></td></tr>
<tr class="separator:a41a53a6f2246172270a67d2923cd42fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa537d702685d719b6f65567cd8ed3c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#acaa537d702685d719b6f65567cd8ed3c">I2C_SMART_IDLE_WAKEUP_MODE</a></td></tr>
<tr class="memdesc:acaa537d702685d719b6f65567cd8ed3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_SMART_IDLE_WAKEUP_MODE selects smart idle wakeup mode of operation.  <a href="#acaa537d702685d719b6f65567cd8ed3c">More...</a><br /></td></tr>
<tr class="separator:acaa537d702685d719b6f65567cd8ed3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2d28f09dd9987e54f3a4bbcd76d51c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a6c2d28f09dd9987e54f3a4bbcd76d51c">I2C_OPMODE_FAST_STAND_MODE</a>&#160;&#160;&#160;(I2C_CON_OPMODE_FSI2C)</td></tr>
<tr class="memdesc:a6c2d28f09dd9987e54f3a4bbcd76d51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_OPMODE_FAST_STAND_MODE Select Fast/Standard mode.  <a href="#a6c2d28f09dd9987e54f3a4bbcd76d51c">More...</a><br /></td></tr>
<tr class="separator:a6c2d28f09dd9987e54f3a4bbcd76d51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3733757714133a61de91b331a3a170"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a3f3733757714133a61de91b331a3a170">I2C_OPMODE_HIGH_SPEED_MODE</a></td></tr>
<tr class="memdesc:a3f3733757714133a61de91b331a3a170"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_OPMODE_HIGH_SPEED_MODE Select high speed mode.  <a href="#a3f3733757714133a61de91b331a3a170">More...</a><br /></td></tr>
<tr class="separator:a3f3733757714133a61de91b331a3a170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a8884975edb84b7fd6c19a8f6b5a47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ae0a8884975edb84b7fd6c19a8f6b5a47">I2C_NORMAL_MODE</a>&#160;&#160;&#160;(I2C_CON_STB_NORMAL)</td></tr>
<tr class="memdesc:ae0a8884975edb84b7fd6c19a8f6b5a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_NORMAL_MODE Select Normal mode.  <a href="#ae0a8884975edb84b7fd6c19a8f6b5a47">More...</a><br /></td></tr>
<tr class="separator:ae0a8884975edb84b7fd6c19a8f6b5a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8eb7308263ad6c9c2b0223d5c01b28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a2d8eb7308263ad6c9c2b0223d5c01b28">I2C_STB_MODE</a>&#160;&#160;&#160;((uint32_t) I2C_CON_STB_STB &lt;&lt; I2C_CON_STB_SHIFT)</td></tr>
<tr class="memdesc:a2d8eb7308263ad6c9c2b0223d5c01b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_STB_MODE Select start byte mode.  <a href="#a2d8eb7308263ad6c9c2b0223d5c01b28">More...</a><br /></td></tr>
<tr class="separator:a2d8eb7308263ad6c9c2b0223d5c01b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85dd7164b7a822072c71114d52b706a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ab85dd7164b7a822072c71114d52b706a">I2C_XSA_7BIT</a>&#160;&#160;&#160;(I2C_CON_XSA_B07)</td></tr>
<tr class="memdesc:ab85dd7164b7a822072c71114d52b706a"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_XSA_7BIT Slave address 7 bit mode.  <a href="#ab85dd7164b7a822072c71114d52b706a">More...</a><br /></td></tr>
<tr class="separator:ab85dd7164b7a822072c71114d52b706a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa110029997826069a9c1a28207d79101"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#aa110029997826069a9c1a28207d79101">I2C_XSA_10BIT</a>&#160;&#160;&#160;((uint32_t) I2C_CON_XSA_B10 &lt;&lt; I2C_CON_XSA_SHIFT)</td></tr>
<tr class="memdesc:aa110029997826069a9c1a28207d79101"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_XSA_10BIT Slave address 10 bit mode.  <a href="#aa110029997826069a9c1a28207d79101">More...</a><br /></td></tr>
<tr class="separator:aa110029997826069a9c1a28207d79101"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af7e47cad210fef11af7c6e3d99476345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#af7e47cad210fef11af7c6e3d99476345">I2CMasterInitExpClk</a> (uintptr_t baseAddr, uint32_t sysClk, uint32_t internalClk, uint32_t outputClk)</td></tr>
<tr class="memdesc:af7e47cad210fef11af7c6e3d99476345"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API will divide the system clock fed to I2C module between 12 and 100Mhz.It will also configure the I2C bus clock frequency.  <a href="#af7e47cad210fef11af7c6e3d99476345">More...</a><br /></td></tr>
<tr class="separator:af7e47cad210fef11af7c6e3d99476345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e4326f551e317e503aed2f2e685741"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ab7e4326f551e317e503aed2f2e685741">I2CMasterEnable</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:ab7e4326f551e317e503aed2f2e685741"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Enables the I2C module.This will bring the I2C module out of reset.  <a href="#ab7e4326f551e317e503aed2f2e685741">More...</a><br /></td></tr>
<tr class="separator:ab7e4326f551e317e503aed2f2e685741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0790b9cb5fadc53bd8914e6ce9bbceff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a0790b9cb5fadc53bd8914e6ce9bbceff">I2CMasterEnableFreeRun</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a0790b9cb5fadc53bd8914e6ce9bbceff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the I2C free run module.  <a href="#a0790b9cb5fadc53bd8914e6ce9bbceff">More...</a><br /></td></tr>
<tr class="separator:a0790b9cb5fadc53bd8914e6ce9bbceff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dba506386df11c425892d2bdeec693"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#af2dba506386df11c425892d2bdeec693">I2CMasterSetSysTest</a> (uintptr_t baseAddr, uint32_t sysTest)</td></tr>
<tr class="memdesc:af2dba506386df11c425892d2bdeec693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the I2C systest register.  <a href="#af2dba506386df11c425892d2bdeec693">More...</a><br /></td></tr>
<tr class="separator:af2dba506386df11c425892d2bdeec693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aee2da1595e015e038788c973eaff0f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a1aee2da1595e015e038788c973eaff0f">I2CMasterGetSysTest</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a1aee2da1595e015e038788c973eaff0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the I2C systest register.  <a href="#a1aee2da1595e015e038788c973eaff0f">More...</a><br /></td></tr>
<tr class="separator:a1aee2da1595e015e038788c973eaff0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35404b9b05de91c3b12a84ac8189e82e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a35404b9b05de91c3b12a84ac8189e82e">I2CMasterDisable</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a35404b9b05de91c3b12a84ac8189e82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the I2C Module.This will put the I2C module in reset. Only Tx and Rx are cleared,status bits are set their default values and all configuration registers are not reset, they keep their initial values.  <a href="#a35404b9b05de91c3b12a84ac8189e82e">More...</a><br /></td></tr>
<tr class="separator:a35404b9b05de91c3b12a84ac8189e82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea186117686f456bc4ef33b84e32a3d2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#aea186117686f456bc4ef33b84e32a3d2">I2CMasterBusBusy</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:aea186117686f456bc4ef33b84e32a3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines whether bus is busy or not.  <a href="#aea186117686f456bc4ef33b84e32a3d2">More...</a><br /></td></tr>
<tr class="separator:aea186117686f456bc4ef33b84e32a3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c0890f3cc0d42eec55107491af8183"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a10c0890f3cc0d42eec55107491af8183">I2CMasterBusy</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a10c0890f3cc0d42eec55107491af8183"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines whether Master is busy or not.  <a href="#a10c0890f3cc0d42eec55107491af8183">More...</a><br /></td></tr>
<tr class="separator:a10c0890f3cc0d42eec55107491af8183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0316e0e48a7fc3de15ef95e48798ca9a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a0316e0e48a7fc3de15ef95e48798ca9a">I2CMasterErr</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a0316e0e48a7fc3de15ef95e48798ca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines whether error occurred or not during I2C operation.  <a href="#a0316e0e48a7fc3de15ef95e48798ca9a">More...</a><br /></td></tr>
<tr class="separator:a0316e0e48a7fc3de15ef95e48798ca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cc90f3e5b094a135b58000fb902e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a18cc90f3e5b094a135b58000fb902e95">I2CMasterControl</a> (uintptr_t baseAddr, uint32_t <a class="el" href="gptpipc_8h.html#a2766e0be89a1a57a241e8557b71cf9e1">cmd</a>)</td></tr>
<tr class="memdesc:a18cc90f3e5b094a135b58000fb902e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configure I2C in different modes of operation.  <a href="#a18cc90f3e5b094a135b58000fb902e95">More...</a><br /></td></tr>
<tr class="separator:a18cc90f3e5b094a135b58000fb902e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0089d19230c4fe081210973d8836818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ae0089d19230c4fe081210973d8836818">I2CMasterStart</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:ae0089d19230c4fe081210973d8836818"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API starts a I2C transaction on the bus. This API must be called after all the configuration for the i2c module is done and after bringing I2C out of local reset.  <a href="#ae0089d19230c4fe081210973d8836818">More...</a><br /></td></tr>
<tr class="separator:ae0089d19230c4fe081210973d8836818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9f54c185546951f159083c183eecf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#aee9f54c185546951f159083c183eecf2">I2CMasterStop</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:aee9f54c185546951f159083c183eecf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API stops a I2C transaction on the bus. This API must be used in case a deliberate STOP needs to be sent on the bus.  <a href="#aee9f54c185546951f159083c183eecf2">More...</a><br /></td></tr>
<tr class="separator:aee9f54c185546951f159083c183eecf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa642dd67fecef1ad3e5ef7f55000845a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#aa642dd67fecef1ad3e5ef7f55000845a">I2CMasterIntEnableEx</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:aa642dd67fecef1ad3e5ef7f55000845a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables only specified I2C interrupts in master mode.  <a href="#aa642dd67fecef1ad3e5ef7f55000845a">More...</a><br /></td></tr>
<tr class="separator:aa642dd67fecef1ad3e5ef7f55000845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d3cbc1b3c0ff95301d5ce3c889fc0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a62d3cbc1b3c0ff95301d5ce3c889fc0d">I2CSlaveIntEnableEx</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:a62d3cbc1b3c0ff95301d5ce3c889fc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables only specified I2C interrupts in Slave mode.  <a href="#a62d3cbc1b3c0ff95301d5ce3c889fc0d">More...</a><br /></td></tr>
<tr class="separator:a62d3cbc1b3c0ff95301d5ce3c889fc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49cb986310631c775cc5d3297caa95c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ae49cb986310631c775cc5d3297caa95c">I2CMasterIntDisableEx</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:ae49cb986310631c775cc5d3297caa95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables only specified I2C interrupts in master mode.  <a href="#ae49cb986310631c775cc5d3297caa95c">More...</a><br /></td></tr>
<tr class="separator:ae49cb986310631c775cc5d3297caa95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ac755ae9f86307ac9144018f8a1644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ae8ac755ae9f86307ac9144018f8a1644">I2CSlaveIntDisableEx</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:ae8ac755ae9f86307ac9144018f8a1644"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables only specified I2C interrupts in Slave mode.  <a href="#ae8ac755ae9f86307ac9144018f8a1644">More...</a><br /></td></tr>
<tr class="separator:ae8ac755ae9f86307ac9144018f8a1644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978f9603a5e2eb4ece7242500abfb447"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a978f9603a5e2eb4ece7242500abfb447">I2CMasterIntStatus</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a978f9603a5e2eb4ece7242500abfb447"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the status of interrupts in master mode.  <a href="#a978f9603a5e2eb4ece7242500abfb447">More...</a><br /></td></tr>
<tr class="separator:a978f9603a5e2eb4ece7242500abfb447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5497fe32b19b942bebce7237d5e89447"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a5497fe32b19b942bebce7237d5e89447">I2CSlaveIntStatus</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a5497fe32b19b942bebce7237d5e89447"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the status of interrupts in slave mode.  <a href="#a5497fe32b19b942bebce7237d5e89447">More...</a><br /></td></tr>
<tr class="separator:a5497fe32b19b942bebce7237d5e89447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97961c14b8da314f6f677b8f0e0a3f24"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a97961c14b8da314f6f677b8f0e0a3f24">I2CMasterIntStatusEx</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:a97961c14b8da314f6f677b8f0e0a3f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the status of specified interrupts in master mode.  <a href="#a97961c14b8da314f6f677b8f0e0a3f24">More...</a><br /></td></tr>
<tr class="separator:a97961c14b8da314f6f677b8f0e0a3f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da72b58286b844126e06047c2abeadc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a1da72b58286b844126e06047c2abeadc">I2CSlaveIntStatusEx</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:a1da72b58286b844126e06047c2abeadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the status of specified interrupts in slave mode.  <a href="#a1da72b58286b844126e06047c2abeadc">More...</a><br /></td></tr>
<tr class="separator:a1da72b58286b844126e06047c2abeadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce48158a546fd5749e06096ed47713b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#acce48158a546fd5749e06096ed47713b">I2CMasterIntRawStatus</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:acce48158a546fd5749e06096ed47713b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the raw status of interrupts in master mode.  <a href="#acce48158a546fd5749e06096ed47713b">More...</a><br /></td></tr>
<tr class="separator:acce48158a546fd5749e06096ed47713b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d938ecd17a6fd0f95fd4c3cf49e6938"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a0d938ecd17a6fd0f95fd4c3cf49e6938">I2CSlaveIntRawStatus</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a0d938ecd17a6fd0f95fd4c3cf49e6938"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the raw status of interrupts in slave mode.  <a href="#a0d938ecd17a6fd0f95fd4c3cf49e6938">More...</a><br /></td></tr>
<tr class="separator:a0d938ecd17a6fd0f95fd4c3cf49e6938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5c85a5370665d97f8745207eb9a6d8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a9f5c85a5370665d97f8745207eb9a6d8">I2CMasterIntRawStatusEx</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:a9f5c85a5370665d97f8745207eb9a6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the raw status of specified interrupts in master mode.  <a href="#a9f5c85a5370665d97f8745207eb9a6d8">More...</a><br /></td></tr>
<tr class="separator:a9f5c85a5370665d97f8745207eb9a6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c4b12f6d765ee5d906ca02d38811ff"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a53c4b12f6d765ee5d906ca02d38811ff">I2CSlaveIntRawStatusEx</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:a53c4b12f6d765ee5d906ca02d38811ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the raw status of specified interrupts in slave mode.  <a href="#a53c4b12f6d765ee5d906ca02d38811ff">More...</a><br /></td></tr>
<tr class="separator:a53c4b12f6d765ee5d906ca02d38811ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab261590e559626347c2ee30413f3571b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ab261590e559626347c2ee30413f3571b">I2CMasterIntClearEx</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:ab261590e559626347c2ee30413f3571b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Clears the status of specified interrupts in master mode.  <a href="#ab261590e559626347c2ee30413f3571b">More...</a><br /></td></tr>
<tr class="separator:ab261590e559626347c2ee30413f3571b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d00fa468b1045a340f496b045d1a727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a7d00fa468b1045a340f496b045d1a727">I2CSlaveIntClearEx</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:a7d00fa468b1045a340f496b045d1a727"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Clears the status of specified interrupts in Slave mode.  <a href="#a7d00fa468b1045a340f496b045d1a727">More...</a><br /></td></tr>
<tr class="separator:a7d00fa468b1045a340f496b045d1a727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240c21589f87115e0c14737237e7ba76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a240c21589f87115e0c14737237e7ba76">I2CMasterIntRawStatusClearEx</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:a240c21589f87115e0c14737237e7ba76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Clears the raw status of specified interrupts in master mode.  <a href="#a240c21589f87115e0c14737237e7ba76">More...</a><br /></td></tr>
<tr class="separator:a240c21589f87115e0c14737237e7ba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7098c8aafb02b5fefc543c8b77bbe205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a7098c8aafb02b5fefc543c8b77bbe205">I2CSlaveIntRawStatusClearEx</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:a7098c8aafb02b5fefc543c8b77bbe205"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Clears the raw status of specified interrupts in Slave mode.  <a href="#a7098c8aafb02b5fefc543c8b77bbe205">More...</a><br /></td></tr>
<tr class="separator:a7098c8aafb02b5fefc543c8b77bbe205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80081679b5fd41ed52a1d6bcd2963cb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a80081679b5fd41ed52a1d6bcd2963cb7">I2CMasterSlaveAddrSet</a> (uintptr_t baseAddr, uint32_t slaveAdd)</td></tr>
<tr class="memdesc:a80081679b5fd41ed52a1d6bcd2963cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets the address of the slave device with which I2C wants to communicate.  <a href="#a80081679b5fd41ed52a1d6bcd2963cb7">More...</a><br /></td></tr>
<tr class="separator:a80081679b5fd41ed52a1d6bcd2963cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20d2a2517650ffc8cb24f59d8721e28"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ac20d2a2517650ffc8cb24f59d8721e28">I2CMasterSlaveAddrGet</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:ac20d2a2517650ffc8cb24f59d8721e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the address of the slave device with which I2C wants to communicate.  <a href="#ac20d2a2517650ffc8cb24f59d8721e28">More...</a><br /></td></tr>
<tr class="separator:ac20d2a2517650ffc8cb24f59d8721e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297979a6c020ccdee3ab0364651b1603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a297979a6c020ccdee3ab0364651b1603">I2CSetDataCount</a> (uintptr_t baseAddr, uint32_t <a class="el" href="tisci__rm__ra_8h.html#a86988a65e0d3ece7990c032c159786d6">count</a>)</td></tr>
<tr class="memdesc:a297979a6c020ccdee3ab0364651b1603"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configure I2C data count register with a value. The value in the I2C data count register indicate how many data words to transfer when the I2C is configured as a master-transmitter and repeat mode is off.  <a href="#a297979a6c020ccdee3ab0364651b1603">More...</a><br /></td></tr>
<tr class="separator:a297979a6c020ccdee3ab0364651b1603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85468476ec94b66fbbcf61b1fee3ffe"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ac85468476ec94b66fbbcf61b1fee3ffe">I2CDataCountGet</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:ac85468476ec94b66fbbcf61b1fee3ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the number of bytes transferred over the I2C bus. The value in the I2C data count register indicate how many data words to transfer when the I2C is configured as a master-transmitter and repeat mode is off.  <a href="#ac85468476ec94b66fbbcf61b1fee3ffe">More...</a><br /></td></tr>
<tr class="separator:ac85468476ec94b66fbbcf61b1fee3ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef4b4fcf6fa14d6c7c0e2ea510bf007"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a6ef4b4fcf6fa14d6c7c0e2ea510bf007">I2CFIFOThresholdConfig</a> (uintptr_t baseAddr, uint32_t thresholdVal, uint32_t flag)</td></tr>
<tr class="memdesc:a6ef4b4fcf6fa14d6c7c0e2ea510bf007"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the threshold value for FIFO buffer.  <a href="#a6ef4b4fcf6fa14d6c7c0e2ea510bf007">More...</a><br /></td></tr>
<tr class="separator:a6ef4b4fcf6fa14d6c7c0e2ea510bf007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad628a48cbb8b26a6f2e5361abd32ebab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ad628a48cbb8b26a6f2e5361abd32ebab">I2CFIFOClear</a> (uintptr_t baseAddr, uint32_t flag)</td></tr>
<tr class="memdesc:ad628a48cbb8b26a6f2e5361abd32ebab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears Transmit and Receive FIFO.  <a href="#ad628a48cbb8b26a6f2e5361abd32ebab">More...</a><br /></td></tr>
<tr class="separator:ad628a48cbb8b26a6f2e5361abd32ebab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e79b4da19e60b4ddad2fc40930de96a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a2e79b4da19e60b4ddad2fc40930de96a">I2CDMATxEventEnable</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a2e79b4da19e60b4ddad2fc40930de96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Enables generation of Transmit Event,when I2C_DATA register is empty.  <a href="#a2e79b4da19e60b4ddad2fc40930de96a">More...</a><br /></td></tr>
<tr class="separator:a2e79b4da19e60b4ddad2fc40930de96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4455936c0fbfdbf1f446a7b9f02d8267"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a4455936c0fbfdbf1f446a7b9f02d8267">I2CDMARxEventEnable</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a4455936c0fbfdbf1f446a7b9f02d8267"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Enables generation of Receive DMA Event, when I2C_DATA register is full.  <a href="#a4455936c0fbfdbf1f446a7b9f02d8267">More...</a><br /></td></tr>
<tr class="separator:a4455936c0fbfdbf1f446a7b9f02d8267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb0f019c3a60a1a393fd6e6c5cf5cc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#acdb0f019c3a60a1a393fd6e6c5cf5cc2">I2CDMATxEventDisable</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:acdb0f019c3a60a1a393fd6e6c5cf5cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Disables Transmit event.  <a href="#acdb0f019c3a60a1a393fd6e6c5cf5cc2">More...</a><br /></td></tr>
<tr class="separator:acdb0f019c3a60a1a393fd6e6c5cf5cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b9c86dd406672251b23fbbf48c159a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ac3b9c86dd406672251b23fbbf48c159a">I2CDMARxEventDisable</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:ac3b9c86dd406672251b23fbbf48c159a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Disables Receive event.  <a href="#ac3b9c86dd406672251b23fbbf48c159a">More...</a><br /></td></tr>
<tr class="separator:ac3b9c86dd406672251b23fbbf48c159a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1096e2f8ba9bb124c25bf3bbe945baa3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a1096e2f8ba9bb124c25bf3bbe945baa3">I2CBufferStatus</a> (uintptr_t baseAddr, uint32_t flag)</td></tr>
<tr class="memdesc:a1096e2f8ba9bb124c25bf3bbe945baa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the status of the internal buffers.  <a href="#a1096e2f8ba9bb124c25bf3bbe945baa3">More...</a><br /></td></tr>
<tr class="separator:a1096e2f8ba9bb124c25bf3bbe945baa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa231020729dffdb61621b7f58150b9ba"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#aa231020729dffdb61621b7f58150b9ba">I2CActiveOwnAddressGet</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:aa231020729dffdb61621b7f58150b9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns one of the module's four own addresses,which external master used when addressing the module.  <a href="#aa231020729dffdb61621b7f58150b9ba">More...</a><br /></td></tr>
<tr class="separator:aa231020729dffdb61621b7f58150b9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7852ba69f2d9ffe12d0cd623f4b979d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a7852ba69f2d9ffe12d0cd623f4b979d0">I2CClockBlockingControl</a> (uintptr_t baseAddr, uint32_t ownAdd0, uint32_t ownAdd1, uint32_t ownAdd2, uint32_t ownAdd3)</td></tr>
<tr class="memdesc:a7852ba69f2d9ffe12d0cd623f4b979d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API blocks or unblocks the clock for any of the module's four own addresses.  <a href="#a7852ba69f2d9ffe12d0cd623f4b979d0">More...</a><br /></td></tr>
<tr class="separator:a7852ba69f2d9ffe12d0cd623f4b979d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffa4f4ead92419b22dbbcb53341e324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a5ffa4f4ead92419b22dbbcb53341e324">I2COwnAddressSet</a> (uintptr_t baseAddr, uint32_t ownAdd, uint32_t flag)</td></tr>
<tr class="memdesc:a5ffa4f4ead92419b22dbbcb53341e324"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures any one of the own address field out of four present in I2C controller.  <a href="#a5ffa4f4ead92419b22dbbcb53341e324">More...</a><br /></td></tr>
<tr class="separator:a5ffa4f4ead92419b22dbbcb53341e324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dc0911bbcd6c367ad630ee87fc86d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a17dc0911bbcd6c367ad630ee87fc86d3">I2CSoftReset</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a17dc0911bbcd6c367ad630ee87fc86d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reset the entire I2C module.On reset,are set to power up reset values.  <a href="#a17dc0911bbcd6c367ad630ee87fc86d3">More...</a><br /></td></tr>
<tr class="separator:a17dc0911bbcd6c367ad630ee87fc86d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07bd7c0acc5549a5eea6bbb6a8b3a7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ae07bd7c0acc5549a5eea6bbb6a8b3a7b">I2CAutoIdleEnable</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:ae07bd7c0acc5549a5eea6bbb6a8b3a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables auto idle mechanism.  <a href="#ae07bd7c0acc5549a5eea6bbb6a8b3a7b">More...</a><br /></td></tr>
<tr class="separator:ae07bd7c0acc5549a5eea6bbb6a8b3a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7d5497b01c296b454253f09947052e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a6a7d5497b01c296b454253f09947052e">I2CAutoIdleDisable</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a6a7d5497b01c296b454253f09947052e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables auto idle mechanism.  <a href="#a6a7d5497b01c296b454253f09947052e">More...</a><br /></td></tr>
<tr class="separator:a6a7d5497b01c296b454253f09947052e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4086455f335cda1bd70ae2a25ed914ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a4086455f335cda1bd70ae2a25ed914ae">I2CGlobalWakeUpEnable</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a4086455f335cda1bd70ae2a25ed914ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables wakeup mechanism.  <a href="#a4086455f335cda1bd70ae2a25ed914ae">More...</a><br /></td></tr>
<tr class="separator:a4086455f335cda1bd70ae2a25ed914ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688ee1d3d813c493f61cc9051663c727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a688ee1d3d813c493f61cc9051663c727">I2CGlobalWakeUpDisable</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a688ee1d3d813c493f61cc9051663c727"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables wakeup mechanism.  <a href="#a688ee1d3d813c493f61cc9051663c727">More...</a><br /></td></tr>
<tr class="separator:a688ee1d3d813c493f61cc9051663c727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49db209898759fb62374bccda59f5375"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a49db209898759fb62374bccda59f5375">I2CIdleModeSelect</a> (uintptr_t baseAddr, uint32_t flag)</td></tr>
<tr class="memdesc:a49db209898759fb62374bccda59f5375"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API selects one of the idle mode operation mechanism.  <a href="#a49db209898759fb62374bccda59f5375">More...</a><br /></td></tr>
<tr class="separator:a49db209898759fb62374bccda59f5375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade693009997ecda4758297b314fb9da6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ade693009997ecda4758297b314fb9da6">I2CClockActivitySelect</a> (uintptr_t baseAddr, uint32_t flag)</td></tr>
<tr class="memdesc:ade693009997ecda4758297b314fb9da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disable external clock gating mechanism by selecting appropriate type of clock activity.  <a href="#ade693009997ecda4758297b314fb9da6">More...</a><br /></td></tr>
<tr class="separator:ade693009997ecda4758297b314fb9da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55867de3fbfbe4ae6883d0073fbe117"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#af55867de3fbfbe4ae6883d0073fbe117">I2CWakeUpEnable</a> (uintptr_t baseAddr, uint32_t eventFlag, uint32_t flag)</td></tr>
<tr class="memdesc:af55867de3fbfbe4ae6883d0073fbe117"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Enables a specific IRQ/DMA request source to generate an asynchronous wakeup signal.A wakeup is signalled to the local host if the corresponding event is captured by the core of the I2C controller.  <a href="#af55867de3fbfbe4ae6883d0073fbe117">More...</a><br /></td></tr>
<tr class="separator:af55867de3fbfbe4ae6883d0073fbe117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3095f0cd8cc7dd5aa367da12248f3576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a3095f0cd8cc7dd5aa367da12248f3576">I2CWakeUpDisable</a> (uintptr_t baseAddr, uint32_t eventFlag, uint32_t flag)</td></tr>
<tr class="memdesc:a3095f0cd8cc7dd5aa367da12248f3576"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Disables a specific IRQ/DMA request source to generate an asynchronous wakeup signal.A wakeup is signalled to the local host if the corresponding event is captured by the core of the I2C controller.  <a href="#a3095f0cd8cc7dd5aa367da12248f3576">More...</a><br /></td></tr>
<tr class="separator:a3095f0cd8cc7dd5aa367da12248f3576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2a77dbfae9f1eaa84abfc91beb9922"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a3d2a77dbfae9f1eaa84abfc91beb9922">I2CSystemStatusGet</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a3d2a77dbfae9f1eaa84abfc91beb9922"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API indicates the state of the reset in case of hardware reset,global reset or partial reset.  <a href="#a3d2a77dbfae9f1eaa84abfc91beb9922">More...</a><br /></td></tr>
<tr class="separator:a3d2a77dbfae9f1eaa84abfc91beb9922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430310d0e1158a6ed011d7764d544a7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a430310d0e1158a6ed011d7764d544a7d">I2CMasterDataPut</a> (uintptr_t baseAddr, uint8_t <a class="el" href="tisci__rm__psil_8h.html#a1e43bf7d608e87228b625cca2c04d641">data</a>)</td></tr>
<tr class="memdesc:a430310d0e1158a6ed011d7764d544a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API transmits a byte from the I2C in Master mode.  <a href="#a430310d0e1158a6ed011d7764d544a7d">More...</a><br /></td></tr>
<tr class="separator:a430310d0e1158a6ed011d7764d544a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fd25a8e1fedaef9e5f237d386c65df"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a14fd25a8e1fedaef9e5f237d386c65df">I2CMasterDataGet</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a14fd25a8e1fedaef9e5f237d386c65df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Receives a byte that has been sent to the I2C in Master mode.  <a href="#a14fd25a8e1fedaef9e5f237d386c65df">More...</a><br /></td></tr>
<tr class="separator:a14fd25a8e1fedaef9e5f237d386c65df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f98342b6f96389e70d2208987862cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a2f98342b6f96389e70d2208987862cdc">I2CSlaveDataPut</a> (uintptr_t baseAddr, uint32_t <a class="el" href="tisci__rm__psil_8h.html#a1e43bf7d608e87228b625cca2c04d641">data</a>)</td></tr>
<tr class="memdesc:a2f98342b6f96389e70d2208987862cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API transmits a byte from the I2C in Slave mode.  <a href="#a2f98342b6f96389e70d2208987862cdc">More...</a><br /></td></tr>
<tr class="separator:a2f98342b6f96389e70d2208987862cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1613225b7ffb90defe43434d47c8da"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#afc1613225b7ffb90defe43434d47c8da">I2CSlaveDataGet</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:afc1613225b7ffb90defe43434d47c8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Receives a byte that has been sent to the I2C in Slave mode.  <a href="#afc1613225b7ffb90defe43434d47c8da">More...</a><br /></td></tr>
<tr class="separator:afc1613225b7ffb90defe43434d47c8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad348fabc786a7771339a8de604358b88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#ad348fabc786a7771339a8de604358b88">I2CSyscInit</a> (uintptr_t baseAddr, uint32_t syscFlag)</td></tr>
<tr class="memdesc:ad348fabc786a7771339a8de604358b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures SYSC register.  <a href="#ad348fabc786a7771339a8de604358b88">More...</a><br /></td></tr>
<tr class="separator:ad348fabc786a7771339a8de604358b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af049e6b20f89c85ce6d39adb0b1de4c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#af049e6b20f89c85ce6d39adb0b1de4c3">I2CConfig</a> (uintptr_t baseAddr, uint32_t conParams)</td></tr>
<tr class="memdesc:af049e6b20f89c85ce6d39adb0b1de4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the I2C operation mode(F/S or HS), slave address 7bit or 10bit, own address 7bit or 10bit and start byte mode or normal mode of operation.  <a href="#af049e6b20f89c85ce6d39adb0b1de4c3">More...</a><br /></td></tr>
<tr class="separator:af049e6b20f89c85ce6d39adb0b1de4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d6c64a7fdb630ddb4e9c693f22847c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#a93d6c64a7fdb630ddb4e9c693f22847c">I2CFlushFifo</a> (uintptr_t baseAddr)</td></tr>
<tr class="memdesc:a93d6c64a7fdb630ddb4e9c693f22847c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This clears the I2C TX and RX FIFO.  <a href="#a93d6c64a7fdb630ddb4e9c693f22847c">More...</a><br /></td></tr>
<tr class="separator:a93d6c64a7fdb630ddb4e9c693f22847c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf41bfd45846a425a4616740418e2b7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html#aabf41bfd45846a425a4616740418e2b7">I2CGetEnabledIntStatus</a> (uintptr_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:aabf41bfd45846a425a4616740418e2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the status of enabled interrupt for the interrupt flag passed.  <a href="#aabf41bfd45846a425a4616740418e2b7">More...</a><br /></td></tr>
<tr class="separator:aabf41bfd45846a425a4616740418e2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac010109692dc03addb6c00209c915b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac010109692dc03addb6c00209c915b2c">&#9670;&nbsp;</a></span>I2C_INT_ARBITRATION_LOST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_ARBITRATION_LOST&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_AL_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_ARBITRATION_LOST - Arbitration lost interrupt. </p>

</div>
</div>
<a id="a3d380029b61a2bd7a3c5688f18b9145e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d380029b61a2bd7a3c5688f18b9145e">&#9670;&nbsp;</a></span>I2C_INT_NO_ACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_NO_ACK&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_NACK_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_NO_ACK - No acknowledgement interrupt. </p>

</div>
</div>
<a id="a084b97e99a4c2a54811f695b6699f1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084b97e99a4c2a54811f695b6699f1e9">&#9670;&nbsp;</a></span>I2C_INT_ADRR_READY_ACESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_ADRR_READY_ACESS&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_ARDY_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_ADRR_READY_ACESS - Register access ready interrupt. </p>

</div>
</div>
<a id="adfc05bc3084d9dfc0064885b59e900c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc05bc3084d9dfc0064885b59e900c0">&#9670;&nbsp;</a></span>I2C_INT_RECV_READY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_RECV_READY&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_RRDY_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_RECV_READY - Receive data ready interrupt. </p>

</div>
</div>
<a id="af28fb48a2ee9f9f68e71d27f76a9573c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28fb48a2ee9f9f68e71d27f76a9573c">&#9670;&nbsp;</a></span>I2C_INT_TRANSMIT_READY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_TRANSMIT_READY&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_XRDY_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_TRANSMIT_READY - Transmit data ready interrupt. </p>

</div>
</div>
<a id="a136608cb852a2c8169b276b7c9edbfb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136608cb852a2c8169b276b7c9edbfb5">&#9670;&nbsp;</a></span>I2C_INT_GENERAL_CALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_GENERAL_CALL&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_GC_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_GENERAL_CALL - General call Interrupt. </p>

</div>
</div>
<a id="a9def92e28c6611d76f6d937cddd72460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9def92e28c6611d76f6d937cddd72460">&#9670;&nbsp;</a></span>I2C_INT_START</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_START&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_STC_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_START - Start Condition interrupt. </p>

</div>
</div>
<a id="a54645dd39e076bb60ca7ec2d57f7ca7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54645dd39e076bb60ca7ec2d57f7ca7c">&#9670;&nbsp;</a></span>I2C_INT_ACCESS_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_ACCESS_ERROR&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_AERR_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_ACCESS_ERROR - Access Error interrupt. </p>

</div>
</div>
<a id="a72c1d12497392f4dd5ec4ce6400c5200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c1d12497392f4dd5ec4ce6400c5200">&#9670;&nbsp;</a></span>I2C_INT_STOP_CONDITION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_STOP_CONDITION&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_BF_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_STOP_CONDITION - Bus Free interrupt. </p>

</div>
</div>
<a id="a4f4d6beae050207191e4fa152a9c66e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4d6beae050207191e4fa152a9c66e8">&#9670;&nbsp;</a></span>I2C_INT_ADRR_SLAVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_ADRR_SLAVE&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_AAS_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_ADRR_SLAVE - Addressed as Slave interrupt. </p>

</div>
</div>
<a id="a4e253549399ea7eec4087006b0381617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e253549399ea7eec4087006b0381617">&#9670;&nbsp;</a></span>I2C_INT_TRANSMIT_UNDER_FLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_TRANSMIT_UNDER_FLOW&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_XUDF_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_TRANSMIT_UNDER_FLOW - Transmit underflow interrupt. </p>

</div>
</div>
<a id="a6592ee43a851ac305d1ee8f832026099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6592ee43a851ac305d1ee8f832026099">&#9670;&nbsp;</a></span>I2C_INT_RECV_OVER_RUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_RECV_OVER_RUN&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_ROVR_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_RECV_OVER_RUN - Receive overrun interrupt. </p>

</div>
</div>
<a id="ae39b3a5cd5f603ec0e9cd16b0b665284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39b3a5cd5f603ec0e9cd16b0b665284">&#9670;&nbsp;</a></span>I2C_INT_RECV_DRAIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_RECV_DRAIN&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_RDR_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_RECV_DRAIN - Receive Draining interrupt. </p>

</div>
</div>
<a id="af7e5617a0008db9ae4c83758e129a920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e5617a0008db9ae4c83758e129a920">&#9670;&nbsp;</a></span>I2C_INT_TRANSMIT_DRAIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_TRANSMIT_DRAIN&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_XDR_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_TRANSMIT_DRAIN - Transmit Draining interrupt. </p>

</div>
</div>
<a id="a4471c913d3fda09badbad20afc12124d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4471c913d3fda09badbad20afc12124d">&#9670;&nbsp;</a></span>I2C_INT_BUS_BUSY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_BUS_BUSY&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_RAW_BB_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_BUS_BUSY - Bus busy interrupt raw status. </p>

</div>
</div>
<a id="adf64ba80311c6866f0e30244278b9099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf64ba80311c6866f0e30244278b9099">&#9670;&nbsp;</a></span>I2C_INT_BUS_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_BUS_FREE&#160;&#160;&#160;((uint32_t) I2C_IRQSTATUS_RAW_BF_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_BUS_FREE - Bus free interrupt raw status. </p>

</div>
</div>
<a id="ad8b4bd4632e2cb83cfbbeb901ebbea7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b4bd4632e2cb83cfbbeb901ebbea7a">&#9670;&nbsp;</a></span>I2C_INT_ALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INT_ALL&#160;&#160;&#160;((uint32_t) 0x7FFFU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_INT_ALL - Enable all interrupt. </p>

</div>
</div>
<a id="ae2d1b528da6253fa0360552b101c01d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d1b528da6253fa0360552b101c01d9">&#9670;&nbsp;</a></span>I2C_TX_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_TX_MODE&#160;&#160;&#160;((uint32_t) 1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_TX_MODE - Transmit mode. </p>

</div>
</div>
<a id="ac72b16cdd19cf9125def8a811036c682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72b16cdd19cf9125def8a811036c682">&#9670;&nbsp;</a></span>I2C_RX_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_RX_MODE&#160;&#160;&#160;((uint32_t) 0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_RX_MODE - Receive mode. </p>

</div>
</div>
<a id="a0b2f7e51db56b8700bfe6e2447377354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2f7e51db56b8700bfe6e2447377354">&#9670;&nbsp;</a></span>I2C_TX_BUFFER_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_TX_BUFFER_STATUS&#160;&#160;&#160;((uint32_t) 0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_TX_BUFFER_STATUS - TX buffer status flag. </p>

</div>
</div>
<a id="af30874d9ff7ace1614572008b16622be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30874d9ff7ace1614572008b16622be">&#9670;&nbsp;</a></span>I2C_RX_BUFFER_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_RX_BUFFER_STATUS&#160;&#160;&#160;((uint32_t) 1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_RX_BUFFER_STATUS - RX buffer status flag. </p>

</div>
</div>
<a id="ab2c8ab2a4f1438202f08aa4e60ef0914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c8ab2a4f1438202f08aa4e60ef0914">&#9670;&nbsp;</a></span>I2C_FIFO_DEPTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FIFO_DEPTH&#160;&#160;&#160;((uint32_t) 2U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_FIFO_DEPTH - Internal FIFO depth flag. </p>

</div>
</div>
<a id="a7c751c0bbf436d25fd671a0f382718ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c751c0bbf436d25fd671a0f382718ca">&#9670;&nbsp;</a></span>I2C_WAKE_UP_ARBITRATION_LOST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_ARBITRATION_LOST&#160;&#160;&#160;(I2C_WE_AL_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_ARBITRATION_LOST - Arbitration lost IRQ wakeup set. </p>

</div>
</div>
<a id="a257f497be7bc2091d89c908aa2e13aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257f497be7bc2091d89c908aa2e13aee">&#9670;&nbsp;</a></span>I2C_WAKE_UP_NO_ACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_NO_ACK&#160;&#160;&#160;(I2C_WE_NACK_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_NO_ACK - No acknowledgment IRQ wakeup set. </p>

</div>
</div>
<a id="a85a61d38b5732c0c1709ff3caadb6f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a61d38b5732c0c1709ff3caadb6f1e">&#9670;&nbsp;</a></span>I2C_WAKE_UP_ADRR_RDY_ACCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_ADRR_RDY_ACCESS&#160;&#160;&#160;(I2C_WE_ARDY_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_ADRR_RDY_ACCESS - Register access ready IRQ wakeup set. </p>

</div>
</div>
<a id="adf92d884d412f2d1adb50a4caabd3e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf92d884d412f2d1adb50a4caabd3e21">&#9670;&nbsp;</a></span>I2C_WAKE_UP_GENERAL_CALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_GENERAL_CALL&#160;&#160;&#160;(I2C_WE_GC_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_GENERAL_CALL - General call IRQ wakeup set. </p>

</div>
</div>
<a id="a85ada87dc419cba2266aa733364157e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ada87dc419cba2266aa733364157e7">&#9670;&nbsp;</a></span>I2C_WAKE_UP_START</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_START&#160;&#160;&#160;(I2C_WE_STC_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_START - Start Condition IRQ wakeup set. </p>

</div>
</div>
<a id="a92294c85b548aafae84068e1ab7cd929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92294c85b548aafae84068e1ab7cd929">&#9670;&nbsp;</a></span>I2C_WAKE_UP_STOP_CONDITION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_STOP_CONDITION&#160;&#160;&#160;(I2C_WE_BF_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_STOP_CONDITION - Bus Free IRQ wakeup set. </p>

</div>
</div>
<a id="a54eb31aa204220038902a41e23fc1398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54eb31aa204220038902a41e23fc1398">&#9670;&nbsp;</a></span>I2C_WAKE_UP_ADRR_SLAVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_ADRR_SLAVE&#160;&#160;&#160;(I2C_WE_AAS_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_ADRR_SLAVE - Address as slave IRQ wakeup set. </p>

</div>
</div>
<a id="aa0627afb1a05d62c1576ecfea005af1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0627afb1a05d62c1576ecfea005af1d">&#9670;&nbsp;</a></span>I2C_WAKE_UP_TX_UNDER_FLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_TX_UNDER_FLOW&#160;&#160;&#160;(I2C_WE_XUDF_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_TX_UNDER_FLOW - Transmit underflow wakeup set. </p>

</div>
</div>
<a id="a7ad9412e2ef6ea5a1a260a44e6a14802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad9412e2ef6ea5a1a260a44e6a14802">&#9670;&nbsp;</a></span>I2C_WAKE_UP_RECV_OVER_RUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_RECV_OVER_RUN&#160;&#160;&#160;(I2C_WE_ROVR_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_RECV_OVER_RUN - Receive overrun wakeup set. </p>

</div>
</div>
<a id="a50a41e30f92cc7a6e99cf9580f800b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a41e30f92cc7a6e99cf9580f800b62">&#9670;&nbsp;</a></span>I2C_WAKE_UP_RECV_DRAIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_RECV_DRAIN&#160;&#160;&#160;(I2C_WE_RDR_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_RECV_DRAIN - Receive Draining wakeup set. </p>

</div>
</div>
<a id="a881f0ec02d5c5ae7b13112f2fe8bee04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881f0ec02d5c5ae7b13112f2fe8bee04">&#9670;&nbsp;</a></span>I2C_WAKE_UP_TRANSMIT_DRAIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_TRANSMIT_DRAIN&#160;&#160;&#160;(I2C_WE_XDR_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_TRANSMIT_DRAIN - Transmit Draining wakeup set. </p>

</div>
</div>
<a id="a57485894314e7e3ba9164efe8f4f1273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57485894314e7e3ba9164efe8f4f1273">&#9670;&nbsp;</a></span>I2C_WAKE_UP_DATA_RECV_TX_RDY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_DATA_RECV_TX_RDY&#160;&#160;&#160;(I2C_WE_DRDY_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_DATA_RECV_TX_RDY - Receive/Transmit data ready IRQ wakeup set. </p>

</div>
</div>
<a id="a02778ddf4fd640b00ccaf6cf25d96774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02778ddf4fd640b00ccaf6cf25d96774">&#9670;&nbsp;</a></span>I2C_WAKE_UP_IRQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_IRQ&#160;&#160;&#160;((uint32_t) 1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_IRQ - IRQ request source. </p>

</div>
</div>
<a id="a64978ac277e98e958b20412bdeb2708f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64978ac277e98e958b20412bdeb2708f">&#9670;&nbsp;</a></span>I2C_WAKE_UP_DMA_RECV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_DMA_RECV&#160;&#160;&#160;((uint32_t) 2U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_DMA_RECV - DMA receive request source. </p>

</div>
</div>
<a id="addf1457b73520fe87795ab51ad2d053e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf1457b73520fe87795ab51ad2d053e">&#9670;&nbsp;</a></span>I2C_WAKE_UP_DMA_TRANSMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_WAKE_UP_DMA_TRANSMIT&#160;&#160;&#160;((uint32_t) 3U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_WAKE_UP_DMA_TRANSMIT - DMA transmit request source. </p>

</div>
</div>
<a id="a5d2f924cd6a70be33ebe6a320489a7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2f924cd6a70be33ebe6a320489a7f8">&#9670;&nbsp;</a></span>I2C_STATUS_RAW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STATUS_RAW&#160;&#160;&#160;((uint32_t) 0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_STATUS_RAW - RAW IRQ status. </p>

</div>
</div>
<a id="a46e55953a8d401c11b99d8ca9508e7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e55953a8d401c11b99d8ca9508e7de">&#9670;&nbsp;</a></span>I2C_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STATUS&#160;&#160;&#160;((uint32_t) 1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_STATUS - IRQ status. </p>

</div>
</div>
<a id="a9df53a3f3b6cf8121350e400ad36bddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df53a3f3b6cf8121350e400ad36bddb">&#9670;&nbsp;</a></span>HAL_HSI2C_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAL_HSI2C_SUCCESS&#160;&#160;&#160;((uint32_t) 0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HAL_HSI2C_SUCCESS - I2C success. </p>

</div>
</div>
<a id="abcde35e8d012da56044653bb2e6c8942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcde35e8d012da56044653bb2e6c8942">&#9670;&nbsp;</a></span>HAL_HSI2C_FAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAL_HSI2C_FAIL&#160;&#160;&#160;((uint32_t) 1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HAL_HSI2C_FAIL - I2C fail. </p>

</div>
</div>
<a id="a5607d186fb5e2336d6e33e8934287c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5607d186fb5e2336d6e33e8934287c9c">&#9670;&nbsp;</a></span>I2C_OWN_ADDR_0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_OWN_ADDR_0&#160;&#160;&#160;((uint32_t) 0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_OWN_ADDR_0 - set own address 0. </p>

</div>
</div>
<a id="adf7f38299a6d385d9a37b780d230af3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7f38299a6d385d9a37b780d230af3b">&#9670;&nbsp;</a></span>I2C_OWN_ADDR_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_OWN_ADDR_1&#160;&#160;&#160;((uint32_t) 1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_OWN_ADDR_1 - set own address 1. </p>

</div>
</div>
<a id="a143a4e198cb74e71552a9bdd00fdf107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143a4e198cb74e71552a9bdd00fdf107">&#9670;&nbsp;</a></span>I2C_OWN_ADDR_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_OWN_ADDR_2&#160;&#160;&#160;((uint32_t) 2U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_OWN_ADDR_2 - set own address 2. </p>

</div>
</div>
<a id="a29723c3ffdb0ba69b389b06ecd30c7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29723c3ffdb0ba69b389b06ecd30c7a1">&#9670;&nbsp;</a></span>I2C_OWN_ADDR_3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_OWN_ADDR_3&#160;&#160;&#160;((uint32_t) 3U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_OWN_ADDR_3 - set own address 3. </p>

</div>
</div>
<a id="a6ac0effda3bee4a5df40e5434af25de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac0effda3bee4a5df40e5434af25de1">&#9670;&nbsp;</a></span>I2C_AUTOIDLE_DISABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_AUTOIDLE_DISABLE&#160;&#160;&#160;(I2C_SYSC_AUTOIDLE_DISABLE)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_AUTOIDLE_DISABLE Disable auto idle mechanism. </p>

</div>
</div>
<a id="ac9f040d4dc1a864fafbc4d072a4d3307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f040d4dc1a864fafbc4d072a4d3307">&#9670;&nbsp;</a></span>I2C_AUTOIDLE_ENABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_AUTOIDLE_ENABLE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint32_t) I2C_SYSC_AUTOIDLE_ENABLE &lt;&lt; \</div><div class="line">                                   I2C_SYSC_AUTOIDLE_SHIFT)</div></div><!-- fragment -->
<p>I2C_AUTOIDLE_ENABLE Enable autoidle mechanism. </p>

</div>
</div>
<a id="a3750144770d6c938b11ac15c089f8ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3750144770d6c938b11ac15c089f8ff8">&#9670;&nbsp;</a></span>I2C_CUT_OFF_BOTH_CLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CUT_OFF_BOTH_CLK&#160;&#160;&#160;(I2C_SYSC_CLKACTIVITY_BOOTHOFF)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_CUT_OFF_BOTH_CLK Both OCP and SYS Clk are cut off. </p>

</div>
</div>
<a id="a2695814468c7f6e0acd258cfbe563650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2695814468c7f6e0acd258cfbe563650">&#9670;&nbsp;</a></span>I2C_CUT_OFF_SYS_CLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CUT_OFF_SYS_CLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint32_t) I2C_SYSC_CLKACTIVITY_OCPON &lt;&lt; \</div><div class="line">                                       I2C_SYSC_CLKACTIVITY_SHIFT)</div></div><!-- fragment -->
<p>I2C_CUT_OFF_SYS_CLK system clock is cut off;OCP clock is kept alive. </p>

</div>
</div>
<a id="a5f4543b403f86cd6aa95720e48a2ef46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4543b403f86cd6aa95720e48a2ef46">&#9670;&nbsp;</a></span>I2C_CUT_OFF_OCP_CLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CUT_OFF_OCP_CLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint32_t) I2C_SYSC_CLKACTIVITY_SYSON &lt;&lt; \</div><div class="line">                                       I2C_SYSC_CLKACTIVITY_SHIFT)</div></div><!-- fragment -->
<p>I2C_CUT_OFF_OCP_CLK OCP clock is cut off;system clock is is kept alive. </p>

</div>
</div>
<a id="a50c414a4f827da665641f67335b0069b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c414a4f827da665641f67335b0069b">&#9670;&nbsp;</a></span>I2C_KEEP_ALIVE_BOTH_CLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_KEEP_ALIVE_BOTH_CLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint32_t) I2C_SYSC_CLKACTIVITY_BOOTHON &lt;&lt; \</div><div class="line">                                      I2C_SYSC_CLKACTIVITY_SHIFT)</div></div><!-- fragment -->
<p>I2C_KEEP_ALIVE_BOTH_CLK BOTH OCP and SYS Clk are kept alive. </p>

</div>
</div>
<a id="adf48b38fc48ce930d867ce2c08146ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf48b38fc48ce930d867ce2c08146ee4">&#9670;&nbsp;</a></span>I2C_ENAWAKEUP_DISABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_ENAWAKEUP_DISABLE&#160;&#160;&#160;(I2C_SYSC_ENAWAKEUP_DISABLE)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_ENAWAKEUP__DISABLE Disable wakeup mechanism. </p>

</div>
</div>
<a id="aa210eb67c8d05158898425f17ce4f9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa210eb67c8d05158898425f17ce4f9fd">&#9670;&nbsp;</a></span>I2C_ENAWAKEUP_ENABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_ENAWAKEUP_ENABLE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint32_t) I2C_SYSC_ENAWAKEUP_ENABLE &lt;&lt; \</div><div class="line">                                     I2C_SYSC_ENAWAKEUP_SHIFT)</div></div><!-- fragment -->
<p>I2C_ENAWAKEUP__ENABLE Enable wakeup mechanism. </p>

</div>
</div>
<a id="ac9730764d2965668c2b3c36ea20fef0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9730764d2965668c2b3c36ea20fef0a">&#9670;&nbsp;</a></span>I2C_FORCE_IDLE_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FORCE_IDLE_MODE&#160;&#160;&#160;(I2C_SYSC_IDLEMODE_FORCEIDLE)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_FORCE_IDLE_MODE selects forced idle mode operation. </p>

</div>
</div>
<a id="af9012367ff47082655e4900b5c6f07e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9012367ff47082655e4900b5c6f07e4">&#9670;&nbsp;</a></span>I2C_NO_IDLE_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_NO_IDLE_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint32_t) I2C_SYSC_IDLEMODE_NOIDLE &lt;&lt; \</div><div class="line">                                         I2C_SYSC_IDLEMODE_SHIFT)</div></div><!-- fragment -->
<p>I2C_NO_IDLE_MODE selects no idle mode operation. </p>

</div>
</div>
<a id="a41a53a6f2246172270a67d2923cd42fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a53a6f2246172270a67d2923cd42fa">&#9670;&nbsp;</a></span>I2C_SMART_IDLE_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SMART_IDLE_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint32_t) I2C_SYSC_IDLEMODE_SMARTIDLE &lt;&lt; \</div><div class="line">                                         I2C_SYSC_IDLEMODE_SHIFT)</div></div><!-- fragment -->
<p>I2C_SMART_IDLE_MODE selects smart idle mode operation. </p>

</div>
</div>
<a id="acaa537d702685d719b6f65567cd8ed3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa537d702685d719b6f65567cd8ed3c">&#9670;&nbsp;</a></span>I2C_SMART_IDLE_WAKEUP_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SMART_IDLE_WAKEUP_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint32_t) I2C_SYSC_IDLEMODE_SMARTIDLE_WAKEUP &lt;&lt; \</div><div class="line">                                         I2C_SYSC_IDLEMODE_SHIFT)</div></div><!-- fragment -->
<p>I2C_SMART_IDLE_WAKEUP_MODE selects smart idle wakeup mode of operation. </p>

</div>
</div>
<a id="a6c2d28f09dd9987e54f3a4bbcd76d51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2d28f09dd9987e54f3a4bbcd76d51c">&#9670;&nbsp;</a></span>I2C_OPMODE_FAST_STAND_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_OPMODE_FAST_STAND_MODE&#160;&#160;&#160;(I2C_CON_OPMODE_FSI2C)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_OPMODE_FAST_STAND_MODE Select Fast/Standard mode. </p>

</div>
</div>
<a id="a3f3733757714133a61de91b331a3a170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3733757714133a61de91b331a3a170">&#9670;&nbsp;</a></span>I2C_OPMODE_HIGH_SPEED_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_OPMODE_HIGH_SPEED_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint32_t) I2C_CON_OPMODE_HSI2C &lt;&lt; \</div><div class="line">                                          I2C_CON_OPMODE_SHIFT)</div></div><!-- fragment -->
<p>I2C_OPMODE_HIGH_SPEED_MODE Select high speed mode. </p>

</div>
</div>
<a id="ae0a8884975edb84b7fd6c19a8f6b5a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a8884975edb84b7fd6c19a8f6b5a47">&#9670;&nbsp;</a></span>I2C_NORMAL_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_NORMAL_MODE&#160;&#160;&#160;(I2C_CON_STB_NORMAL)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_NORMAL_MODE Select Normal mode. </p>

</div>
</div>
<a id="a2d8eb7308263ad6c9c2b0223d5c01b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8eb7308263ad6c9c2b0223d5c01b28">&#9670;&nbsp;</a></span>I2C_STB_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STB_MODE&#160;&#160;&#160;((uint32_t) I2C_CON_STB_STB &lt;&lt; I2C_CON_STB_SHIFT)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_STB_MODE Select start byte mode. </p>

</div>
</div>
<a id="ab85dd7164b7a822072c71114d52b706a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85dd7164b7a822072c71114d52b706a">&#9670;&nbsp;</a></span>I2C_XSA_7BIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_XSA_7BIT&#160;&#160;&#160;(I2C_CON_XSA_B07)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_XSA_7BIT Slave address 7 bit mode. </p>

</div>
</div>
<a id="aa110029997826069a9c1a28207d79101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa110029997826069a9c1a28207d79101">&#9670;&nbsp;</a></span>I2C_XSA_10BIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_XSA_10BIT&#160;&#160;&#160;((uint32_t) I2C_CON_XSA_B10 &lt;&lt; I2C_CON_XSA_SHIFT)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_XSA_10BIT Slave address 10 bit mode. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af7e47cad210fef11af7c6e3d99476345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e47cad210fef11af7c6e3d99476345">&#9670;&nbsp;</a></span>I2CMasterInitExpClk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterInitExpClk </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sysClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>internalClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>outputClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API will divide the system clock fed to I2C module between 12 and 100Mhz.It will also configure the I2C bus clock frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">sysClk</td><td>It is the System clock fed to I2C module. </td></tr>
    <tr><td class="paramname">internalClk</td><td>It is the internal clock used by I2C module.Which is obtained by scaling System clock fed to I2C module. </td></tr>
    <tr><td class="paramname">outputClk</td><td>It is the required I2C bus speed or frequency.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ab7e4326f551e317e503aed2f2e685741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e4326f551e317e503aed2f2e685741">&#9670;&nbsp;</a></span>I2CMasterEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterEnable </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Enables the I2C module.This will bring the I2C module out of reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a0790b9cb5fadc53bd8914e6ce9bbceff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0790b9cb5fadc53bd8914e6ce9bbceff">&#9670;&nbsp;</a></span>I2CMasterEnableFreeRun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterEnableFreeRun </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the I2C free run module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="af2dba506386df11c425892d2bdeec693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dba506386df11c425892d2bdeec693">&#9670;&nbsp;</a></span>I2CMasterSetSysTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterSetSysTest </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sysTest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the I2C systest register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>It is the Memory address of the I2C instance used.</td></tr>
    <tr><td class="paramname">sysTest</td><td>The system test register value to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a1aee2da1595e015e038788c973eaff0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aee2da1595e015e038788c973eaff0f">&#9670;&nbsp;</a></span>I2CMasterGetSysTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterGetSysTest </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the I2C systest register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>It is the Memory address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sysTest The system test register value to be set. </dd></dl>

</div>
</div>
<a id="a35404b9b05de91c3b12a84ac8189e82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35404b9b05de91c3b12a84ac8189e82e">&#9670;&nbsp;</a></span>I2CMasterDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterDisable </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the I2C Module.This will put the I2C module in reset. Only Tx and Rx are cleared,status bits are set their default values and all configuration registers are not reset, they keep their initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="aea186117686f456bc4ef33b84e32a3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea186117686f456bc4ef33b84e32a3d2">&#9670;&nbsp;</a></span>I2CMasterBusBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t I2CMasterBusBusy </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines whether bus is busy or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns 1 if bus is busy. returns 0 if bus is free. </dd></dl>

</div>
</div>
<a id="a10c0890f3cc0d42eec55107491af8183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c0890f3cc0d42eec55107491af8183">&#9670;&nbsp;</a></span>I2CMasterBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterBusy </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines whether Master is busy or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns 1 if bus is busy. returns 0 if bus is free. </dd></dl>

</div>
</div>
<a id="a0316e0e48a7fc3de15ef95e48798ca9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0316e0e48a7fc3de15ef95e48798ca9a">&#9670;&nbsp;</a></span>I2CMasterErr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterErr </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines whether error occurred or not during I2C operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error status.If error has occurred it returns a non zero value. If no error has occurred then return status will be zero. </dd></dl>

</div>
</div>
<a id="a18cc90f3e5b094a135b58000fb902e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cc90f3e5b094a135b58000fb902e95">&#9670;&nbsp;</a></span>I2CMasterControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterControl </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configure I2C in different modes of operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">cmd</td><td>It is the value which configures I2C in different modes of operation.<br />
 cmd can take following macros.<br />
 I2C_CFG_MST_TX - Configure'sI2C as Master-Transmitter.<br />
 I2C_CFG_MST_RX - Configurers I2C as Master-Receiver.<br />
 I2C_CFG_STOP - Configurers I2C to generate stop condition when DCOUNT counts down to zero.<br />
 I2C_CFG_N0RMAL_MODE - Configurers I2C in normal mode.<br />
 I2C_CFG_SRT_BYTE_MODE - Configurers I2C in start byte mode.<br />
 I2C_CFG_7BIT_SLAVE_ADDR - Configurers I2C to address seven bit addressed slave.<br />
 I2C_CFG_10BIT_SLAVE_ADDR - Configurers I2C to address ten bit addressed slave.<br />
 I2C_CFG_10BIT_OWN_ADDR_0 - Enable 10bit addressing mode for own address 0.<br />
 I2C_CFG_10BIT_OWN_ADDR_1 - Enable 10bit addressing mode for own address 1.<br />
 I2C_CFG_10BIT_OWN_ADDR_2 - Enable 10bit addressing mode for own address 2.<br />
 I2C_CFG_10BIT_OWN_ADDR_3 - Enable 10bit addressing mode for own address 3.<br />
 I2C_CFG_7BIT_OWN_ADDR_0 - Enable 7bit addressing mode for own address 0.<br />
 I2C_CFG_7BIT_OWN_ADDR_1 - Enable 7bit addressing mode for own address 1 .<br />
 I2C_CFG_7BIT_OWN_ADDR_2 - Enable 7bit addressing mode for own address 2.<br />
 I2C_CFG_7BIT_OWN_ADDR_3 - Enable 7bit addressing mode for own address 3.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ae0089d19230c4fe081210973d8836818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0089d19230c4fe081210973d8836818">&#9670;&nbsp;</a></span>I2CMasterStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterStart </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API starts a I2C transaction on the bus. This API must be called after all the configuration for the i2c module is done and after bringing I2C out of local reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="aee9f54c185546951f159083c183eecf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9f54c185546951f159083c183eecf2">&#9670;&nbsp;</a></span>I2CMasterStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterStop </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API stops a I2C transaction on the bus. This API must be used in case a deliberate STOP needs to be sent on the bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="aa642dd67fecef1ad3e5ef7f55000845a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa642dd67fecef1ad3e5ef7f55000845a">&#9670;&nbsp;</a></span>I2CMasterIntEnableEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterIntEnableEx </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables only specified I2C interrupts in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts that are required to be enabled.<br />
 intFlag can take following values.<br />
 I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 I2C_INT_START - Start condition interrupt.<br />
 I2C_INT_ACCESS_ERROR - Access error interrupt.<br />
 I2C_INT_STOP_CONDITION - Stop condition interrupt.<br />
 I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.<br />
 I2C_INT_TRANSMIT_UNDER_FLOW - Transmit under flow interrupt.<br />
 I2C_INT_RECV_OVER_RUN - Receive overrun interrupt.<br />
 I2C_INT_RECV_DRAIN - Receive drain interrupt.<br />
 I2C_INT_TRANSMIT_DRAIN - Transmit drain interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a62d3cbc1b3c0ff95301d5ce3c889fc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d3cbc1b3c0ff95301d5ce3c889fc0d">&#9670;&nbsp;</a></span>I2CSlaveIntEnableEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveIntEnableEx </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables only specified I2C interrupts in Slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts that are required to be enabled.<br />
 intFlag can take following values.<br />
 I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 I2C_INT_START - Start condition interrupt.<br />
 I2C_INT_ACCESS_ERROR - Access error interrupt.<br />
 I2C_INT_STOP_CONDITION - Stop condition interrupt.<br />
 I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.<br />
 I2C_INT_TRANSMIT_UNDER_FLOW - Transmit under flow interrupt.<br />
 I2C_INT_RECV_OVER_RUN - Receive overrun interrupt.<br />
 I2C_INT_RECV_DRAIN - Receive drain interrupt.<br />
 I2C_INT_TRANSMIT_DRAIN - Transmit drain interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ae49cb986310631c775cc5d3297caa95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49cb986310631c775cc5d3297caa95c">&#9670;&nbsp;</a></span>I2CMasterIntDisableEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterIntDisableEx </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables only specified I2C interrupts in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts that are required to be disabled<br />
 intFlag can take following values.<br />
 I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 I2C_INT_START - Start condition interrupt.<br />
 I2C_INT_ACCESS_ERROR - Access error interrupt.<br />
 I2C_INT_STOP_CONDITION - Stop condition interrupt.<br />
 I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.<br />
 I2C_INT_TRANSMIT_UNDER_FLOW - Transmit under flow interrupt.<br />
 I2C_INT_RECV_OVER_RUN - Receive overrun interrupt.<br />
 I2C_INT_RECV_DRAIN - Receive drain interrupt.<br />
 I2C_INT_TRANSMIT_DRAIN - Transmit drain interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ae8ac755ae9f86307ac9144018f8a1644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ac755ae9f86307ac9144018f8a1644">&#9670;&nbsp;</a></span>I2CSlaveIntDisableEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveIntDisableEx </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables only specified I2C interrupts in Slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts that are required to be disabled<br />
 intFlag can take following values.<br />
 I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 I2C_INT_START - Start condition interrupt.<br />
 I2C_INT_ACCESS_ERROR - Access error interrupt.<br />
 I2C_INT_STOP_CONDITION - Stop condition interrupt.<br />
 I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.<br />
 I2C_INT_TRANSMIT_UNDER_FLOW - Transmit under flow interrupt.<br />
 I2C_INT_RECV_OVER_RUN - Receive overrun interrupt.<br />
 I2C_INT_RECV_DRAIN - Receive drain interrupt.<br />
 I2C_INT_TRANSMIT_DRAIN - Transmit drain interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a978f9603a5e2eb4ece7242500abfb447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978f9603a5e2eb4ece7242500abfb447">&#9670;&nbsp;</a></span>I2CMasterIntStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterIntStatus </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the status of interrupts in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of interrupts. </dd></dl>

</div>
</div>
<a id="a5497fe32b19b942bebce7237d5e89447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5497fe32b19b942bebce7237d5e89447">&#9670;&nbsp;</a></span>I2CSlaveIntStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CSlaveIntStatus </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the status of interrupts in slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of interrupts. </dd></dl>

</div>
</div>
<a id="a97961c14b8da314f6f677b8f0e0a3f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97961c14b8da314f6f677b8f0e0a3f24">&#9670;&nbsp;</a></span>I2CMasterIntStatusEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterIntStatusEx </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the status of specified interrupts in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts whose status needs to be returned.<br />
 intFlag can take following macros.<br />
 I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C register ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 I2C_INT_START - Start condition interrupt.<br />
 I2C_INT_ACCESS_ERROR - Access error interrupt.<br />
 I2C_INT_STOP_CONDITION - Stop condition interrupt.<br />
 I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.<br />
 I2C_INT_TRANSMIT_UNDER_FLOW - Transmit under flow interrupt.<br />
 I2C_INT_RECV_OVER_RUN - Receive overrun interrupt.<br />
 I2C_INT_BUS_BUSY - Bus busy.<br />
 I2C_INT_RECV_DRAIN - Receive drain interrupt.<br />
 I2C_INT_TRANSMIT_DRAIN - Transmit drain interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of specified interrupts. </dd></dl>

</div>
</div>
<a id="a1da72b58286b844126e06047c2abeadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da72b58286b844126e06047c2abeadc">&#9670;&nbsp;</a></span>I2CSlaveIntStatusEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CSlaveIntStatusEx </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the status of specified interrupts in slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts whose status needs to be returned.<br />
 intFlag can take following macros.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 I2C_INT_START - Start condition interrupt.<br />
 I2C_INT_ACCESS_ERROR - Access error interrupt.<br />
 I2C_INT_STOP_CONDITION - Stop condition interrupt.<br />
 I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.<br />
 I2C_INT_TRANSMIT_UNDER_FLOW - Transmit under flow interrupt.<br />
 I2C_INT_RECV_OVER_RUN - Receive overrun interrupt.<br />
 I2C_INT_BUS_BUSY - Bus busy.<br />
 I2C_INT_RECV_DRAIN - Receive drain interrupt.<br />
 I2C_INT_TRANSMIT_DRAIN - Transmit drain interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of specified interrupts. </dd></dl>

</div>
</div>
<a id="acce48158a546fd5749e06096ed47713b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce48158a546fd5749e06096ed47713b">&#9670;&nbsp;</a></span>I2CMasterIntRawStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterIntRawStatus </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the raw status of interrupts in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw status of interrupts. </dd></dl>

</div>
</div>
<a id="a0d938ecd17a6fd0f95fd4c3cf49e6938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d938ecd17a6fd0f95fd4c3cf49e6938">&#9670;&nbsp;</a></span>I2CSlaveIntRawStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CSlaveIntRawStatus </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the raw status of interrupts in slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw status of interrupts. </dd></dl>

</div>
</div>
<a id="a9f5c85a5370665d97f8745207eb9a6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5c85a5370665d97f8745207eb9a6d8">&#9670;&nbsp;</a></span>I2CMasterIntRawStatusEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterIntRawStatusEx </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the raw status of specified interrupts in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts whose raw status needs to be returned.<br />
 intFlag can take following macros.<br />
 I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 I2C_INT_START - Start condition interrupt.<br />
 I2C_INT_ACCESS_ERROR - Access error interrupt.<br />
 I2C_INT_STOP_CONDITION - Stop condition interrupt.<br />
 I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.<br />
 I2C_INT_TRANSMIT_UNDER_FLOW - Transmit under flow interrupt.<br />
 I2C_INT_RECV_OVER_RUN - Receive overrun interrupt.<br />
 I2C_INT_BUS_BUSY - Bus busy.<br />
 I2C_INT_RECV_DRAIN - Receive drain interrupt.<br />
 I2C_INT_TRANSMIT_DRAIN - Transmit drain interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of specified interrupts. </dd></dl>

</div>
</div>
<a id="a53c4b12f6d765ee5d906ca02d38811ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c4b12f6d765ee5d906ca02d38811ff">&#9670;&nbsp;</a></span>I2CSlaveIntRawStatusEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CSlaveIntRawStatusEx </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the raw status of specified interrupts in slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts whose raw status needs to be returned.<br />
 intFlag can take following macros.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 I2C_INT_START - Start condition interrupt.<br />
 I2C_INT_ACCESS_ERROR - Access error interrupt.<br />
 I2C_INT_STOP_CONDITION - Stop condition interrupt.<br />
 I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.<br />
 I2C_INT_TRANSMIT_UNDER_FLOW - Transmit under flow interrupt.<br />
 I2C_INT_RECV_OVER_RUN - Receive overrun interrupt.<br />
 I2C_INT_BUS_BUSY - Bus busy.<br />
 I2C_INT_RECV_DRAIN - Receive drain interrupt.<br />
 I2C_INT_TRANSMIT_DRAIN - Transmit drain interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of specified interrupts. </dd></dl>

</div>
</div>
<a id="ab261590e559626347c2ee30413f3571b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab261590e559626347c2ee30413f3571b">&#9670;&nbsp;</a></span>I2CMasterIntClearEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterIntClearEx </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Clears the status of specified interrupts in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts whose status needs to be cleared<br />
 intFlag can take following macros.<br />
 I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C registers ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 I2C_INT_START - Start condition interrupt.<br />
 I2C_INT_ACCESS_ERROR - Access error interrupt.<br />
 I2C_INT_STOP_CONDITION - Stop condition interrupt.<br />
 I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.<br />
 I2C_INT_TRANSMIT_UNDER_FLOW - Transmit under flow interrupt.<br />
 I2C_INT_RECV_DRAIN - Receive drain interrupt.<br />
 I2C_INT_TRANSMIT_DRAIN - Transmit drain interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a7d00fa468b1045a340f496b045d1a727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d00fa468b1045a340f496b045d1a727">&#9670;&nbsp;</a></span>I2CSlaveIntClearEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveIntClearEx </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Clears the status of specified interrupts in Slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts whose status needs to be cleared<br />
 intFlag can take following macros.<br />
 I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C registers ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 I2C_INT_START - Start condition interrupt.<br />
 I2C_INT_ACCESS_ERROR - Access error interrupt.<br />
 I2C_INT_STOP_CONDITION - Stop condition interrupt.<br />
 I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.<br />
 I2C_INT_TRANSMIT_UNDER_FLOW - Transmit under flow interrupt.<br />
 I2C_INT_RECV_DRAIN - Receive drain interrupt.<br />
 I2C_INT_TRANSMIT_DRAIN - Transmit drain interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a240c21589f87115e0c14737237e7ba76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240c21589f87115e0c14737237e7ba76">&#9670;&nbsp;</a></span>I2CMasterIntRawStatusClearEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterIntRawStatusClearEx </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Clears the raw status of specified interrupts in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts whose status needs to be cleared<br />
 intFlag can take following macros.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a7098c8aafb02b5fefc543c8b77bbe205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7098c8aafb02b5fefc543c8b77bbe205">&#9670;&nbsp;</a></span>I2CSlaveIntRawStatusClearEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveIntRawStatusClearEx </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Clears the raw status of specified interrupts in Slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts whose status needs to be cleared<br />
 intFlag can take following macros.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C register are ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a80081679b5fd41ed52a1d6bcd2963cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80081679b5fd41ed52a1d6bcd2963cb7">&#9670;&nbsp;</a></span>I2CMasterSlaveAddrSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterSlaveAddrSet </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slaveAdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets the address of the slave device with which I2C wants to communicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">slaveAdd</td><td>slave address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ac20d2a2517650ffc8cb24f59d8721e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20d2a2517650ffc8cb24f59d8721e28">&#9670;&nbsp;</a></span>I2CMasterSlaveAddrGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterSlaveAddrGet </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the address of the slave device with which I2C wants to communicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slave address. </dd></dl>

</div>
</div>
<a id="a297979a6c020ccdee3ab0364651b1603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297979a6c020ccdee3ab0364651b1603">&#9670;&nbsp;</a></span>I2CSetDataCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSetDataCount </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configure I2C data count register with a value. The value in the I2C data count register indicate how many data words to transfer when the I2C is configured as a master-transmitter and repeat mode is off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">count</td><td>It is value which is set to I2C data count register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ac85468476ec94b66fbbcf61b1fee3ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85468476ec94b66fbbcf61b1fee3ffe">&#9670;&nbsp;</a></span>I2CDataCountGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CDataCountGet </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the number of bytes transferred over the I2C bus. The value in the I2C data count register indicate how many data words to transfer when the I2C is configured as a master-transmitter and repeat mode is off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes transferred over the I2C bus. </dd></dl>

</div>
</div>
<a id="a6ef4b4fcf6fa14d6c7c0e2ea510bf007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef4b4fcf6fa14d6c7c0e2ea510bf007">&#9670;&nbsp;</a></span>I2CFIFOThresholdConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CFIFOThresholdConfig </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thresholdVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the threshold value for FIFO buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">thresholdVal</td><td>It is the threshold value for FIFO buffer.Which is used to specify the trigger level for data transfer or data receive transfers. </td></tr>
    <tr><td class="paramname">flag</td><td>It specifies FIFO buffer in TX mode or RX mode.<br />
<pre class="fragment">     flag can take following macros.\n

    I2C_TX_MODE.\n
    I2C_RX_MODE.\n
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ad628a48cbb8b26a6f2e5361abd32ebab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad628a48cbb8b26a6f2e5361abd32ebab">&#9670;&nbsp;</a></span>I2CFIFOClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CFIFOClear </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears Transmit and Receive FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">flag</td><td>It specifies Transmit FIFO or Receive FIFO.<br />
<pre class="fragment">     flag can take following macros.\n

    I2C_TX_MODE - .\n
    I2C_RX_MODE - .\n
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a2e79b4da19e60b4ddad2fc40930de96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e79b4da19e60b4ddad2fc40930de96a">&#9670;&nbsp;</a></span>I2CDMATxEventEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CDMATxEventEnable </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Enables generation of Transmit Event,when I2C_DATA register is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a4455936c0fbfdbf1f446a7b9f02d8267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4455936c0fbfdbf1f446a7b9f02d8267">&#9670;&nbsp;</a></span>I2CDMARxEventEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CDMARxEventEnable </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Enables generation of Receive DMA Event, when I2C_DATA register is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="acdb0f019c3a60a1a393fd6e6c5cf5cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb0f019c3a60a1a393fd6e6c5cf5cc2">&#9670;&nbsp;</a></span>I2CDMATxEventDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CDMATxEventDisable </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Disables Transmit event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ac3b9c86dd406672251b23fbbf48c159a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b9c86dd406672251b23fbbf48c159a">&#9670;&nbsp;</a></span>I2CDMARxEventDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CDMARxEventDisable </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Disables Receive event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a1096e2f8ba9bb124c25bf3bbe945baa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1096e2f8ba9bb124c25bf3bbe945baa3">&#9670;&nbsp;</a></span>I2CBufferStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CBufferStatus </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the status of the internal buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">flag</td><td>It specifies required status field.<br />
<pre class="fragment">    BufStatOp can take following macros.\n

    I2C_TX_BUFFER_STATUS - Indicates the number of data bytes still.
                             left to be written in TXFIFO\n
    I2C_RX_BUFFER_STATUS - Indicates the number of bytes to be
                             transferred from the FIFO at the end
                             of the I2C transfer.\n
    I2C_FIFO_DEPTH       - Internal FIFO buffer depth.\n
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>required status of internal buffer. </dd></dl>

</div>
</div>
<a id="aa231020729dffdb61621b7f58150b9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa231020729dffdb61621b7f58150b9ba">&#9670;&nbsp;</a></span>I2CActiveOwnAddressGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CActiveOwnAddressGet </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns one of the module's four own addresses,which external master used when addressing the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of the module's four own address the external master used when addressing the module. returns HSI2C_FAIL if failed to get own address </dd></dl>

</div>
</div>
<a id="a7852ba69f2d9ffe12d0cd623f4b979d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7852ba69f2d9ffe12d0cd623f4b979d0">&#9670;&nbsp;</a></span>I2CClockBlockingControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CClockBlockingControl </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ownAdd0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ownAdd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ownAdd2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ownAdd3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API blocks or unblocks the clock for any of the module's four own addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
    <tr><td class="paramname">ownAdd0</td><td>It is value which blocks or unblocks clock to i2c if an external master using own address 0.</td></tr>
    <tr><td class="paramname">ownAdd1</td><td>It is value which blocks or unblocks clock to i2c if an external master using own address 1.</td></tr>
    <tr><td class="paramname">ownAdd2</td><td>It is value which blocks or unblocks clock to i2c if an external master using own address 2.</td></tr>
    <tr><td class="paramname">ownAdd3</td><td>It is value which blocks or unblocks clock to i2c if an external master using own address 0.</td></tr>
  </table>
  </dd>
</dl>
<p>0 - Unblocks clock to i2c 1 - Blocks clock to i2c </p><dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a5ffa4f4ead92419b22dbbcb53341e324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffa4f4ead92419b22dbbcb53341e324">&#9670;&nbsp;</a></span>I2COwnAddressSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2COwnAddressSet </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ownAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures any one of the own address field out of four present in I2C controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">ownAdd</td><td>Own address to be set. </td></tr>
    <tr><td class="paramname">flag</td><td>It specifies the any one of the own address field out of four.<br />
 flag can take following values.<br />
 I2C_OWN_ADDR_0.<br />
 I2C_OWN_ADDR_1.<br />
 I2C_OWN_ADDR_2.<br />
 I2C_OWN_ADDR_3.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a17dc0911bbcd6c367ad630ee87fc86d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17dc0911bbcd6c367ad630ee87fc86d3">&#9670;&nbsp;</a></span>I2CSoftReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSoftReset </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reset the entire I2C module.On reset,are set to power up reset values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ae07bd7c0acc5549a5eea6bbb6a8b3a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07bd7c0acc5549a5eea6bbb6a8b3a7b">&#9670;&nbsp;</a></span>I2CAutoIdleEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CAutoIdleEnable </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables auto idle mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a6a7d5497b01c296b454253f09947052e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7d5497b01c296b454253f09947052e">&#9670;&nbsp;</a></span>I2CAutoIdleDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CAutoIdleDisable </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables auto idle mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a4086455f335cda1bd70ae2a25ed914ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4086455f335cda1bd70ae2a25ed914ae">&#9670;&nbsp;</a></span>I2CGlobalWakeUpEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CGlobalWakeUpEnable </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables wakeup mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a688ee1d3d813c493f61cc9051663c727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688ee1d3d813c493f61cc9051663c727">&#9670;&nbsp;</a></span>I2CGlobalWakeUpDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CGlobalWakeUpDisable </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables wakeup mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a49db209898759fb62374bccda59f5375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49db209898759fb62374bccda59f5375">&#9670;&nbsp;</a></span>I2CIdleModeSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CIdleModeSelect </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API selects one of the idle mode operation mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">flag</td><td>It is the value which determines the type of idle mode operation.<br />
 idleMode can take following values.<br />
 I2C_FORCE_IDLE_MODE - selects forced idle mode operation.<br />
 I2C_NO_IDLE_MODE - selects no idle mode operation.<br />
 I2C_SMART_IDLE_MODE - selects smart idle mode operation.<br />
 I2C_SMART_IDLE_WAKEUP_MODE - selects smart idle wakeup mode of operation.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ade693009997ecda4758297b314fb9da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade693009997ecda4758297b314fb9da6">&#9670;&nbsp;</a></span>I2CClockActivitySelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CClockActivitySelect </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disable external clock gating mechanism by selecting appropriate type of clock activity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">flag</td><td>It is the value which determines the type of clock activity.<br />
 clkAct can take following values.<br />
 I2C_CUT_OFF_BOTH_CLK - Both OCP and SYS CLK are cut off.<br />
 I2C_CUT_OFF_SYS_CLK - system clock is cut off;OCP clock is kept alive.<br />
 I2C_CUT_OFF_OCP_CLK - OCP clock is cut off;system clock is is kept alive<br />
 I2C_KEEP_ALIVE_BOTH_CLK - BOTH OCP and SYS CLK are kept alive.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="af55867de3fbfbe4ae6883d0073fbe117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55867de3fbfbe4ae6883d0073fbe117">&#9670;&nbsp;</a></span>I2CWakeUpEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CWakeUpEnable </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Enables a specific IRQ/DMA request source to generate an asynchronous wakeup signal.A wakeup is signalled to the local host if the corresponding event is captured by the core of the I2C controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">eventFlag</td><td>It specifies for which event wakeup signal has to Enable.<br />
 eventFlag can take following values.<br />
 I2C_WAKE_UP_ARBITRATION_LOST - Arbitration-lost wakeup signal.<br />
 I2C_WAKE_UP_NO_ACK - No-acknowledgement wakeup signal.<br />
 I2C_WAKE_UP_ADRR_READY_ACCESS - No-acknowledgement wakeup signal.<br />
 I2C_WAKE_UP_GENERAL_CALL - General call wakeup signal.<br />
 I2C_WAKE_UP_START - Start condition wakeup signal.<br />
 I2C_WAKE_UP_STOP_CONDITION - Stop condition wakeup signal.<br />
 I2C_WAKE_UP_ADRR_SLAVE - Address-as-slave wakeup signal.<br />
 I2C_WAKE_UP_TX_UNDER_FLOW - Transmit under flow wakeup signal.<br />
 I2C_WAKE_UP_RECV_OVER_RUN - Receive overrun wakeup signal.<br />
 I2C_WAKE_UP_RECV_DRAIN - Receive drain wakeup signal.<br />
 I2C_WAKE_UP_TRANSMIT_DRAIN - Transmit drain wakeup signal.<br />
 I2C_WAKE_UP_DATA_RECV_TX_RDY - Receive-data-ready wakeup signal.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>It specifies IRQ or DMA Transmit or DMA receive request source to generate asynchronous wake up signal.<br />
 flag can take following values.<br />
 I2C_WAKE_UP_IRQ.<br />
 I2C_WAKE_UP_DMA_RECV.<br />
 I2C_WAKE_UP_DMA_TRANMIT.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a3095f0cd8cc7dd5aa367da12248f3576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3095f0cd8cc7dd5aa367da12248f3576">&#9670;&nbsp;</a></span>I2CWakeUpDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CWakeUpDisable </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Disables a specific IRQ/DMA request source to generate an asynchronous wakeup signal.A wakeup is signalled to the local host if the corresponding event is captured by the core of the I2C controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">eventFlag</td><td>It specifies for which event wakeup signal has to disabled.<br />
 intFlag can take following macros.<br />
 I2C_WAKE_UP_ARBITRATION_LOST - Arbitration-lost wakeup signal.<br />
 I2C_WAKE_UP_NO_ACK - No-acknowledgement wakeup signal.<br />
 I2C_WAKE_UP_ADRR_RDY_ACCESS - No-acknowledgement wakeup signal.<br />
 I2C_WAKE_UP_GENERAL_CALL - General call wakeup signal.<br />
 I2C_WAKE_UP_START - Start condition wakeup signal.<br />
 I2C_WAKE_UP_STOP_CONDITION - Stop condition wakeup signal.<br />
 I2C_WAKE_UP_ADRR_SLAVE - Address-as-slave wakeup signal.<br />
 I2C_WAKE_UP_TX_UNDER_FLOW - Transmit under flow wakeup signal.<br />
 I2C_WAKE_UP_RECV_OVER_RUN - Receive overrun wakeup signal.<br />
 I2C_WAKE_UP_RECV_DRAIN - Receive drain wakeup signal.<br />
 I2C_WAKE_UP_TRANSMIT_DRAIN - Transmit drain wakeup signal.<br />
 I2C_WAKE_UP_DATA_RECV_TX_RDY - Receive-data-ready wakeup signal.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>It specifies IRQ or DMA Transmit or DMA receive request source to generate asynchronous wake up signal.<br />
 flag can take following values.<br />
 I2C_WAKE_UP_IRQ.<br />
 I2C_WAKE_UP_DMA_RECV.<br />
 I2C_WAKE_UP_DMA_TRANMIT.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a3d2a77dbfae9f1eaa84abfc91beb9922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2a77dbfae9f1eaa84abfc91beb9922">&#9670;&nbsp;</a></span>I2CSystemStatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CSystemStatusGet </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API indicates the state of the reset in case of hardware reset,global reset or partial reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns "1" if reset is completed. returns "0" if internal module reset is ongoing. </dd></dl>

</div>
</div>
<a id="a430310d0e1158a6ed011d7764d544a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430310d0e1158a6ed011d7764d544a7d">&#9670;&nbsp;</a></span>I2CMasterDataPut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterDataPut </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API transmits a byte from the I2C in Master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">data</td><td>data to be transmitted from the I2C Master.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a id="a14fd25a8e1fedaef9e5f237d386c65df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14fd25a8e1fedaef9e5f237d386c65df">&#9670;&nbsp;</a></span>I2CMasterDataGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2CMasterDataGet </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Receives a byte that has been sent to the I2C in Master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte received from by the I2C in Master mode. </dd></dl>

</div>
</div>
<a id="a2f98342b6f96389e70d2208987862cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f98342b6f96389e70d2208987862cdc">&#9670;&nbsp;</a></span>I2CSlaveDataPut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveDataPut </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API transmits a byte from the I2C in Slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">data</td><td>data to be transmitted from the I2C in Slave mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="afc1613225b7ffb90defe43434d47c8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1613225b7ffb90defe43434d47c8da">&#9670;&nbsp;</a></span>I2CSlaveDataGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2CSlaveDataGet </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Receives a byte that has been sent to the I2C in Slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte received from by the I2C in Slave mode. </dd></dl>

</div>
</div>
<a id="ad348fabc786a7771339a8de604358b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad348fabc786a7771339a8de604358b88">&#9670;&nbsp;</a></span>I2CSyscInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSyscInit </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>syscFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures SYSC register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">syscFlag</td><td>value of sysc register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af049e6b20f89c85ce6d39adb0b1de4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af049e6b20f89c85ce6d39adb0b1de4c3">&#9670;&nbsp;</a></span>I2CConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CConfig </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>conParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the I2C operation mode(F/S or HS), slave address 7bit or 10bit, own address 7bit or 10bit and start byte mode or normal mode of operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">conParams</td><td>Is the structure defining the configure parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>struct I2CconParams_s </dd></dl>

</div>
</div>
<a id="a93d6c64a7fdb630ddb4e9c693f22847c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d6c64a7fdb630ddb4e9c693f22847c">&#9670;&nbsp;</a></span>I2CFlushFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CFlushFifo </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This clears the I2C TX and RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="aabf41bfd45846a425a4616740418e2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf41bfd45846a425a4616740418e2b7">&#9670;&nbsp;</a></span>I2CGetEnabledIntStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CGetEnabledIntStatus </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the status of enabled interrupt for the interrupt flag passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>I2C base address. </td></tr>
    <tr><td class="paramname">intFlag</td><td>It specifies the interrupts that are required to be enabled.<br />
 intFlag can take following values.<br />
 I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt.<br />
 I2C_INT_NO_ACK - No-acknowledgement interrupt.<br />
 I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access.<br />
 I2C_INT_RECV_READY - Receive-data-ready interrupt.<br />
 I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt.<br />
 I2C_INT_GENERAL_CALL - General call interrupt.<br />
 I2C_INT_START - Start condition interrupt.<br />
 I2C_INT_ACCESS_ERROR - Access error interrupt.<br />
 I2C_INT_STOP_CONDITION - Stop condition interrupt.<br />
 I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.<br />
 I2C_INT_TRANSMIT_UNDER_FLOW - Transmit under flow interrupt.<br />
 I2C_INT_RECV_OVER_RUN - Receive overrun interrupt.<br />
 I2C_INT_RECV_DRAIN - Receive drain interrupt.<br />
 I2C_INT_TRANSMIT_DRAIN - Transmit drain interrupt.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of specified interrupts </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_93501a11e921083efbd154e0cdff5f10.html">packages</a></li><li class="navelem"><a class="el" href="dir_b59fa847594ba2e55d37d32c1afb17da.html">ti</a></li><li class="navelem"><a class="el" href="dir_6714554a377e9eea584c5edeb2f684c7.html">csl</a></li><li class="navelem"><a class="el" href="dir_d7c4508447702eee9f9e2fb20993bd7e.html">src</a></li><li class="navelem"><a class="el" href="dir_af962a7d312e0da9e8f277325625cc72.html">ip</a></li><li class="navelem"><a class="el" href="dir_f695ba231dc26809da3a7e5475beda77.html">i2c</a></li><li class="navelem"><a class="el" href="dir_9781d0131208aa89621da22140e162b1.html">V2</a></li><li class="navelem"><a class="el" href="i2c_8h.html">i2c.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
